<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>7&nbsp; Data Manipulations – Base R Essentials</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./iteration.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./manipulations.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Data Manipulations</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Base R Essentials</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Getting Started with Base R</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./objects1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Objects - Vectors, Matrices, and Arrays</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./objects2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Objects - Lists and Data Frames</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Subsetting.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Subsetting Objects</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./functions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Writing User-Defined Functions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./iteration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Iteration</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./manipulations.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Data Manipulations</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#creating-and-re-coding-variables" id="toc-creating-and-re-coding-variables" class="nav-link active" data-scroll-target="#creating-and-re-coding-variables"><span class="header-section-number">7.1</span> Creating and Re-coding Variables</a>
  <ul class="collapse">
  <li><a href="#creating-variables-using-relational-operators" id="toc-creating-variables-using-relational-operators" class="nav-link" data-scroll-target="#creating-variables-using-relational-operators"><span class="header-section-number">7.1.1</span> Creating Variables Using Relational Operators</a></li>
  <li><a href="#creating-variables-using-ifelse" id="toc-creating-variables-using-ifelse" class="nav-link" data-scroll-target="#creating-variables-using-ifelse"><span class="header-section-number">7.1.2</span> Creating Variables Using <code>ifelse()</code></a></li>
  <li><a href="#creating-factors-using-the-cut-function" id="toc-creating-factors-using-the-cut-function" class="nav-link" data-scroll-target="#creating-factors-using-the-cut-function"><span class="header-section-number">7.1.3</span> Creating Factors Using the <code>cut()</code> Function</a></li>
  </ul></li>
  <li><a href="#handling-data-with-duplicated-elements" id="toc-handling-data-with-duplicated-elements" class="nav-link" data-scroll-target="#handling-data-with-duplicated-elements"><span class="header-section-number">7.2</span> Handling Data with Duplicated Elements</a>
  <ul class="collapse">
  <li><a href="#duplicated-elements-in-vectors" id="toc-duplicated-elements-in-vectors" class="nav-link" data-scroll-target="#duplicated-elements-in-vectors"><span class="header-section-number">7.2.1</span> Duplicated Elements in Vectors</a></li>
  <li><a href="#duplicated-rows-or-columns-in-matrices" id="toc-duplicated-rows-or-columns-in-matrices" class="nav-link" data-scroll-target="#duplicated-rows-or-columns-in-matrices"><span class="header-section-number">7.2.2</span> Duplicated Rows or Columns in Matrices</a></li>
  <li><a href="#duplicated-records-in-data-frames" id="toc-duplicated-records-in-data-frames" class="nav-link" data-scroll-target="#duplicated-records-in-data-frames"><span class="header-section-number">7.2.3</span> Duplicated Records in Data Frames</a></li>
  </ul></li>
  <li><a href="#merging-data-frames" id="toc-merging-data-frames" class="nav-link" data-scroll-target="#merging-data-frames"><span class="header-section-number">7.3</span> Merging Data Frames</a></li>
  <li><a href="#reshaping-data" id="toc-reshaping-data" class="nav-link" data-scroll-target="#reshaping-data"><span class="header-section-number">7.4</span> Reshaping Data</a>
  <ul class="collapse">
  <li><a href="#stacking-and-unstacking-data" id="toc-stacking-and-unstacking-data" class="nav-link" data-scroll-target="#stacking-and-unstacking-data"><span class="header-section-number">7.4.1</span> Stacking and Unstacking Data</a></li>
  <li><a href="#reshaping-data-frames-with-reshape" id="toc-reshaping-data-frames-with-reshape" class="nav-link" data-scroll-target="#reshaping-data-frames-with-reshape"><span class="header-section-number">7.4.2</span> Reshaping Data Frames with <code>reshape()</code></a></li>
  </ul></li>
  <li><a href="#aggregating-data" id="toc-aggregating-data" class="nav-link" data-scroll-target="#aggregating-data"><span class="header-section-number">7.5</span> Aggregating Data</a>
  <ul class="collapse">
  <li><a href="#aggregation-with-aggregate" id="toc-aggregation-with-aggregate" class="nav-link" data-scroll-target="#aggregation-with-aggregate"><span class="header-section-number">7.5.1</span> Aggregation with <code>aggregate()</code></a></li>
  <li><a href="#applying-functions-by-group-with-by" id="toc-applying-functions-by-group-with-by" class="nav-link" data-scroll-target="#applying-functions-by-group-with-by"><span class="header-section-number">7.5.2</span> Applying Functions by Group with <code>by()</code></a></li>
  <li><a href="#computing-group-summaries-with-ave" id="toc-computing-group-summaries-with-ave" class="nav-link" data-scroll-target="#computing-group-summaries-with-ave"><span class="header-section-number">7.5.3</span> Computing Group Summaries with <code>ave()</code></a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Data Manipulations</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Having already acquired the skills to subset or sort data in R, we now delve into additional applications for manipulating data. One crucial aspect is <em>re-coding variables</em>, where we can transform existing data into new categories or formats to better suit our analysis. Additionally, mastering the handling of <em>duplicated data</em> is essential for ensuring the accuracy of our analyses, allowing us to identify and manage duplicate entries efficiently. Furthermore, learning techniques for <em>merging data</em> from different sources empowers us to integrate diverse datasets seamlessly, facilitating more comprehensive analyses and insights. These applications not only enhance our ability to manipulate data effectively but also broaden the scope of analyses we can perform, enabling us to extract valuable information and make informed decisions in various domains.</p>
<section id="creating-and-re-coding-variables" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="creating-and-re-coding-variables"><span class="header-section-number">7.1</span> Creating and Re-coding Variables</h2>
<p>Creating a new variable based on an existing one is a common task in data manipulation. You can add a new variable to an existing data frame using either the dollar sign (<code>$</code>) or square brackets (<code>[</code> or <code>[[</code>). For example:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>d <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">a =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">b =</span> <span class="dv">5</span><span class="sc">:</span><span class="dv">8</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>d<span class="sc">$</span>c <span class="ot">&lt;-</span> d<span class="sc">$</span>a <span class="sc">+</span> d<span class="sc">$</span>b             <span class="co"># using $ to add a new column</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>d[<span class="st">"d"</span>] <span class="ot">&lt;-</span> d[[<span class="st">"a"</span>]] <span class="sc">+</span> <span class="dv">2</span>       <span class="co"># using [ and [[ to add a new column</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>d[[<span class="st">"e"</span>]] <span class="ot">&lt;-</span> <span class="fu">log</span>(d[[<span class="st">"b"</span>]])    </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>d</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  a b  c d        e
1 1 5  6 3 1.609438
2 2 6  8 4 1.791759
3 3 7 10 5 1.945910
4 4 8 12 6 2.079442</code></pre>
</div>
</div>
<p>This yields the data frame with the new variables <code>c</code> , <code>d</code> , and <code>e</code> added as combinations or transformations of the original columns.</p>
<p>In practice, creating new variables often goes hand-in-hand with recoding or transforming existing variables. Below, we explore several methods for creating or recoding variables in base R.</p>
<section id="creating-variables-using-relational-operators" class="level3" data-number="7.1.1">
<h3 data-number="7.1.1" class="anchored" data-anchor-id="creating-variables-using-relational-operators"><span class="header-section-number">7.1.1</span> Creating Variables Using Relational Operators</h3>
<p>We often create <em>indicator</em> variables based on existing continuous or categorical variables, usually for modeling purposes or to present data differently. These indicators typically take values of 1 or 0 (or are represented as logical <code>TRUE</code> / <code>FALSE</code> values). They are easily created using relational operators. When comparing a variable with a value, the result is a logical vector of <code>TRUE</code> or <code>FALSE</code>. If we want the result as numeric values <code>1</code> and <code>0</code>, we can wrap the expression in <code>as.integer()</code> to convert the logicals to 1/0.</p>
<p>For example, using the painters dataset from the <code>MASS</code> package, suppose we want to create a logical indicator variable showing whether each painter’s Drawing score is above or below the mean of all painters’Drawing scores. We can do this with the following commands:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MASS)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>painters<span class="sc">$</span>Drawing_ind <span class="ot">&lt;-</span> painters<span class="sc">$</span>Drawing <span class="sc">&gt;=</span> <span class="fu">mean</span>(painters<span class="sc">$</span>Drawing)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(painters[, <span class="fu">c</span>(<span class="st">"Drawing"</span>, <span class="st">"Drawing_ind"</span>)])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>              Drawing Drawing_ind
Da Udine            8       FALSE
Da Vinci           16        TRUE
Del Piombo         13        TRUE
Del Sarto          16        TRUE
Fr. Penni          15        TRUE
Guilio Romano      16        TRUE</code></pre>
</div>
</div>
<p>The commands above add a new column <code>Drawing_ind</code> that is <code>TRUE</code> if the painter’s <code>Drawing</code> score is above the mean, and <code>FALSE</code> otherwise.</p>
<p>We can similarly use relational operators to create an <em>ordinal</em> categorical variable with more than two levels. For instance, suppose we want to create a new variable <code>Comp_ord</code> based on the painters’ Composition score with the following rules:</p>
<ul>
<li>If <code>Composition</code> &lt; 8, assign <code>Comp_ord</code> = 1</li>
<li>If 8 <span class="math inline">\(\ge\)</span> <code>Composition</code> &lt; 12, assign <code>Comp_ord</code> = 2</li>
<li>If <code>Composition</code> <span class="math inline">\(\ge\)</span> 12, assign <code>Comp_ord</code> = 3</li>
</ul>
<p>We can achieve this by exploiting the fact that logical comparisons in R can be coerced to 1/0 values. One concise method is:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>painters<span class="sc">$</span>Comp_ord <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">+</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  (painters<span class="sc">$</span>Composition <span class="sc">&gt;=</span> <span class="dv">8</span>) <span class="sc">+</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  (painters<span class="sc">$</span>Composition <span class="sc">&gt;=</span> <span class="dv">12</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(painters[, <span class="fu">c</span>(<span class="st">"Composition"</span>, <span class="st">"Comp_ord"</span>)])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>              Composition Comp_ord
Da Udine               10        2
Da Vinci               15        3
Del Piombo              8        2
Del Sarto              12        3
Fr. Penni               0        1
Guilio Romano          15        3</code></pre>
</div>
</div>
<p>The logic here is that the expression adds 1 for each threshold passed. All observations start at 1 (the lowest category). If <code>Composition</code> <span class="math inline">\(\ge\)</span> 8 , we add 1 (making it 2 for those cases). If <code>Composition</code> <span class="math inline">\(\ge\)</span> 12 , we add another 1 (making it 3 for those cases that exceed both thresholds).</p>
<p>It’s good practice to verify that the newly created variable is correct. One way to check <code>Comp_ord</code> is by using the <code>tapply()</code> function to compute the minimum and maximum Composition within each category of <code>Comp_ord</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tapply</span>(painters<span class="sc">$</span>Composition, painters<span class="sc">$</span>Comp_ord, min)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> 1  2  3 
 0  8 12 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tapply</span>(painters<span class="sc">$</span>Composition, painters<span class="sc">$</span>Comp_ord, max)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> 1  2  3 
 6 11 18 </code></pre>
</div>
</div>
<p>This should confirm that for <code>Comp_ord</code> category 1, <code>Composition</code> ranges 0–7; for category 2, 8–11; and for category 3, 12–18, matching our intended cut-offs.</p>
</section>
<section id="creating-variables-using-ifelse" class="level3" data-number="7.1.2">
<h3 data-number="7.1.2" class="anchored" data-anchor-id="creating-variables-using-ifelse"><span class="header-section-number">7.1.2</span> Creating Variables Using <code>ifelse()</code></h3>
<p>The <code>ifelse()</code> function is a vectorized conditional function handy for creating indicator, ordinal, or categorical variables. It has the form <code>ifelse(test, yes, no)</code> , where <code>test</code> is a logical condition, <code>yes</code> is the value to return for observations where the <code>test</code> is <code>TRUE</code>, and <code>no</code> is the value to return where the <code>test</code> is <code>FALSE</code>. The value returned by <code>ifelse()</code> will have the same length as the <code>test</code> vector, with each element filled by either the <code>yes</code> or <code>no</code> value depending on the condition<span class="citation" data-cites="matloff2011art">(<a href="#ref-matloff2011art" role="doc-biblioref">Matloff 2011</a>)</span>.</p>
<p>For instance, consider again the <code>painters</code> data frame. The <code>School</code> variable in this dataset is a factor with levels A, B, C, D, E, F, G, H (denoting which art school each painter belonged to). Suppose we want to create a binary variable <code>School2</code> which equals 1 if the <code>school</code> is A, B, or C, and 2 otherwise. We can use <code>ifelse()</code> with the <code>%in%</code> operator for this set membership test:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>School2 <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(painters<span class="sc">$</span>School <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"A"</span>,<span class="st">"B"</span>,<span class="st">"C"</span>), <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(School2, painters<span class="sc">$</span>School)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       
School2  A  B  C  D  E  F  G  H
      1 10  6  6  0  0  0  0  0
      2  0  0  0 10  7  4  7  4</code></pre>
</div>
</div>
<p>The table above will show that for schools A, B, C we have <code>School2</code> = 1, and for the others it’s 2.</p>
<p>We can also nest <code>ifelse()</code> statements to create variables with more than two categories. Continuing the example above, suppose we want to create <code>School3</code> such that: A/B/C map to 1, D/E map to 2, and F/G/H map to 3. We can nest a second <code>ifelse()</code> inside the first:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>School3 <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(painters<span class="sc">$</span>School <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"A"</span>,<span class="st">"B"</span>,<span class="st">"C"</span>), <span class="dv">1</span>,</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">ifelse</span>(painters<span class="sc">$</span>School <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"D"</span>,<span class="st">"E"</span>), <span class="dv">2</span>, <span class="dv">3</span>))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(School3, painters<span class="sc">$</span>School)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       
School3  A  B  C  D  E  F  G  H
      1 10  6  6  0  0  0  0  0
      2  0  0  0 10  7  0  0  0
      3  0  0  0  0  0  4  7  4</code></pre>
</div>
</div>
<p>We see <code>School3</code> assigns 1 to A/B/C, 2 to D/E, and 3 to F/G/H as intended.</p>
</section>
<section id="creating-factors-using-the-cut-function" class="level3" data-number="7.1.3">
<h3 data-number="7.1.3" class="anchored" data-anchor-id="creating-factors-using-the-cut-function"><span class="header-section-number">7.1.3</span> Creating Factors Using the <code>cut()</code> Function</h3>
<p>In statistical analysis, it’s often useful to convert a continuous variable into a categorical factor by binning its values into intervals. The base R function <code>cut()</code> is designed for this purpose. The <code>cut()</code> function takes a numeric vector and converts it into a factor by dividing the range of the data into intervals (bins) and assigning each value to a bin.</p>
<p>Key arguments of <code>cut()</code> include:</p>
<ul>
<li><code>x</code> : the numeric vector to be binned.</li>
<li><code>breaks</code> : a numeric vector of cut points (of length <code>n+1</code> if you want <code>n</code> intervals), or a single number giving the number of intervals to cut <code>x</code> into.</li>
<li><code>labels</code> : an optional vector of labels for the resulting factor levels. If not provided, <code>cut</code> will by default label the intervals like <code>(a,b]</code> (using parentheses for open intervals and brackets for closed intervals).</li>
<li><code>include.lowest</code> : logical, indicating if the lowest (first) interval should be closed on the left. By default the intervals are left-open, right-closed; setting <code>include.lowest=TRUE</code> will include the minimum value of <code>x</code> in the first interval (making it <code>[a,b]</code> for the first interval).</li>
<li><code>right</code> : logical for whether intervals should be closed on the right (and open on the left) or vice versa. The default <code>right=TRUE</code> means intervals like <code>(a,b]</code> ; if FALSE , you get <code>[a,b)</code> style.</li>
</ul>
<p>As an example, suppose we want to categorize the painters’ <code>Colour</code> score into four groups representing quartiles (i.e., 0–25th percentile, 25–50th, 50–75th, 75–100th). We can do this by first finding the quartile cut points and then using <code>cut()</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>qt <span class="ot">&lt;-</span> <span class="fu">quantile</span>(painters<span class="sc">$</span>Colour, <span class="at">probs =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>, <span class="dv">1</span>))</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>qt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   0%   25%   50%   75%  100% 
 0.00  7.25 10.00 16.00 18.00 </code></pre>
</div>
</div>
<p>Now use these as breakpoints:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>painters<span class="sc">$</span>ColourCat <span class="ot">&lt;-</span> <span class="fu">cut</span>(painters<span class="sc">$</span>Colour, </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                          <span class="at">breaks =</span> qt,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">labels =</span>  <span class="fu">c</span>(<span class="st">"first"</span>,<span class="st">"second"</span>,<span class="st">"third"</span>,<span class="st">"fourth"</span>),</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>                          <span class="at">include.lowest =</span> <span class="cn">TRUE</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(painters<span class="sc">$</span>ColourCat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
 first second  third fourth 
    14     15     18      7 </code></pre>
</div>
</div>
<p>Here “first” corresponds to the lowest quarter of <code>Colour</code> values, and “fourth” the highest quarter. We set <code>include.lowest = TRUE</code> so that the minimum value (0 in this case) is included in the lowest interval.</p>
<p>Using <code>cut()</code> in this way allows us to introduce non-linear relationships or categorical distinctions into models (for example, using quartiles instead of a continuous variable) and to better interpret continuous variables by grouping their values into meaningful categories.</p>
</section>
</section>
<section id="handling-data-with-duplicated-elements" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="handling-data-with-duplicated-elements"><span class="header-section-number">7.2</span> Handling Data with Duplicated Elements</h2>
<p>Data often contain duplicate records, which may occur intentionally or as errors (for instance, through data entry mistakes or merging datasets). Identifying and handling duplicates is typically part of data cleaning. Base R provides functions to detect and manage duplicates in vectors, matrices, and data frames.</p>
<section id="duplicated-elements-in-vectors" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="duplicated-elements-in-vectors"><span class="header-section-number">7.2.1</span> Duplicated Elements in Vectors</h3>
<p>For vectors, the <code>unique()</code> function returns a vector of the distinct values. The companion function <code>duplicated()</code> returns a logical vector the same length as the input, indicating for each position whether that element is a duplicate of an earlier element. Both functions have an argument <code>fromLast</code> which, if set to <code>TRUE</code>, considers duplication from the reverse direction (this affects which element is considered the “first” occurrence).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>v <span class="ot">&lt;-</span> <span class="fu">c</span>(letters[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>], <span class="st">"d"</span>, <span class="st">"a"</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>v</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "a" "b" "c" "d" "d" "a"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">unique</span>(v)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "a" "b" "c" "d"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">unique</span>(v, <span class="at">fromLast =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "b" "c" "d" "a"</code></pre>
</div>
</div>
<p>Here <code>unique(v)</code> kept the first occurrence of each letter (so we see <code>"a"</code> from position 1, not the <code>"a"</code> from the end), whereas <code>unique(v, fromLast=TRUE)</code> kept the last occurrence of each duplicate (so it retained the <code>"a"</code> from the end and dropped the earlier one).</p>
<p>Now check <code>duplicated(v)</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">duplicated</span>(v)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE FALSE FALSE FALSE  TRUE  TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">duplicated</span>(v, <span class="at">fromLast =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  TRUE FALSE FALSE  TRUE FALSE FALSE</code></pre>
</div>
</div>
<p>In the first output, the fifth element (<code>"d"</code>) and sixth element (<code>"a"</code>) are marked <code>TRUE</code> because they are duplicates of earlier elements in the vector. In the second output (<code>fromLast=TRUE</code>), it’s the first element <code>"a"</code> and fourth element <code>"d"</code> that are marked <code>TRUE</code> (because from the reverse direction, those become the “duplicate” instances).</p>
<p>If our goal is to extract only the unique values from a vector, we can use <code>!duplicated()</code> as a filtering index:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>v[<span class="sc">!</span><span class="fu">duplicated</span>(v)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "a" "b" "c" "d"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>v[<span class="sc">!</span><span class="fu">duplicated</span>(v, <span class="at">fromLast =</span> <span class="cn">TRUE</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "b" "c" "d" "a"</code></pre>
</div>
</div>
<p>The first line returns the first occurrences of each unique value (same as <code>unique(v)</code>), while the second returns the last occurrences of each unique value.</p>
</section>
<section id="duplicated-rows-or-columns-in-matrices" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="duplicated-rows-or-columns-in-matrices"><span class="header-section-number">7.2.2</span> Duplicated Rows or Columns in Matrices</h3>
<p>The concepts of <code>unique()</code> and <code>duplicated()</code> extend to matrices as well, working by rows (the default, <code>MARGIN = 1</code>). The <code>unique()</code> function will return a matrix with duplicate rows removed, and <code>duplicated()</code> will return a logical vector flagging duplicate rows. For example:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>mat <span class="ot">&lt;-</span> <span class="fu">matrix</span>(</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"c"</span>, <span class="dv">3</span>), <span class="st">"d"</span>, <span class="st">"c"</span>, </span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"a"</span>,<span class="st">"b"</span>,<span class="st">"c"</span>,<span class="st">"c"</span>,<span class="st">"c"</span>), <span class="dv">2</span>),</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    letters[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>], <span class="st">"d"</span>, <span class="st">"c"</span>,</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rep</span>(<span class="st">"c"</span>, <span class="dv">5</span>), letters[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>], <span class="st">"c"</span>, <span class="st">"c"</span>),</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">ncol =</span> <span class="dv">5</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>mat</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4] [,5]
[1,] "c"  "c"  "c"  "d"  "c" 
[2,] "a"  "b"  "c"  "c"  "c" 
[3,] "a"  "b"  "c"  "c"  "c" 
[4,] "a"  "b"  "c"  "d"  "c" 
[5,] "c"  "c"  "c"  "c"  "c" 
[6,] "a"  "b"  "c"  "c"  "c" </code></pre>
</div>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">unique</span>(mat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4] [,5]
[1,] "c"  "c"  "c"  "d"  "c" 
[2,] "a"  "b"  "c"  "c"  "c" 
[3,] "a"  "b"  "c"  "d"  "c" 
[4,] "c"  "c"  "c"  "c"  "c" </code></pre>
</div>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">duplicated</span>(mat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE FALSE  TRUE FALSE FALSE  TRUE</code></pre>
</div>
</div>
<p>We see that rows 3 and 6 were duplicates of earlier rows (row 3 duplicates row 2, and row 6 duplicates row 2 as well), which is why <code>duplicated(mat)</code> flags them as TRUE . The <code>unique(mat)</code> result kept one copy of each distinct row.</p>
<p>If we want to check for duplicated columns in a matrix, we can use the <code>MARGIN</code> argument with value 2 in <code>unique()</code> or <code>duplicated()</code> . By default, these functions act on rows (<code>MARGIN=1</code>). For example, <code>unique(mat, MARGIN=2)</code> would give the unique set of columns of the matrix, and <code>duplicated(mat, MARGIN=2)</code> would flag duplicate columns. In our mat example, we can test:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">unique</span>(mat, <span class="at">MARGIN =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4]
[1,] "c"  "c"  "c"  "d" 
[2,] "a"  "b"  "c"  "c" 
[3,] "a"  "b"  "c"  "c" 
[4,] "a"  "b"  "c"  "d" 
[5,] "c"  "c"  "c"  "c" 
[6,] "a"  "b"  "c"  "c" </code></pre>
</div>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">duplicated</span>(mat, <span class="at">MARGIN =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE FALSE FALSE FALSE  TRUE</code></pre>
</div>
</div>
<p>If there were any identical columns, <code>duplicated(mat, MARGIN=2)</code> would mark them. (In the constructed matrix above, each column is actually unique.)</p>
</section>
<section id="duplicated-records-in-data-frames" class="level3" data-number="7.2.3">
<h3 data-number="7.2.3" class="anchored" data-anchor-id="duplicated-records-in-data-frames"><span class="header-section-number">7.2.3</span> Duplicated Records in Data Frames</h3>
<p>Working with duplicate observations in a data frame is similar to the matrix case (except we cannot use <code>MARGIN</code> to target columns in one call). The <code>unique()</code> function applied to a data frame returns the data frame with duplicate rows removed. The <code>duplicated()</code> function applied to a data frame returns a logical vector indicating which rows are duplicates of a previous row.</p>
<p>Consider an example data frame with a patient ID, a visit number, and a score, where some patients have multiple rows (multiple visits):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">5</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">ID =</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"A01"</span>, <span class="dv">3</span>), <span class="fu">rep</span>(<span class="st">"A02"</span>, <span class="dv">2</span>), <span class="st">"A03"</span>, <span class="st">"A04"</span>, <span class="fu">rep</span>(<span class="st">"A05"</span>, <span class="dv">2</span>)),</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">visit =</span> <span class="fu">c</span>(<span class="dv">3</span><span class="sc">:</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="fu">rep</span>(<span class="dv">1</span>, <span class="dv">4</span>)),</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">score =</span> <span class="fu">round</span>(<span class="fu">rnorm</span>(<span class="dv">9</span>, <span class="dv">5</span>, <span class="dv">2</span>))</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>dat</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   ID visit score
1 A01     3     3
2 A01     2     8
3 A01     1     2
4 A02     1     5
5 A02     2     8
6 A03     1     4
7 A04     1     4
8 A05     1     4
9 A05     1     4</code></pre>
</div>
</div>
<p>We can see that ID A01 appears 3 times, A02 twice, A05 twice, etc. If we use <code>unique(dat)</code> , it will return a data frame with duplicate rows removed. In this example, row 9 is an exact duplicate of row 8 (same ID, visit, score), so <code>unique(dat)</code> would drop one of those:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">unique</span>(dat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   ID visit score
1 A01     3     3
2 A01     2     8
3 A01     1     2
4 A02     1     5
5 A02     2     8
6 A03     1     4
7 A04     1     4
8 A05     1     4</code></pre>
</div>
</div>
<p>Understanding these tools allows for many practical operations. For example, we can use them to extract the first or last occurrence of each group in a dataset. Returning to the <code>dat</code> example: to get each patient’s first visit and last visit, we can do the following:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. sort by ID then visit</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>dat_sort <span class="ot">&lt;-</span> dat[<span class="fu">order</span>(dat<span class="sc">$</span>ID, dat<span class="sc">$</span>visit), ]  </span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. first row for each ID</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>first_visit <span class="ot">&lt;-</span> dat_sort[<span class="sc">!</span><span class="fu">duplicated</span>(dat_sort<span class="sc">$</span>ID), ] </span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>first_visit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   ID visit score
3 A01     1     2
4 A02     1     5
6 A03     1     4
7 A04     1     4
8 A05     1     4</code></pre>
</div>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. last row for each ID</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>last_visit <span class="ot">&lt;-</span> dat_sort[<span class="sc">!</span><span class="fu">duplicated</span>(dat_sort<span class="sc">$</span>ID, <span class="at">fromLast=</span><span class="cn">TRUE</span>), ] </span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>last_visit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   ID visit score
1 A01     3     3
5 A02     2     8
6 A03     1     4
7 A04     1     4
9 A05     1     4</code></pre>
</div>
</div>
<p>Let’s break down what we did:</p>
<ul>
<li>We sorted the data frame by ID and then by visit number, storing it in <code>dat_sort</code> . This ensures that for each patient ID, the visits are in chronological order.</li>
<li><code>!duplicated(dat_sort$ID)</code> gives <code>TRUE</code> for the first occurrence of each unique ID (since the data is sorted, that will be the earliest visit for each patient). Subsetting <code>dat_sort</code> with this returns the first visit for each patient.</li>
<li>Similarly, using <code>duplicated(dat_sort$ID, fromLast=TRUE)</code> identifies the last occurrence of each ID (the last visit in order), and negating it (<code>!</code>) flags those last occurrences. Subsetting gives us the last visit for each patient.</li>
</ul>
<p>Another scenario is splitting a dataset into two: one containing only individuals with multiple records, and one containing individuals with a single record. Using the <code>dat</code> example, we could do:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># IDs that appear more than once</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>dup_IDs <span class="ot">&lt;-</span> dat<span class="sc">$</span>ID[<span class="fu">duplicated</span>(dat<span class="sc">$</span>ID)] </span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co"># all rows for IDs with duplicates</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>multi_record_df <span class="ot">&lt;-</span> dat[dat<span class="sc">$</span>ID <span class="sc">%in%</span> dup_IDs, ] </span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>multi_record_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   ID visit score
1 A01     3     3
2 A01     2     8
3 A01     1     2
4 A02     1     5
5 A02     2     8
8 A05     1     4
9 A05     1     4</code></pre>
</div>
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># rows for IDs that appear only once</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>single_record_df <span class="ot">&lt;-</span> dat[<span class="sc">!</span>dat<span class="sc">$</span>ID <span class="sc">%in%</span> dup_IDs, ] </span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>single_record_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   ID visit score
6 A03     1     4
7 A04     1     4</code></pre>
</div>
</div>
<p>In our data, <code>dup_IDs</code> would include “A01”, “A02”, “A05”. Thus, <code>multi_record_df</code> will contain all records for those IDs, and <code>single_record_df</code> will contain the records for A03 and A04 (the IDs that occur only once).</p>
</section>
</section>
<section id="merging-data-frames" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="merging-data-frames"><span class="header-section-number">7.3</span> Merging Data Frames</h2>
<p>Merging data is crucial for combining information from various sources, enabling us to uncover hidden patterns and relationships. It facilitates comprehensive analysis by integrating diverse datasets, leading to more informed decisions and deeper insights into the underlying phenomena.</p>
<p>In base R, the primary tool for merging data frames is the <code>merge()</code> function. This function allows us to join two data frames based on one or more common key variables.</p>
<p>For example, suppose we have two data frames we want to merge by an <code>id</code> column:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>data1 <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>),</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">var1 =</span> <span class="fu">c</span>(<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>)</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>data1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id var1
1  2    A
2  1    B
3  3    C</code></pre>
</div>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>data2 <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>),</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">var2 =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">9</span>)</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>data2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id var2
1  3    1
2  4    3
3  1    9</code></pre>
</div>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">merge</span>(data1, data2)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>result</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id var1 var2
1  1    B    9
2  3    C    1</code></pre>
</div>
</div>
<p>By default, data frames are merged using the columns with common names in both data frames. You can also specify the variable or variables explicitly with the <code>by</code> argument, such as <code>by = "id"</code>. In this example, merging the two data frames by <code>id</code> results in a data frame that includes only the rows with matching <code>id</code> values in both data frames.</p>
<p>The <code>merge()</code> function performs an inner join (keeping only matching rows) by default. We can change this behavior with the arguments <code>all.x</code> , <code>all.y</code> , or <code>all</code> :</p>
<ul>
<li><code>all.x = TRUE</code>: keeps all rows from the first data frame (a left join).</li>
<li><code>all.y = TRUE</code>: keeps all rows from the second data frame (a right join).</li>
<li><code>all = TRUE</code>: keeps all rows from both (a full outer join), inserting <code>NA</code> for missing matches.</li>
</ul>
<p>For instance, using the same <code>data1</code> and <code>data2</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="fu">merge</span>(data1, data2, <span class="at">by =</span> <span class="st">"id"</span>, <span class="at">all.x =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id var1 var2
1  1    B    9
2  2    A   NA
3  3    C    1</code></pre>
</div>
</div>
<p>In the example above, every <code>id</code> from <code>data1</code> is retained. Notice id 2 had no match in <code>data2</code>, resulting in <code>NA</code> for <code>var2</code>. Similarly:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="fu">merge</span>(data1, data2, <span class="at">by =</span> <span class="st">"id"</span>, <span class="at">all.y =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id var1 var2
1  1    B    9
2  3    C    1
3  4 &lt;NA&gt;    3</code></pre>
</div>
</div>
<p>And setting <code>all = TRUE</code> keeps all ids from both:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="fu">merge</span>(data1, data2, <span class="at">by =</span> <span class="st">"id"</span>, <span class="at">all =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id var1 var2
1  1    B    9
2  2    A   NA
3  3    C    1
4  4 &lt;NA&gt;    3</code></pre>
</div>
</div>
<p>Notice how id 4 (which was only in <code>data2</code>) and id 2 (only in <code>data1</code>) are included, with missing values filled in for the other data frame’s fields.</p>
<p>If the key columns have different names in the two data frames, we can use <code>by.x</code> and <code>by.y</code> to specify them. For example, if <code>data2</code> had the identifier in a column named <code>ID</code> (capital letters) instead of <code>id</code> , we could do:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>data3 <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">ID =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>),</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">var2 =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">8</span>, <span class="dv">9</span>)</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="fu">merge</span>(data2, data3, <span class="at">by.x =</span> <span class="st">"id"</span>, <span class="at">by.y =</span> <span class="st">"ID"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id var2.x var2.y
1  1      9      1
2  3      1      8
3  4      3      9</code></pre>
</div>
</div>
<p>The command above merges data2 and data3 by matching <code>data2$id</code> to <code>data3$ID</code>. The result’s column names for the merged key will default to <code>id</code> (the name in the first data frame <code>data2</code>), and since both data frames had a <code>var2</code> column, the output will have <code>var2.x</code> and <code>var2.y</code> to distinguish them.</p>
<p>In this example, <code>.x</code> and <code>.y</code> suffixes were auto-appended to distinguish the two <code>var2</code> columns that came from <code>data2</code> and <code>data3</code>. We can customize these suffixes using the <code>suffixes</code> argument if desired:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">merge</span>(data2, data3, <span class="at">by.x=</span><span class="st">"id"</span>, <span class="at">by.y=</span><span class="st">"ID"</span>,</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>      <span class="at">suffixes=</span><span class="fu">c</span>(<span class="st">".data2"</span>,<span class="st">".data3"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id var2.data2 var2.data3
1  1          9          1
2  3          1          8
3  4          3          9</code></pre>
</div>
</div>
<p>Merging data frames in base R using <code>merge()</code> is quite powerful for relational operations. It’s worth noting, however, that there are other packages and tools (such as <code>dplyr</code> from the <code>tidyverse</code>, or the <code>data.table</code> package) that provide alternative syntax and potentially faster performance for merging and joining operations.</p>
</section>
<section id="reshaping-data" class="level2" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="reshaping-data"><span class="header-section-number">7.4</span> Reshaping Data</h2>
<p>In data analysis, we often need to transform datasets between wide format and long format (and vice versa), or otherwise rearrange the shape of our data.</p>
<p>Base R provides several functions for reshaping data, including <code>stack()</code>, <code>unstack()</code>, and the more general <code>reshape()</code> function. These functions allow us to reorganize data frames or vectors without losing information, only changing how that information is structured. Many modern R packages such as <code>tidyr</code> also offer powerful data reshaping tools, but we will focus on base R here.</p>
<section id="stacking-and-unstacking-data" class="level3" data-number="7.4.1">
<h3 data-number="7.4.1" class="anchored" data-anchor-id="stacking-and-unstacking-data"><span class="header-section-number">7.4.1</span> Stacking and Unstacking Data</h3>
<p>The functions <code>stack()</code> and <code>unstack()</code> provide a convenient way to convert data between <em>long</em> and <em>wide</em> formats when the dataset is relatively simple. <em>Stacking</em> means taking data that is spread across multiple columns and stacking them into a single column (creating a longer, narrower dataset). <em>Unstacking</em> is the opposite: taking data from a single column that includes observations from multiple groups and spreading it out into separate columns (creating a wider dataset).</p>
<p>In base R, <code>stack(x)</code> takes a data frame or list <code>x</code> and concatenates the values into one long vector, while also creating an index that indicates the source column for each value . The result of <code>stack()</code> is a data frame with two columns: one named <code>values</code> (the stacked values) and one named <code>ind</code> (a factor indicating which column the value came from) . Conversely, <code>unstack()</code> takes such a stacked data frame (or a similar structure) and spreads it back out into separate vectors for each category.</p>
<p>To illustrate, consider the built-in dataset <code>InsectSprays</code> , which is in long format (one observation per row, with a factor indicating spray type). If we wanted a wide format with one column per spray type, we could unstack it. Conversely, if we start with the wide form, we could stack it back to long. The following example demonstrates unstacking:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(InsectSprays)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   72 obs. of  2 variables:
 $ count: num  10 7 20 14 14 12 10 23 17 20 ...
 $ spray: Factor w/ 6 levels "A","B","C","D",..: 1 1 1 1 1 1 1 1 1 1 ...</code></pre>
</div>
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(InsectSprays)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  count spray
1    10     A
2     7     A
3    20     A
4    14     A
5    14     A
6    12     A</code></pre>
</div>
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>wideDF <span class="ot">&lt;-</span> <span class="fu">unstack</span>(InsectSprays)</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>wideDF</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    A  B C  D E  F
1  10 11 0  3 3 11
2   7 17 1  5 5  9
3  20 21 7 12 3 15
4  14 11 2  6 5 22
5  14 16 3  4 3 15
6  12 14 1  3 6 16
7  10 17 2  5 1 13
8  23 17 1  5 1 10
9  17 19 3  5 3 26
10 20 21 0  5 2 26
11 14  7 1  2 6 24
12 13 13 4  4 4 13</code></pre>
</div>
</div>
<p>Here, <code>unstack(InsectSprays)</code> produced a data frame with separate columns <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, <code>F</code> for each spray type, each column containing the count values. Essentially, it turned the balanced long format into a wide format. This works because the original data had the same number of observations for each spray type (a balanced design) <span class="citation" data-cites="braun_r_intro">(<a href="#ref-braun_r_intro" role="doc-biblioref">Braun n.d.</a>)</span>.</p>
<p>If we <code>stack()</code> that wide data frame (or the original wide form, if we had it), we should get back to the long format. For instance:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>stackedDF <span class="ot">&lt;-</span> <span class="fu">stack</span>(wideDF)</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(stackedDF)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  values ind
1     10   A
2      7   A
3     20   A
4     14   A
5     14   A
6     12   A</code></pre>
</div>
</div>
<p>The <code>stack()</code> function in base R stacks only plain atomic vector columns — that is, columns for which <code>is.vector()</code> returns TRUE, such as numeric, character, or logical vectors. Columns with additional class attributes, like <code>factors</code> or <code>matrices</code>, are ignored with a warning, even though they are technically atomic under the hood. Additionally, when stacking columns of mixed types (e.g., numeric and character), R will coerce them to a common type, usually character, to ensure the <code>values</code> column remains consistent. For example:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">a =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">b =</span> letters[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>],</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">c =</span> <span class="fu">factor</span>(<span class="fu">c</span>(<span class="st">"low"</span>, <span class="st">"medium"</span>, <span class="st">"high"</span>)),</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">d =</span> <span class="fu">c</span>(T, F, T)</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  a b      c     d
1 1 a    low  TRUE
2 2 b medium FALSE
3 3 c   high  TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="fu">stack</span>(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in stack.data.frame(df): non-vector columns will be ignored</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>  values ind
1      1   a
2      2   a
3      3   a
4      a   b
5      b   b
6      c   b
7   TRUE   d
8  FALSE   d
9   TRUE   d</code></pre>
</div>
</div>
<p>The <code>unstack(x, form)</code> function in base R reshapes a data frame from long to wide format using a formula interface. The formula should be written as <code>value ~ group</code>, where <code>value</code> is the column containing the measurements, and <code>group</code> is the column whose unique values will become new column names.</p>
<p>For example, suppose we have the following long-format data frame:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">person =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>), <span class="at">each =</span> <span class="dv">2</span>),</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">variable =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"height"</span>, <span class="st">"weight"</span>), <span class="at">times =</span> <span class="dv">3</span>),</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">value =</span> <span class="fu">c</span>(<span class="dv">160</span>, <span class="dv">55</span>, <span class="dv">170</span>, <span class="dv">65</span>, <span class="dv">180</span>, <span class="dv">75</span>)</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  person variable value
1      A   height   160
2      A   weight    55
3      B   height   170
4      B   weight    65
5      C   height   180
6      C   weight    75</code></pre>
</div>
</div>
<p>The function <code>unstack(df, value ~ variable)</code> spreads the value column into separate columns based on the variable column (<code>height</code> and <code>weight</code>):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="fu">unstack</span>(df, value <span class="sc">~</span> variable)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  height weight
1    160     55
2    170     65
3    180     75</code></pre>
</div>
</div>
<p>Alternatively, using <code>unstack(df, value ~ person)</code> spreads the values into columns named after each person (<code>A</code>, <code>B</code>, <code>C</code>):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="fu">unstack</span>(df, value <span class="sc">~</span> person)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    A   B   C
1 160 170 180
2  55  65  75</code></pre>
</div>
</div>
<p>If the data is in stacked format (e.g., created directly by <code>stack()</code>), then <code>unstack()</code> can be called without a formula.</p>
</section>
<section id="reshaping-data-frames-with-reshape" class="level3" data-number="7.4.2">
<h3 data-number="7.4.2" class="anchored" data-anchor-id="reshaping-data-frames-with-reshape"><span class="header-section-number">7.4.2</span> Reshaping Data Frames with <code>reshape()</code></h3>
<p>The <code>reshape()</code> function in base R is a flexible tool for converting data frames between wide and long formats, handling complex rearrangements that simpler functions like <code>stack()</code> or <code>unstack()</code> may not manage (e.g., multiple measured variables or unbalanced data).</p>
<p>Key Arguments for <code>reshape()</code>:</p>
<ul>
<li><code>data</code>: The data frame to reshape.</li>
<li><code>direction</code>: <code>"long"</code> to stack multiple columns into one, or <code>"wide"</code> to spread one column into multiple.</li>
<li><code>idvar</code>: Column(s) identifying the observational unit (e.g., subject ID) that stay constant.</li>
<li><code>timevar</code>: Column indicating the time or occasion, whose values become suffixes in wide format or a new column in long format.</li>
<li><code>varying</code>: For <em>wide-to-long</em>, a vector or list of column names to stack into a single column. For <em>long-to-wide</em>, this is often inferred.</li>
<li><code>v.names</code>: The name of the measurement variable in long format.</li>
</ul>
<p><strong>Example: Wide to Long Format</strong></p>
<p>Suppose we have a wide data frame where each subject (<code>id</code>) has scores measured at two time points (<code>score_time1</code>, <code>score_time2</code>):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>wideDF <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">score_time1 =</span> <span class="fu">c</span>(<span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">4</span>),</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">score_time2 =</span> <span class="fu">c</span>(<span class="dv">6</span>, <span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>wideDF</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id score_time1 score_time2
1  1           5           6
2  2           3           2
3  3           4           4</code></pre>
</div>
</div>
<p>To reshape this to long format (one row per subject per time point), use <code>reshape()</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>longDF1 <span class="ot">&lt;-</span> <span class="fu">reshape</span>(wideDF, </span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">direction =</span> <span class="st">"long"</span>,</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">idvar =</span> <span class="st">"id"</span>, </span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>                   <span class="at">timevar =</span> <span class="st">"time"</span>,</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>                   <span class="at">varying =</span> <span class="fu">c</span>(<span class="st">"score_time1"</span>, <span class="st">"score_time2"</span>),</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>                   <span class="at">v.names =</span> <span class="st">"score"</span>)</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>longDF1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    id time score
1.1  1    1     5
2.1  2    1     3
3.1  3    1     4
1.2  1    2     6
2.2  2    2     2
3.2  3    2     4</code></pre>
</div>
</div>
<p>Here:</p>
<ul>
<li><code>idvar = "id"</code>: Keeps id constant for each subject.</li>
<li><code>timevar = "time"</code>: Creates a new column time with values (1, 2) from the suffixes of <code>score_time1</code> and <code>score_time2</code>.</li>
<li><code>varying = c("score_time1", "score_time2")</code>: Specifies columns to stack into one.</li>
<li><code>v.names = "score"</code>: Names the stacked measurement column score.</li>
</ul>
<p>The result has two rows per subject: one for <code>time = 1</code> and one for <code>time = 2</code>, with corresponding scores. If column suffixes aren’t numeric (e.g., <code>score_pre</code>, <code>score_post</code>), use <code>times = c("pre", "post")</code> to define time values explicitly. For example:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>longDF2 <span class="ot">&lt;-</span> <span class="fu">reshape</span>(wideDF, </span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">direction =</span> <span class="st">"long"</span>,</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">idvar =</span> <span class="st">"id"</span>, </span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>                   <span class="at">timevar =</span> <span class="st">"time"</span>,</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>                   <span class="at">times =</span> <span class="fu">c</span>(<span class="st">"pre"</span>, <span class="st">"post"</span>),</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>                   <span class="at">varying =</span> <span class="fu">c</span>(<span class="st">"score_time1"</span>, <span class="st">"score_time2"</span>),</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>                   <span class="at">v.names =</span> <span class="st">"score"</span>)</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>longDF2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       id time score
1.pre   1  pre     5
2.pre   2  pre     3
3.pre   3  pre     4
1.post  1 post     6
2.post  2 post     2
3.post  3 post     4</code></pre>
</div>
</div>
<p><strong>Example: Long to Wide Format</strong></p>
<p>Now, let’s reshape the longDF back to wide format:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="fu">reshape</span>(longDF1, </span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>        <span class="at">direction =</span> <span class="st">"wide"</span>, </span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">idvar =</span> <span class="st">"id"</span>, </span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">timevar =</span> <span class="st">"time"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    id score.1 score.2
1.1  1       5       6
2.1  2       3       2
3.1  3       4       4</code></pre>
</div>
</div>
<p>Here, <code>reshape()</code> spreads the score column into <code>score.1</code> and <code>score.2</code> based on time values. You can customize the column name separator with the <code>sep</code> argument. For example:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="fu">reshape</span>(longDF2, </span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>        <span class="at">direction =</span> <span class="st">"wide"</span>, </span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">idvar =</span> <span class="st">"id"</span>, </span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">timevar =</span> <span class="st">"time"</span>,</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">sep =</span> <span class="st">"_"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      id score_pre score_post
1.pre  1         5          6
2.pre  2         3          2
3.pre  3         4          4</code></pre>
</div>
</div>
<p>The <code>reshape()</code> function is powerful but can be tricky due to its need for precise argument specification. Modern packages like <code>tidyr</code> (<code>pivot_longer()</code>, <code>pivot_wider()</code>) or <code>reshape2</code> (<code>melt()</code>, <code>dcast()</code>) often provide simpler alternatives for reshaping tasks.</p>
</section>
</section>
<section id="aggregating-data" class="level2" data-number="7.5">
<h2 data-number="7.5" class="anchored" data-anchor-id="aggregating-data"><span class="header-section-number">7.5</span> Aggregating Data</h2>
<p>In data analysis, we frequently need to aggregate data — that is, to summarize or collapse detailed observations into higher-level summaries. Examples include calculating the average income by country, total sales by quarter, or the minimum and maximum values within categories. Base R provides several functions for group-wise computations: <code>tapply()</code>, <code>aggregate()</code>, <code>by()</code>, and <code>ave()</code> are among the most commonly used. We have already introduced <code>tapply()</code> in a previous chapter, so in this section, we will focus on the remaining three — each with its own use case and output format, depending on the structure of the data and the desired result.</p>
<p>Before diving into each function, note that all these functions ultimately achieve a “split-apply-combine” strategy: they split data into groups based on some factor or categorical variable, apply a function to each group, and then combine the results.</p>
<section id="aggregation-with-aggregate" class="level3" data-number="7.5.1">
<h3 data-number="7.5.1" class="anchored" data-anchor-id="aggregation-with-aggregate"><span class="header-section-number">7.5.1</span> Aggregation with <code>aggregate()</code></h3>
<p>The <code>aggregate()</code> function in base R is a powerful tool for summarizing data frames, offering a data-frame-oriented alternative to <code>tapply()</code>. Unlike <code>tapply()</code>, which applies a function to a vector split by factors and returns an array or vector, <code>aggregate()</code> handles multiple columns and returns a data frame, ideal for further manipulation or merging. The <code>aggregate()</code> function has two main methods: the formula method (using a formula like <code>y ~ group</code>) and the default method (using <code>x</code>, <code>by</code>, <code>FUN</code>). Below, we explain both methods and provide examples using the <code>iris</code> dataset, which contains measurements (e.g., <code>Sepal.Length</code>, <code>Sepal.Width</code>) for 50 flowers from each of three <code>iris</code> species.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(iris)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa</code></pre>
</div>
</div>
<p><strong>Formula Method</strong></p>
<p>The formula method uses a<code>ggregate(formula, data, FUN)</code>, where:</p>
<ul>
<li><code>formula</code>: Specifies the variable(s) to aggregate and grouping factor(s), e.g., <code>y ~ group</code> or <code>cbind(y1, y2) ~ group</code>.</li>
<li><code>data</code>: The data frame containing the variables.</li>
<li><code>FUN</code>: The function to apply (e.g., <code>mean</code>, <code>sd</code>).</li>
</ul>
<p>For example, to calculate the mean Sepal.Length for each species:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="fu">aggregate</span>(Sepal.Length <span class="sc">~</span> Species, </span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>          <span class="at">data =</span> iris, </span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>          <span class="at">FUN =</span> mean)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     Species Sepal.Length
1     setosa        5.006
2 versicolor        5.936
3  virginica        6.588</code></pre>
</div>
</div>
<p>This returns a data frame with one row per <code>Species</code> and a column for the mean <code>Sepal.Length</code>.</p>
<p>To compute the mean and standard deviation of <code>Sepal.Length</code> and <code>Sepal.Width</code> by <code>species</code>, use <code>cbind()</code> in the formula and a custom function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="fu">aggregate</span>(<span class="fu">cbind</span>(Sepal.Length, Sepal.Width) <span class="sc">~</span> Species, </span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>          <span class="at">data =</span> iris, </span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>          \(x) <span class="fu">c</span>(<span class="at">Mean =</span> <span class="fu">mean</span>(x), <span class="at">SD =</span> <span class="fu">sd</span>(x)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     Species Sepal.Length.Mean Sepal.Length.SD Sepal.Width.Mean Sepal.Width.SD
1     setosa         5.0060000       0.3524897        3.4280000      0.3790644
2 versicolor         5.9360000       0.5161711        2.7700000      0.3137983
3  virginica         6.5880000       0.6358796        2.9740000      0.3224966</code></pre>
</div>
</div>
<p>This returns a data frame with mean and standard deviation for both variables per species.</p>
<p>If you have multiple grouping factors (e.g., <code>Species</code> and a hypothetical <code>some_factor</code>), include them in the formula:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Hypothetical example</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="fu">aggregate</span>(Sepal.Length <span class="sc">~</span> Species <span class="sc">+</span> some_factor, </span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>          <span class="at">data =</span> iris, </span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>          <span class="at">FUN =</span> mean)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Default Method</strong></p>
<p>The default method uses <code>aggregate(x, by, FUN)</code>, where:</p>
<ul>
<li><code>x</code>: A vector or data frame of variables to aggregate.</li>
<li><code>by</code>: A list of grouping factors (e.g., <code>list(group = df$group)</code>).</li>
<li><code>FUN</code>: The function to apply.</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="fu">aggregate</span>(<span class="at">x =</span> iris[, <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>], </span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>          <span class="at">by =</span> <span class="fu">list</span>(<span class="at">Species =</span> iris<span class="sc">$</span>Species), </span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>          <span class="at">FUN =</span> mean)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     Species Sepal.Length Sepal.Width Petal.Length Petal.Width
1     setosa        5.006       3.428        1.462       0.246
2 versicolor        5.936       2.770        4.260       1.326
3  virginica        6.588       2.974        5.552       2.026</code></pre>
</div>
</div>
<p>This returns a data frame with one row per Species and columns for the mean of each measurement variable.</p>
<p>The formula method is often more intuitive for simple aggregations, while the default method is flexible for aggregating multiple columns without a formula. Both methods produce data frames, making <code>aggregate()</code> versatile. For more modern alternatives, consider <code>dplyr</code>’s <code>group_by()</code> and <code>summarise()</code> for streamlined aggregation.</p>
</section>
<section id="applying-functions-by-group-with-by" class="level3" data-number="7.5.2">
<h3 data-number="7.5.2" class="anchored" data-anchor-id="applying-functions-by-group-with-by"><span class="header-section-number">7.5.2</span> Applying Functions by Group with <code>by()</code></h3>
<p>The function <code>by()</code> is another approach to group-wise operations. The usage is <code>by(data, INDICES, FUN, ...)</code> , where:</p>
<ul>
<li><code>data</code> is typically a data frame.</li>
<li><code>INDICES</code> is a factor or list of factors by which to split the data frame. - <code>FUN</code> is the function to apply to each subset of the data frame.</li>
</ul>
<p>The <code>by()</code> function will split the data frame by the factor(s) you provide, apply the function to each subset, and return an object of class <code>"by"</code> . When printed, this object shows the results for each group in a neat format.</p>
<p>For instance, using the <code>iris</code> data, if we want to get summary statistics of the numeric variables for each Species, we could do:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="fu">by</span>(iris[, <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>], iris<span class="sc">$</span>Species, summary)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>iris$Species: setosa
  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   
 Min.   :4.300   Min.   :2.300   Min.   :1.000   Min.   :0.100  
 1st Qu.:4.800   1st Qu.:3.200   1st Qu.:1.400   1st Qu.:0.200  
 Median :5.000   Median :3.400   Median :1.500   Median :0.200  
 Mean   :5.006   Mean   :3.428   Mean   :1.462   Mean   :0.246  
 3rd Qu.:5.200   3rd Qu.:3.675   3rd Qu.:1.575   3rd Qu.:0.300  
 Max.   :5.800   Max.   :4.400   Max.   :1.900   Max.   :0.600  
------------------------------------------------------------ 
iris$Species: versicolor
  Sepal.Length    Sepal.Width     Petal.Length   Petal.Width   
 Min.   :4.900   Min.   :2.000   Min.   :3.00   Min.   :1.000  
 1st Qu.:5.600   1st Qu.:2.525   1st Qu.:4.00   1st Qu.:1.200  
 Median :5.900   Median :2.800   Median :4.35   Median :1.300  
 Mean   :5.936   Mean   :2.770   Mean   :4.26   Mean   :1.326  
 3rd Qu.:6.300   3rd Qu.:3.000   3rd Qu.:4.60   3rd Qu.:1.500  
 Max.   :7.000   Max.   :3.400   Max.   :5.10   Max.   :1.800  
------------------------------------------------------------ 
iris$Species: virginica
  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   
 Min.   :4.900   Min.   :2.200   Min.   :4.500   Min.   :1.400  
 1st Qu.:6.225   1st Qu.:2.800   1st Qu.:5.100   1st Qu.:1.800  
 Median :6.500   Median :3.000   Median :5.550   Median :2.000  
 Mean   :6.588   Mean   :2.974   Mean   :5.552   Mean   :2.026  
 3rd Qu.:6.900   3rd Qu.:3.175   3rd Qu.:5.875   3rd Qu.:2.300  
 Max.   :7.900   Max.   :3.800   Max.   :6.900   Max.   :2.500  </code></pre>
</div>
</div>
<p>The main difference between <code>by()</code> and <code>aggregate()</code> lies in their output. Both functions split data into groups based on a factor and apply a function to each group. However, <code>aggregate()</code> returns a data frame, making it easier to use for further data manipulation. In contrast, <code>by()</code> returns a list-like <code>"by"</code> object, which can be useful for printing or inspecting group-specific results but may require additional steps if you want to combine or reshape the output for downstream analysis.</p>
</section>
<section id="computing-group-summaries-with-ave" class="level3" data-number="7.5.3">
<h3 data-number="7.5.3" class="anchored" data-anchor-id="computing-group-summaries-with-ave"><span class="header-section-number">7.5.3</span> Computing Group Summaries with <code>ave()</code></h3>
<p>While functions like <code>tapply()</code> and <code>aggregate()</code> produce one summary value per group, there are situations where we want to compute a group summary but retain the full length of the original data. This is useful when we want to annotate each observation with a statistic derived from its group, such as the group mean. The <code>ave()</code> function is designed specifically for this purpose.</p>
<p>The <code>ave()</code> function takes a vector <code>x</code>, splits it according to the grouping factor(s), applies a function <code>FUN</code> (default is mean), and returns a vector of the same length as <code>x</code> where each element is replaced by the computed group summary. This makes it especially handy for adding new columns to data frames based on group-level statistics.</p>
<p>For example, consider a data frame of test scores for students across different classes:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>students <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">class =</span> <span class="fu">c</span>(<span class="st">"A"</span>, <span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"B"</span>, <span class="st">"B"</span>, <span class="st">"A"</span>),</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">score =</span> <span class="fu">c</span>(<span class="dv">85</span>, <span class="dv">90</span>, <span class="dv">78</span>, <span class="dv">88</span>, <span class="dv">84</span>, <span class="dv">92</span>)</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>students</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  class score
1     A    85
2     A    90
3     B    78
4     B    88
5     B    84
6     A    92</code></pre>
</div>
</div>
<p>We can compute the class average for each student and store it in a new column using <code>ave()</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>students<span class="sc">$</span>class_avg <span class="ot">&lt;-</span> <span class="fu">ave</span>(students<span class="sc">$</span>score, </span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>                          students<span class="sc">$</span>class, </span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">FUN=</span>mean)</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>students</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  class score class_avg
1     A    85  89.00000
2     A    90  89.00000
3     B    78  83.33333
4     B    88  83.33333
5     B    84  83.33333
6     A    92  89.00000</code></pre>
</div>
</div>
<p>Now each student has a <code>class_avg</code> value corresponding to the mean score of their class. This technique is useful for comparisons, standardization, or visualization.</p>
<p>Although the default function for <code>ave()</code> is mean, you can supply other summary functions like <code>median</code>, <code>sd</code>, or even custom ones as long as the function returns a single value per group. However, avoid using functions that return multiple values (like range), since <code>ave()</code> expects only one summary value per group.</p>
<p>In summary, <code>ave()</code> is a convenient way to create group-based summary columns that align with the structure of the original data. It complements other aggregation functions by expanding the result across the full dataset instead of collapsing it.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-braun_r_intro" class="csl-entry" role="listitem">
Braun, W. John. n.d. <span>“Introduction to r.”</span> <a href="https://pages.stat.wisc.edu/~st849-1/Rnotes/1IntroD.pdf" class="uri">https://pages.stat.wisc.edu/~st849-1/Rnotes/1IntroD.pdf</a>.
</div>
<div id="ref-matloff2011art" class="csl-entry" role="listitem">
Matloff, Norman. 2011. <em>The Art of r Programming: A Tour of Statistical Software Design</em>. No Starch Press.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./iteration.html" class="pagination-link" aria-label="Iteration">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Iteration</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>