[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Base R Essentials",
    "section": "",
    "text": "Preface\nThis book is designed as a practical and approachable guide to Base R—the core language features that form the foundation of statistical computing and data analysis in R. Whether you are a student, researcher, or professional analyst, understanding how to work with vectors, matrices, lists, data frames, and other fundamental R objects is essential for effective data manipulation and exploration.\nWhile modern R workflows often incorporate contributed packages such as the tidyverse or ggplot2, this book focuses intentionally on Base R. The author believes that students should first gain a solid understanding of Base R’s syntax, object system, and programming logic before moving on to more abstracted tools. Learning Base R first not only builds lasting fluency with the language but also makes the transition to advanced topics and packages significantly easier.\nThe chapters are organized to build up knowledge systematically—starting from R installation and basic syntax, progressing through object types and subsetting techniques, and culminating in writing user-defined functions and implementing programming logic. Examples are grounded in real-world data tasks and are chosen to reinforce both conceptual understanding and hands-on skills.\nReaders are encouraged to type out the code, experiment with variations, and explore the structure and behavior of R objects using functions like typeof(),class(), or str(). These practices will strengthen your fluency and confidence as an R user, regardless of your background in programming.\nBy the end of this reader, you will have a strong grasp of the essentials of Base R—knowledge that will serve as a reliable foundation for more advanced statistical modeling, data visualization, and working with packages in the broader R ecosystem.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Getting Started with Base R",
    "section": "",
    "text": "1.1 Introduction to Base R and Setup\nR is a freely available and versatile tool for data analysis, statistics, and visualization, widely used by researchers and analysts (R Core Team 2025). Base R, the core version, equips you with essential features to explore data without additional packages. For beginners, mastering R involves understanding its diverse objects—such as vectors and lists—and learning to break them apart or combine them effectively. Equally critical is comprehending R’s syntax, including recognizing symbols like parentheses or brackets, interpreting help files, and applying functions to specific object types. These skills form the foundation for R proficiency.\nDeveloped from the S programming language by John Chambers, R was crafted by Robert Gentleman and Ross Ihaka, whose initials inspired its name. As part of the GNU open-source project, R’s code is accessible under the GNU General Public License, allowing anyone to use or enhance it (R Core Team 2025). To streamline your experience, RStudio, a free companion tool, provides an intuitive interface for coding and visualizing data, ideal for novices and experts (Posit 2025).\nInstallation of R, followed by RStudio, is the first step, as RStudio requires R to operate. Visit https://posit.co/download/rstudio-desktop/, which guides you through both steps (Posit 2025). The website identifies the operating system and provides a download link labeled ‘DOWNLOAD RSTUDIO DESKTOP FOR WINDOWS’ for Windows or ‘DOWNLOAD RSTUDIO DESKTOP FOR macOS’ for macOS.\nStep 1: Install R\nStep 2: Install RStudio\nFor additional guidance, view this video on RStudio installation: https://learnr-examples.shinyapps.io/ex-setup-r/#section-install-rstudio\nWith R and RStudio installed, you’re prepared to explore Base R’s objects and syntax.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#introduction-to-base-r-and-setup",
    "href": "intro.html#introduction-to-base-r-and-setup",
    "title": "1  Getting Started with Base R",
    "section": "",
    "text": "Under “1. Install R,” click the link to download R from the Comprehensive R Archive Network (CRAN).\nSelect a CRAN mirror site near your location and choose your system (Windows, macOS, or Linux).\nFor Windows, download the .exe installer (e.g., R-4.5.0-win.exe). For macOS, select the appropriate .pkg file (e.g., R-4.5.0-arm64.pkg for M1/M2 Macs or R-4.5.0-x86_64.pkg for Intel Macs).\nRun the installer, accepting default settings. On macOS, you may need a system password.\nOpen R, type 1 + 1 in the console, and press Enter. If you see 2, R is installed correctly.\n\n\n\nReturn to https://posit.co/download/rstudio-desktop/. Under “2. Install RStudio,” click the download button for RStudio Desktop (free version).\nFor Windows, download the .exe file (e.g., RStudio-2025.05.1-513.exe). For macOS, download the .dmg file (e.g., RStudio-2025.05.1-513.dmg).\nOn Windows, run the .exe and follow the prompts. On macOS, open the .dmg, drag RStudio to the Applications folder, and eject the disk image.\nOpen RStudio. The R console appears alongside tools for code writing and management.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#exploring-the-rstudio-environment",
    "href": "intro.html#exploring-the-rstudio-environment",
    "title": "1  Getting Started with Base R",
    "section": "1.2 Exploring the RStudio Environment",
    "text": "1.2 Exploring the RStudio Environment\nThe RStudio environment, a structured interface designed for data analysis and coding, provides a workspace for creating, managing, and visualizing R objects, such as lists and data frames, and for understanding syntax, including commands and associated symbols.\n\n\n\n\n\n\nFigure 1.1: RStudio Initial Interface\n\n\n\nAfter installing R and RStudio, the RStudio environment, a structured interface designed for data analysis and coding, provides a workspace for creating, managing, and visualizing R objects, such as lists and tables, and for understanding syntax, including commands and their associated symbols. The initial layout, shown in Figure 1.1, organizes tools for these tasks.\nThe default view includes the console on the left, where you can type and execute R commands directly, and panels on the right for the environment, history, and connections. The console displays R’s version and platform details, confirming your setup. For example, typing 1 + 1 and pressing Enter should yield 2, verifying the environment is operational. Although you can also work with the regular R console that you initially installed, it is recommended you work with RStudio, which offers a much better user-friendly interface and additional tools to enhance your experience.\n\n\n\n\n\n\nFigure 1.2: RStudio Interface with Script, Environment, and Plot\n\n\n\nTo enhance your workflow, you can create a script file to save and organize your commands. Select File &gt; New File &gt; R Script to open a new script editor, as shown in Figure 1.2. This editor, located in the upper-left pane, allows you to write and edit R code, such as defining vectors or performing calculations. The environment panel updates to reflect any objects you create, such as score1 or score2 from your script. Scripts are essential for documenting your work and revisiting it later, supporting your exploration of R’s objects and syntax.\nAs you work, the environment panel tracks your data objects, while the console executes your commands. Additionally, the plotting window in the lower right corner, as seen in Figure 1.2, displays visual representations of your data, such as graphs or charts, when you use commands like plot(). This feature allows you to explore relationships within your objects, enhancing your understanding of their structure and supporting your mastery of R’s syntax for visualization.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#understanding-r-commands",
    "href": "intro.html#understanding-r-commands",
    "title": "1  Getting Started with Base R",
    "section": "1.3 Understanding R Commands",
    "text": "1.3 Understanding R Commands\nR’s syntax is the foundation for instructing the program to perform tasks, and mastering it is essential for beginners.\n\n1.3.1 Constants and Variables\nA constant is a fixed value that remains unchanged, such as the number 1 or the text \"a\". When entered, these values produce specific outputs:\n\n1\n\n[1] 1\n\n\"a\"\n\n[1] \"a\"\n\n\nNotably, 1 is a numeric vector of length one, while \"a\" is a character vector of the same length. To reuse these values efficiently, you can assign them names, creating variables. For example:\n\nx &lt;- 1.12345 \nx\n\n[1] 1.12345\n\nb = \"a\" \nb\n\n[1] \"a\"\n\n\nHowever, typing an undefined variable name, such as y, will trigger an error, requiring prior assignment:\n\ny\n\nError: object 'y' not found\n\n\nThis naming process lays the foundation for storing and manipulating data, a principle that extends to how assignments function, as discussed next.\n\n\n1.3.2 Assignments\nAssignment associates a name with a value or object, storing it for later use. The primary operator is &lt;-, though = is also valid. To check a value, enter the name in the console:\n\nx &lt;- 5\nx\n\n[1] 5\n\ny = 10\ny\n\n[1] 10\n\n\nOnce assigned, variables like x and y can be used in calculations:\n\nx^2\n\n[1] 25\n\nx + y + 3\n\n[1] 18\n\n\nHere, x and y serve as variable names, enabling further manipulation and analysis within commands.\n\n\n1.3.3 Functions with Constants and Variables\nConstants and variables are frequently used with R functions, which perform specific operations. For example:\n\nsum(1, 2, 3)  \n\n[1] 6\n\nx &lt;- 1.23456\nround(x, 2)     ## round x to 2 decimal places\n\n[1] 1.23\n\nlog(b) \n\nError in log(b): non-numeric argument to mathematical function\n\n\nlog(b) is invalid (as \"a\" isn’t numeric), illustrating that functions require compatible object types. Functions enhance your ability to work with objects, a skill you’ll develop further.\n\n\n1.3.4 Operators and Their Function-Like Nature\nOperators differ from functions in that they are placed between constants or variables to perform calculations. For example:\n\n1:10       ## sequence operator :\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx * 2      ## multiplication operator *\n\n[1] 2.46912\n\n\nThese operators can be treated as functions by enclosing them within backticks, single quotes, or double quotes.\n\n3 + 5\n\n[1] 8\n\n`+`(3, 5)\n\n[1] 8\n\n'+'(3, 5)\n\n[1] 8\n\n\"+\"(3, 5)\n\n[1] 8\n\n\nHowever, this approach, by treating an operator as a function, is not commonly used in R and is typically reserved for advanced contexts, with the standard infix notation (e.g., 3 + 5) being preferred for readability.\n\n\n1.3.5 Braces and Special Symbols\nBraces and symbols are critical for structuring R code. Following an explanation of functions and operators, this section examines braces, which are fundamental to R’s syntax:\n\nParentheses (): Used to call functions and to group expressions for controlling order of operations.\n\nsum(1, 2) \n\n[1] 3\n\n(1 + 2) * 3\n\n[1] 9\n\n\nSquare Brackets []: Select elements from objects\n\nvec &lt;- c(1, 2, 3)\nvec[1]\n\n[1] 1\n\n\nCurly Braces {}: Group multiple commands into a single block, allowing them to be evaluated together.\n\n{\n  x &lt;- 5\n  print(x)\n}\n\n[1] 5\n\n\n\n\n\n1.3.6 Commands and Expressions\nAn R command is a complete line of code that directs R to perform a specific action, such as assigning values, loading packages, or analyzing data. Commands produce output and can be executed in the RStudio console. For example, x &lt;- 5 is a command that assigns a value.\nAn R expression is a component of a command or a standalone code segment that evaluates to a value. Within a command like log(2) + exp(5), log(2) is an expression yielding approximately 0.693. Expressions are the building blocks of commands, producing results in R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#an-overview-of-r-objects",
    "href": "intro.html#an-overview-of-r-objects",
    "title": "1  Getting Started with Base R",
    "section": "1.4 An Overview of R Objects",
    "text": "1.4 An Overview of R Objects\nWithin the R language, it is important to recognize that everything is treated as an object. R data objects can be classified based on their dimensionality and whether their contents share the same data type. The five common data types are organized in the following table:\n\n\n\nDimension\nHomogeneous\nHeterogeneous\n\n\n\n\n1\nVector\nList\n\n\n2\nMatrix\nData Frame\n\n\nN\nArray\n\n\n\n\nEach of these R objects possesses unique attributes, and the number of attributes varies from one object to another. When working with objects in R, it is crucial to distinguish between different R objects and to comprehend the distinctions among them.\n\n1.4.1 Storage Mode and Class\nThe characteristics of R objects are often described by their storage mode and class. You can determine the storage mode of each object using the typeof() function. For example:\n\nn1 &lt;- c(1, 4, pi, 10)\nn1\n\n[1]  1.000000  4.000000  3.141593 10.000000\n\ntypeof(n1)\n\n[1] \"double\"\n\n\nThe most frequently encountered modes include numeric (which can be either integer or double), character, and logical. The class attribute provides information about the data structure of an object. It is worth noting that the concept of class is closely related to object-oriented programming, though this is not covered in this course. You can determine the class of each object by using the class() function. For instance, the following command creates a matrix, n2, from n1 using the matrix() function:\n\nn2 &lt;- matrix(n1, nrow = 2)\nn2\n\n     [,1]      [,2]\n[1,]    1  3.141593\n[2,]    4 10.000000\n\ntypeof(n2)  \n\n[1] \"double\"\n\nclass(n2)   \n\n[1] \"matrix\" \"array\" \n\nclass(n1)   \n\n[1] \"numeric\"\n\n\nAn object can belong to more than one class, as seen with n2, which is both a matrix and, more broadly, an array with only two dimensions. It is important to note that the storage mode of n2 remains double. The distinction between n1 and n2 is primarily based on their class: n1 is a one-dimensional vector, while n2 is a matrix, a specific type of array.\nThe following example creates a list using the list() function, and both typeof() and class() functions return list:\n\nl1 &lt;- list(n = c(1, 3), ch = \"a\")\nl1\n\n$n\n[1] 1 3\n\n$ch\n[1] \"a\"\n\ntypeof(l1)  \n\n[1] \"list\"\n\nclass(l1)   \n\n[1] \"list\"\n\n\nYou can generate a data frame using the data.frame() function. A data frame is a particular type of list object. We will delve further into data frames in the upcoming chapter.\n\nd1 &lt;- data.frame(n = 1:26, L = LETTERS)\nd1\n\n    n L\n1   1 A\n2   2 B\n3   3 C\n4   4 D\n5   5 E\n6   6 F\n7   7 G\n8   8 H\n9   9 I\n10 10 J\n11 11 K\n12 12 L\n13 13 M\n14 14 N\n15 15 O\n16 16 P\n17 17 Q\n18 18 R\n19 19 S\n20 20 T\n21 21 U\n22 22 V\n23 23 W\n24 24 X\n25 25 Y\n26 26 Z\n\ntypeof(d1) \n\n[1] \"list\"\n\nclass(d1)   \n\n[1] \"data.frame\"\n\n\nAll these objects will be explored in detail in the next chapter.\n\n\n1.4.2 The is.xxx() Function\nThe function that starts with is. tests whether its argument is of a specified mode or class. The result from this type of function is either TRUE or FALSE. For example, you can use is.numeric(), is.character(), and is.logical() to check if an argument is numeric, character, or logical, respectively.\n\nis.numeric(n2)    \n\n[1] TRUE\n\nis.character(n2)  \n\n[1] FALSE\n\n\nThere are additional is.xxx() functions that can be employed to check whether an argument has a specific data structure, such as is.vector(), is.matrix(), and is.array().\n\nis.vector(n2)   \n\n[1] FALSE\n\nis.matrix(n2)   \n\n[1] TRUE\n\n\n\n\n1.4.3 Displaying Objects\nFor smaller objects, you can easily display them by typing their names. However, many R objects can be considerably large. In such cases, you can employ various R functions to gain insight into the internal structure of an object. Functions like str(), head(), tail(), and more can provide you with a summary of an object’s content and help you explore its properties.\nThe str() function can succinctly display the internal structure of an R object.\n\nstr(n1)  \n\n num [1:4] 1 4 3.14 10\n\nstr(d1)  \n\n'data.frame':   26 obs. of  2 variables:\n $ n: int  1 2 3 4 5 6 7 8 9 10 ...\n $ L: chr  \"A\" \"B\" \"C\" \"D\" ...\n\n\nYou can use the head() or tail() function to display the first or last portions of an object.\n\nhead(d1)  # First 6 rows\n\n  n L\n1 1 A\n2 2 B\n3 3 C\n4 4 D\n5 5 E\n6 6 F\n\ntail(d1)  # Last 6 rows\n\n    n L\n21 21 U\n22 22 V\n23 23 W\n24 24 X\n25 25 Y\n26 26 Z\n\n\n\n\n1.4.4 Missing Values\nMissing data can have a substantial impact on the accuracy and validity of your analyses. If not properly identified and addressed, they can introduce bias and lead to erroneous conclusions.\nIn R, missing values are typically represented as NA, which is a logical vector of length 1. When NA is included within the c() function, it is automatically coerced to the correct data type. It is important to note that missing values can be intentional or may arise from various factors, including computations or data type conversions.\nIn the following example, the missing values result from the as.numeric() function, which attempts to convert a character vector into a numeric vector.\n\nc1 &lt;- c(\"A\", \"B\", \"C\")\nas.numeric(c1) \n\nWarning: NAs introduced by coercion\n\n\n[1] NA NA NA\n\n\nThe is.na() function is a valuable tool for identifying missing values within a vector. It operates by returning a logical vector of the same length as its input, where each element corresponds to the presence or absence of a missing value. For example, if you apply is.na() to a vector, you will obtain a logical vector with TRUE at the positions where missing values are present and FALSE where data is available.\n\nn4 &lt;- c(1, NA, 3)\nis.na(n4)  \n\n[1] FALSE  TRUE FALSE\n\n\nTypically, when performing operations on missing value(s) represented by NA, the result is also a missing value(s) NA. However, almost all descriptive statistical functions, such as sum(), mean(), median(), and others, provide an na.rm= argument, and setting it to na.rm = TRUE allows the removal of missing values during these operations.\n\nsum(n4)       # Returns NA\n\n[1] NA\n\nsum(n4, na.rm = TRUE)  # Returns 4\n\n[1] 4",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#getting-help",
    "href": "intro.html#getting-help",
    "title": "1  Getting Started with Base R",
    "section": "1.5 Getting Help",
    "text": "1.5 Getting Help\nAccessing help resources in R is critical for understanding functions, resolving errors, and developing coding proficiency. R provides built-in tools to access documentation within the environment, complemented by external community resources.\nTo retrieve documentation for a specific function, the help() function or its shorthand, ?, is used. For instance, entering help(matrix) or ?matrix in the console displays the help file for the matrix() function, which creates a matrix from a vector with specified dimensions. Most R help files consist of the following sections, though some may be omitted depending on the function:\n\nDescription: Explains the function’s purpose, stating that matrix() constructs a matrix from a given vector.\nUsage: Shows the function’s syntax, such as matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL).\nArguments: Lists inputs, including data(the input vector), nrow (number of rows), and ncol (number of columns), with explanations of their roles.\nDetails: Provides additional context, such as how matrix() handles vector recycling if the data length does not match the specified dimensions.\nValue: Describes the output, typically the result of the function, though this section is not included in the matrix() help file.\nExamples: Provides sample code demonstrating practical applications, such as creating a 2x2 matrix.\n\nFor operators such as +, -, or ^, the operator must be enclosed in single or double quotes when accessing help:\n\nhelp(\"^\")\n\nTo examine a function’s arguments without opening the full help file, the args() function displays the argument list. For example:\n\nargs(matrix)\n\nfunction (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) \nNULL\n\n\nThis output indicates that matrix() accepts arguments such as data=, nrow=, and ncol=, enabling the creation of a matrix with specified dimensions.\nExternal resources provide additional support. Platforms such as Stack Overflow, the RStudio Community, and R-bloggers offer forums for posing questions and accessing solutions from the R community, enhancing the documentation available within R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#r-packages",
    "href": "intro.html#r-packages",
    "title": "1  Getting Started with Base R",
    "section": "1.6 R Packages",
    "text": "1.6 R Packages\nThe R system comprises two fundamental components: the base R system and contributed packages. The base R system, installed initially, includes essential packages containing core functions, such as matrix() for creating matrices. Additional packages, which extend R’s functionality, are available from repositories like the Comprehensive R Archive Network (CRAN) and Bioconductor.\nTo install a package from CRAN, the install.packages() function is used. For instance, the following command installs the survival package, which provides tools for survival analysis:\n\ninstall.packages(\"survival\")\n\nFor packages from Bioconductor, a repository for bioinformatics tools, the BiocManager::install() function is employed after installing the BiocManager package from CRAN. For example, to install the Biobase package, which supports genomic data analysis, the following commands are used:\n\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"Biobase\")\n\nOnce installed, packages are stored on the computer’s hard drive. To access a package’s functions in an R session, the library() function loads the package into the environment. For example:\n\nlibrary(survival)\n\nFunctions from the base R system, such as matrix(), require no package loading, as they are available by default.\nTo access a specific function from a package without loading it, the :: operator is used, specifying the package and function name, for example: survival::coxph(). This approach allows direct use of a function, such as coxph() from the survival package, without making all package functions readily available, which helps avoid conflicts between packages with similarly named functions.\nExternal resources, such as CRAN’s package documentation and Bioconductor’s support forums, provide further guidance on package usage and troubleshooting, complementing R’s built-in help system.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#session-management",
    "href": "intro.html#session-management",
    "title": "1  Getting Started with Base R",
    "section": "1.7 Session Management",
    "text": "1.7 Session Management\n\n1.7.1 Working Directory\nThe working directory serves as the default location for file-related operations in R, such as loading data or saving files. It functions as the primary directory for an R session. To identify the working directory, the getwd() function is used:\n\ngetwd()\n\n[1] \"C:/Users/Public/Desktop\"\n\n\nTo list all files and folders in the working directory, the dir() function is employed:\n\ndir()\n\n [1] \"Adobe Acrobat XI Pro.lnk\" \"Adobe FormsCentral.lnk\"  \n [3] \"desktop.ini\"              \"Firefox.lnk\"             \n [5] \"Git Bash.lnk\"             \"Google Chrome.lnk\"       \n [7] \"Mullvad VPN.lnk\"          \"R 4.4.1.lnk\"             \n [9] \"R 4.4.3.lnk\"              \"WinEdt 11.lnk\"           \n\n\nTo change the working directory, the setwd() function specifies a new location within the file system. File paths in R should use forward slashes (/) rather than backslashes (\\), as backslashes are not valid in R. For example, a path copied from a Windows environment, such as C:\\Users\\art\\OneDrive, must be converted to use forward slashes:\n\nsetwd(\"C:/Users/art/OneDrive\")\n\nR also supports relative paths using shortcut notations:\n\n\".\" refers to the current directory\n\"..\" refers to the parent directory\n\"./folder\" refers to a subfolder named folder inside the current directory\n\"../folder\" accesses a subfolder one level above\n\nFor example:\n\nsetwd(\"../Documents/data\")\n\n\n\n1.7.2 Workspace\nThe R workspace serves as a temporary storage area for all objects created during a session, including variables, data frames, functions, and other data structures. To view the objects stored in the workspace, the ls() function displays their names in the console:\n\nls()\n\n [1] \"b\"   \"c1\"  \"d1\"  \"l1\"  \"n1\"  \"n2\"  \"n4\"  \"vec\" \"x\"   \"y\"  \n\n\nEach time data is created or loaded, variables are assigned, or calculations are performed, the resulting objects are stored in the workspace, making them available for use throughout the session. For example, assigning a matrix to a variable adds it to the workspace:\n\nm1 &lt;- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2)\nls()\n\n [1] \"b\"   \"c1\"  \"d1\"  \"l1\"  \"m1\"  \"n1\"  \"n2\"  \"n4\"  \"vec\" \"x\"   \"y\"  \n\n\nTo remove specific objects from the workspace, the rm() function is used. For instance, to delete objects named m1 and n1:\n\nrm(m1, n1)\nls()\n\n[1] \"b\"   \"c1\"  \"d1\"  \"l1\"  \"n2\"  \"n4\"  \"vec\" \"x\"   \"y\"  \n\n\nTo clear all objects, the command rm(list = ls()) removes everything listed by ls().\nThe workspace is temporary, and its contents are lost when the session ends unless explicitly saved. To save all workspace objects to a file in the working directory, the save.image() function is used, with the file path specified using forward slashes. For example:\n\nsave.image(\"C:/Users/art/OneDrive/lect1.RData\")\n\nTo save specific objects, the save() function specifies the objects and a file name:\n\nsave(c1, n1, file = \"C:/Users/art/OneDrive/c1_n1.RData\")\n\nAlternatively, to save a single object, the saveRDS() function serializes it to a file:\n\nsaveRDS(c1, file = \"C:/Users/art/OneDrive/c1.RDS\")\n\nTo retrieve saved objects, the load() function restores all objects from a file created by save() or save.image():\n\nload(\"C:/Users/art/OneDrive/lect1.RData\")\n\nTo retrieve a single object saved with saveRDS(), the readRDS() function reads it into the workspace, assigning it to a variable:\n\nc1 &lt;- readRDS(\"C:/Users/art/OneDrive/c1.RDS\")\n\nThese commands load objects from files into the workspace, enabling their use.\n\n\n\n\nPosit. 2025. “RStudio Desktop - Download.” Posit, PBC. https://posit.co/download/rstudio-desktop/.\n\n\nR Core Team. 2025. “R: A Language and Environment for Statistical Computing.” Vienna, Austria: R Foundation for Statistical Computing. https://www.r-project.org/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "objects1.html",
    "href": "objects1.html",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "",
    "text": "2.1 Vectors\nVectors are the simplest and most fundamental objects in R, serving as the building blocks for data analysis. They are one-dimensional, homogeneous collections of elements, meaning all elements must share the same data type. This section covers how to create vectors, understand their types and attributes, and perform basic operations like accessing elements and concatenation.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#vectors",
    "href": "objects1.html#vectors",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "",
    "text": "2.1.1 Types of Vectors\nVectors in R are atomic, meaning they cannot contain mixed data types, and come in four common types: integer, double, logical, and character. The c() function, which stands for “concatenate,” is the primary method for creating vectors. To explore a vector’s properties, use typeof() to check its storage mode (data type) and class() to confirm its structure, which for vectors is typically numeric, logical, or character. The length() function returns the number of elements in a vector, reflecting its linear structure.\n\nv &lt;- c(2.9, 3.5, 4.5, NA, 3, 2.4)\nv\n\n[1] 2.9 3.5 4.5  NA 3.0 2.4\n\ntypeof(v)\n\n[1] \"double\"\n\nclass(v)\n\n[1] \"numeric\"\n\nlength(v)\n\n[1] 6\n\n\nBy default, R stores numbers as double (double-precision real numbers). To create an integer vector, append the L suffix to numbers, explicitly indicating integer values. This is often encountered in vectors generated by R functions, such as sequences. For example, functions like seq() or operations in Bioconductor packages, such as those for genomic data analysis, may produce integer vectors to optimize storage efficiency. This is particularly common when handling large datasets where integer types reduce memory usage.\n\ni &lt;- c(1L, 3L, 10L)\ni\n\n[1]  1  3 10\n\ntypeof(i)\n\n[1] \"integer\"\n\nclass(i)\n\n[1] \"integer\"\n\n\nCharacter vectors are common when accessing text data, such as columns in a data frame read from external files. Enclose character values in quotation marks (\" \" or ' '), except for NA, which represents missing values.\n\ncolors &lt;- c(\"red\", \"green\", \"blue\", \"yellow\", NA, \"purple\")\ncolors\n\n[1] \"red\"    \"green\"  \"blue\"   \"yellow\" NA       \"purple\"\n\ntypeof(colors)\n\n[1] \"character\"\n\nclass(colors)\n\n[1] \"character\"\n\n\nLogical vectors, consisting of TRUE or FALSE (also T or F), often result from comparisons (covered later in this chapter). They are useful for filtering or conditional operations.\n\nlogical_vec &lt;- c(TRUE, NA, T, F)\ntypeof(logical_vec)\n\n[1] \"logical\"\n\nclass(logical_vec)\n\n[1] \"logical\"\n\n\n\n\n2.1.2 Accessing Elements in a Vector\nA common task is accessing or extracting elements from a vector. This section introduces positional indexing, one of five methods for accessing elements (additional methods are covered in Chapter 4). Since vectors are linear, elements are indexed by their position (1, 2, …, N). Use square brackets [] with an index vector to select elements. An index vector specifies the positions of elements to extract from the target vector.\n\nv &lt;- c(2.9, 3.5, 4.5, NA, 3, 2.4) \nv[1]\n\n[1] 2.9\n\n\nTo select multiple elements, create an index vector using c(). For example, to extract the first, second, and fourth elements:\n\nv[c(1,2,4)]\n\n[1] 2.9 3.5  NA\n\n\nFor consecutive elements, use the colon operator (:) to generate a sequence of positions. The following selects the second through fifth elements:\n\nv[2:5]\n\n[1] 3.5 4.5  NA 3.0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#attributes",
    "href": "objects1.html#attributes",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.2 Attributes",
    "text": "2.2 Attributes\nAttributes are metadata associated with R objects, such as vectors, providing additional information like names or custom descriptors. They enhance data organization and accessibility, especially in data analysis tasks.\n\n2.2.1 The Names Attribute\nVectors can have a names attribute to label elements, making them easier to reference. Use the names() function to assign or retrieve names.\n\nv &lt;- c(2, 3, 3.5, 6.7) \nnames(v) &lt;- c(\"a\", \"b\", \"c\", \"d\")\nv\n\n  a   b   c   d \n2.0 3.0 3.5 6.7 \n\nnames(v)\n\n[1] \"a\" \"b\" \"c\" \"d\"\n\n\nElements can be accessed using names within square brackets, offering a descriptive alternative to positional indexing.\n\nv[\"a\"]\n\na \n2 \n\nv[c(\"a\", \"c\")]\n\n  a   c \n2.0 3.5 \n\n\nNames can also be assigned during vector creation using the c() function with named arguments.\n\nv &lt;- c(first=1, second=pi, third = sqrt(2))\nv\n\n   first   second    third \n1.000000 3.141593 1.414214 \n\n\nA vector with a names attribute is called a named vector, commonly used for clarity in data analysis.\n\n\n2.2.2 User-defined Attributes\nBeyond the names attribute, you can create custom attributes using the attr() function. This allows attaching metadata, such as creation dates or descriptions, to objects. Use attr() to set or retrieve specific attributes, and attributes() to view all attributes.\n\nattr(v, \"when\") &lt;- \"Created on 6/24/25\"\nv\n\n   first   second    third \n1.000000 3.141593 1.414214 \nattr(,\"when\")\n[1] \"Created on 6/24/25\"\n\nattr(v, \"when\")\n\n[1] \"Created on 6/24/25\"\n\nattr(v, \"names\")\n\n[1] \"first\"  \"second\" \"third\" \n\nattributes(v)\n\n$names\n[1] \"first\"  \"second\" \"third\" \n\n$when\n[1] \"Created on 6/24/25\"\n\n\nThe attributes() function returns a list, highlighting that attributes are stored as a list object. As emphasized in Chapter 1, “everything in R is an object,” so always check the type and structure of function outputs using typeof() and class() to build proficiency.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#concatenation",
    "href": "objects1.html#concatenation",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.3 Concatenation",
    "text": "2.3 Concatenation\nConcatenation involves combining vectors of the same data type to create a larger vector. The c() function is the primary tool for this operation, essential for data manipulation tasks.\n\n2.3.1 Concatenating Vectors\nTo combine vectors, use c() to append elements or vectors.\n\nv\n\n   first   second    third \n1.000000 3.141593 1.414214 \nattr(,\"when\")\n[1] \"Created on 6/24/25\"\n\nv1 &lt;- c(v, 3)\nv1\n\n   first   second    third          \n1.000000 3.141593 1.414214 3.000000 \n\nv2 &lt;- c(v, v1)\nv2\n\n   first   second    third    first   second    third          \n1.000000 3.141593 1.414214 1.000000 3.141593 1.414214 3.000000 \n\nv3 &lt;-  c(v, extra = 3)\nv3\n\n   first   second    third    extra \n1.000000 3.141593 1.414214 3.000000 \n\n\nThe extra name in the last example assigns a label to the new element, preserving the original names from v while adding a descriptive identifier for clarity.\n\n\n2.3.2 Coercion\nWhen combining vectors of different data types, R applies coercion to convert them to a common type, following the hierarchy: logical → integer → double → character. This ensures operations proceed without errors but may affect data integrity.\nFor implicit coercion, R automatically converts types based on the hierarchy.\n\ntypeof(c(FALSE, 1L))\n\n[1] \"integer\"\n\ntypeof(c(1L, pi))\n\n[1] \"double\"\n\ntypeof(c(pi, \"pi\"))\n\n[1] \"character\"\n\n\nExplicit coercion uses as.xxx() functions (e.g., as.numeric(), as.character()) to control type conversion.\n\nas.logical(c(FALSE, 1L))\n\n[1] FALSE  TRUE\n\n\nCoercion can lead to data loss or missing values. For example, converting doubles to integers truncates decimals, and non-numeric characters to numbers produce NA.\n\nas.integer(c(1L, pi))\n\n[1] 1 3\n\nas.double(c(pi, \"pi\"))\n\nWarning: NAs introduced by coercion\n\n\n[1] 3.141593       NA\n\n\nBe cautious with coercion to avoid unintended data loss, and always verify the resulting data type using typeof() or class().",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#vectorized-operations",
    "href": "objects1.html#vectorized-operations",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.4 Vectorized Operations",
    "text": "2.4 Vectorized Operations\nVectorized operations are a cornerstone of R, enabling efficient and concise data manipulation by applying computations to entire vectors in a single expression. Unlike traditional programming languages that require explicit loops, R’s vectorized approach leverages optimized C and Fortran code, making it ideal for statistical computing and large datasets. This section explores how vectorized operations work on vectors, including element-wise arithmetic, scalar operations, and recycling, laying the groundwork for comparisons that produce logical vectors later in this chapter.\n\n2.4.1 Element-Wise Arithmetic\nWhen applying an arithmetic operation (e.g., +, -, *, /) to two vectors of the same length, R performs the operation element-wise, producing a new vector of the same length. Each element in the result corresponds to the operation applied to the paired elements of the input vectors.\n\nv1 &lt;- c(1, 2, 3)\nv2 &lt;- c(4, 5, 6)\nv1 + v2\n\n[1] 5 7 9\n\nv1 * v2\n\n[1]  4 10 18\n\n\nIn these examples, R adds or multiplies corresponding elements: \\(1 + 4 =5\\), \\(2 + 5 = 7\\), \\(3 + 6 = 9\\) for addition, and \\(1 \\times 4 = 4\\), \\(2 \\times 5 = 10\\), \\(3 \\times 6 = 18\\) for multiplication.\n\n\n2.4.2 Scalar Operations\nVectorized operations allow a single value (scalar) to be applied to every element of a vector. R automatically recycles the scalar to match the vector’s length, simplifying tasks like scaling or offsetting data values.\n\nv1 &lt;- c(1, 2, 3)\nv1 + 5\n\n[1] 6 7 8\n\nv1 * 2\n\n[1] 2 4 6\n\n\nHere, R adds 5 or multiplies by 2 for each element of v1, equivalent to operating with a vector c(5, 5, 5) or c(2, 2, 2).\n\n\n2.4.3 Recycling with Unequal Lengths\nWhen vectors have different lengths, R recycles the shorter vector to match the longer one’s length. If the longer vector’s length is a multiple of the shorter one, recycling is seamless. Otherwise, R issues a warning but completes the operation.\n\nv3 &lt;- c(7, 8)\nv1 + v3\n\nWarning in v1 + v3: longer object length is not a multiple of shorter object\nlength\n\n\n[1]  8 10 10\n\n\nIn this example, v3 is recycled as c(7, 8, 7) to match v1’s length, adding element-wise: \\(1+7=8\\), \\(2+8=10\\), \\(3+7=10\\). Be cautious with recycling, as mismatched lengths may lead to unintended results. Use length() to verify vector lengths before operations to avoid such issues.\n\n\n2.4.4 Vectorized Functions\nMany Base R functions, such as sqrt() and log(), are vectorized, applying computations to each element of a vector without loops. These are useful for transforming data in statistical analyses.\n\nv1 &lt;- c(1, 4, 9)\nsqrt(v1)\n\n[1] 1 2 3\n\nlog(v1)\n\n[1] 0.000000 1.386294 2.197225",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#numeric-vectors",
    "href": "objects1.html#numeric-vectors",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.5 Numeric Vectors",
    "text": "2.5 Numeric Vectors\nNumeric vectors, encompassing both integer and double types, are essential for quantitative data analysis in R. While the c() function is ideal for creating small vectors without patterns, R provides specialized functions like seq(), rep(), and random number generators to efficiently create numeric vectors with specific patterns or distributions. This section explores these functions, enabling you to generate sequences, replicate values, and simulate data, building on the vector concepts from earlier sections.\n\n2.5.1 The seq() Function\nThe colon operator (:) generates a sequence of integers with a step size of 1, in ascending or descending order.\n\n2:6\n\n[1] 2 3 4 5 6\n\n4:-3\n\n[1]  4  3  2  1  0 -1 -2 -3\n\n\nThe more frequently used method for generating a sequence of numbers is by employing the seq() function. The first two arguments, named from= and to=, define the starting and ending points of the sequence.\n\nseq(5, 10)\n\n[1]  5  6  7  8  9 10\n\n\nThe by= argument specifies the step size, while length.out= sets the desired number of elements. These arguments are mutually exclusive, as specifying both would create ambiguity in the sequence’s structure.\n\nseq(2, 20, by=3)\n\n[1]  2  5  8 11 14 17 20\n\nseq(2, 20, length.out=7)\n\n[1]  2  5  8 11 14 17 20\n\n\nThe seq_along() function generates a sequence of integers from 1 to the length of a given vector, useful for creating indices for data analysis tasks.\n\nmy_vector &lt;- c(\"apple\", \"banana\", \"cherry\")\nseq_along(my_vector)\n\n[1] 1 2 3\n\n\nThis sequence corresponds to the positions of elements in my_vector, facilitating tasks like iterating over vector elements.\n\n\n2.5.2 The rep() Function\nThe rep() function replicates a vector or its elements, offering flexibility for creating repeated patterns. Its main arguments are x= (the vector to replicate) and times= (the number of repetitions).\nWhen times is a single integer, the entire vector x is repeated that number of times.\n\ni &lt;- rep(2, 4)\ni\n\n[1] 2 2 2 2\n\nx &lt;- 1:4\ny &lt;- rep(x, 2)\ny\n\n[1] 1 2 3 4 1 2 3 4\n\n\nWhen times is a vector of the same length as x, each element x[i] is repeated times[i] times, allowing customized repetition patterns.\n\nz &lt;- rep(x, i)\nz\n\n[1] 1 1 2 2 3 3 4 4\n\nw &lt;- rep(x, x)\nw\n\n [1] 1 2 2 3 3 3 4 4 4 4\n\n\nUse length() to verify the resulting vector’s length, especially for complex repetition patterns.\n\n\n2.5.3 The Random Number Generator Functions\nRandom number generators in R create vectors based on probability distributions, such as uniform or normal, and are named with the prefix r (e.g., runif(), rnorm()). These functions are valuable for simulations in statistics and data analysis. Below is a table of common random number generators and their distributions.\n\n\n\nFunction\nDistribution\n\n\n\n\nrunif(n, min=0, max=1)\nUniform\n\n\nrnorm(n, mean=0, sd=1)\nNormal\n\n\nrbinom(n, size, prob)\nBinomial\n\n\nrpois(n, lambda)\nPoisson\n\n\nrexp(n, rate = 1)\nExponential\n\n\nrt(n, df)\nT\n\n\nrf(n, df1, df2)\nF\n\n\nrchisq(n, df)\nChi square\n\n\n\nTo generate 100 numbers from a normal distribution with mean 2 and standard deviation 3:\n\nn &lt;- rnorm(100, 2, 3)\nhead(n)\n\n[1]  1.928964  1.288082  5.086042  5.236424  2.931389 -1.694067\n\nmean(n)\n\n[1] 1.722565\n\nsd(n)\n\n[1] 2.824913\n\n\nThe set.seed() function ensures reproducibility by fixing the random number generator’s starting point. Setting the same seed produces identical random sequences, which is crucial for debugging and sharing results.\n\nset.seed(123)\nrandom_vector1 &lt;- rnorm(5, mean = 0, sd = 1)\nrandom_vector1\n\n[1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774\n\nset.seed(123)\nrandom_vector2 &lt;- rnorm(5, mean = 0, sd = 1)\nrandom_vector2\n\n[1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774\n\n\nAlways set a seed before generating random numbers to ensure consistent results across sessions.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#logical-vectors",
    "href": "objects1.html#logical-vectors",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.6 Logical Vectors",
    "text": "2.6 Logical Vectors\nLogical vectors, consisting of TRUE and FALSE values, are fundamental for conditional operations and data filtering in R. Logical Vectors are often generated through comparisons and manipulated using logical operators. This section explores how to create logical vectors with relational operators, handle missing values, apply Boolean algebra, and use logical vectors in practical data analysis tasks, such as counting or summarizing conditions.\n\n2.6.1 Generating Logical Vectors\nLogical vectors are commonly created using relational operators: &lt;, &lt;=, &gt;, &gt;=, == (exact equality), and != (exact inequality). These operators compare vectors element-wise, producing a logical vector where TRUE indicates the condition is met and FALSE indicates it is not.\n\nv &lt;- c(seq(2, 4), NA)\nv &gt; 3\n\n[1] FALSE FALSE  TRUE    NA\n\n\nIn this example, v &gt; 3 checks if each element exceeds 3, returning NA for missing values. Be cautious when using == with numeric vectors due to floating-point precision issues.\n\nx &lt;- c(1 / 49 * 49, sqrt(2)^2)\nx\n\n[1] 1 2\n\nx == c(1, 2)\n\n[1] FALSE FALSE\n\n\nThe which() function converts a logical vector to an integer vector of indices where the condition is TRUE, ignoring NA values.\n\nwhich(v &gt; 3)\n\n[1] 3\n\n\n\n\n2.6.2 Handling Missing Values\nOperations involving missing values (NA) in logical vectors typically result in NA, as the outcome depends on an unknown value.\n\nNA &gt; 5\n\n[1] NA\n\n10 == NA\n\n[1] NA\n\nNA == NA\n\n[1] NA\n\n\nUse is.na(), introduced in Chapter 1, to identify missing values in any vector type, returning TRUE for NA and FALSE otherwise.\n\nis.na(c(1, NA, 3))\n\n[1] FALSE  TRUE FALSE\n\nis.na(c(\"a\", NA, \"b\"))\n\n[1] FALSE  TRUE FALSE\n\nis.na(c(TRUE, NA, FALSE))\n\n[1] FALSE  TRUE FALSE\n\n\n\n\n2.6.3 Logical Operators and Boolean Algebra\nLogical operators &, |, and ! perform element-wise Boolean algebra on logical vectors. The & operator returns TRUE for elements where both vectors are TRUE (logical AND), | returns TRUE if at least one is TRUE (logical OR), and ! negates the vector.\n\nh &lt;- c(1, 10, 3.5, 8, 8)\nh1 &lt;- h &gt; 5\nh1\n\n[1] FALSE  TRUE FALSE  TRUE  TRUE\n\nh2 &lt;- h == 8\nh2 \n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\nh1 & h2\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\nh1 | h2\n\n[1] FALSE  TRUE FALSE  TRUE  TRUE\n\n!h1\n\n[1]  TRUE FALSE  TRUE FALSE FALSE\n\n\nFor missing values, Boolean operations follow specific rules due to the ambiguity of NA, which could be either TRUE or FALSE. The result and reasoning are summarized in the tables below.\nOR Logic (|)\n\n\n\n\n\n\n\n\nX\nx | NA\nreasoning\n\n\n\n\nTRUE\nTRUE\nAt least one is TRUE - result is guaranteed TRUE\n\n\nFALSE\nNA\nNA could be TRUE or FALSE - result is unknown\n\n\nNA\nNA\nBoth values unknown - result is unknown\n\n\n\nAND Logic (&)\n\n\n\n\n\n\n\n\nX\nx & NA\nreasoning\n\n\n\n\nTRUE\nNA\nNA could be TRUE or FALSE - result is unknown\n\n\nFALSE\nFALSE\nOne is FALSE - result is guaranteed FALSE\n\n\nNA\nNA\nBoth values unknown - result is unknown\n\n\n\nThe %in% operator checks if elements of one vector are present in another, returning TRUE for matches. Unlike ==, NA %in% NA is TRUE.\n\nc(1, 2, NA) %in% NA\n\n[1] FALSE FALSE  TRUE\n\nc(1, 2, NA) == NA\n\n[1] NA NA NA\n\nc(1:5, NA) %in% c(1, 5, 11)\n\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n\n\n\n\n2.6.4 The all() and any() Functions\nThe all() and any() functions summarize logical vectors. all() returns TRUE if all elements are TRUE, while any() returns TRUE if at least one element is TRUE. Missing values may affect results unless handled with na.rm=TRUE.\n\nf &lt;- c(3.01, 3.001, 3.0001, 3.00001)\nany (f == 3.001, na.rm=TRUE)\n\n[1] TRUE\n\nany (f &gt;3.1, na.rm=TRUE)\n\n[1] FALSE\n\nall (f &gt; 3.001, na.rm=TRUE)\n\n[1] FALSE\n\n\nInstead of using the any() or all() functions, we can solve problems based on what we’ve learned. For example, the following commands illustrates how to test if any elements in F equal 3.001?\nInstead of relying solely on any() or all(), you can use techniques learned earlier. For example, to test if any elements in f equal 3.001, follow these steps:\n\n## Step 1: Compare f with 3.001 using ==\nf == 3.001\n\n[1] FALSE  TRUE FALSE FALSE\n\n## Step 2: Count the number of elements in f equal to 3.001\nsum(f == 3.001, na.rm=TRUE)\n\n[1] 1\n\n## Step 3: Check if the count is greater than 0\nsum(f == 3.001, na.rm=TRUE) &gt; 0\n\n[1] TRUE\n\n\n\n\n2.6.5 Numeric Summaries\nLogical vectors are coerced to numeric values in arithmetic operations, with TRUE as 1 and FALSE as 0. This enables counting or proportion calculations, such as determining how many elements meet a condition. Additionally, mean() gives the proportion of TRUE values where x is a logical vector.\n\nv &lt;- c(seq(1, 6, by=0.5), 10)\nmean_v &lt;- mean(v, na.rm=TRUE)\nmean_v\n\n[1] 4.041667\n\nv &gt; mean_v\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nsum(v &gt; mean_v)\n\n[1] 5\n\nmean(v &gt; mean_v)\n\n[1] 0.4166667\n\n\nIn this example, sum(v &gt; mean_v) counts elements greater than the mean, and mean(v &gt; mean_v) gives the proportion.\nFor a vector with missing values, use na.rm=TRUE to compute the proportion accurately.\n\nv_with_na &lt;- c(1, 2, 3, NA, 5)\nmean(v_with_na &gt; 3, na.rm=TRUE)\n\n[1] 0.25\n\n\nIn this case, v_with_na &gt; 3 yields [FALSE FALSE FALSE NA TRUE], and mean(v_with_na &gt; 3, na.rm=TRUE) excludes the NA, giving a proportion of 0.25 (or 25%) based on the one TRUE value out of four non-missing elements.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#factors",
    "href": "objects1.html#factors",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.7 Factors",
    "text": "2.7 Factors\nFactors are a specialized type of vector in R, designed to represent categorical data with a fixed set of levels. Unlike character vectors, factors impose an order on their values, which is useful for statistical modeling and data analysis. This section covers the creation of factors, their sorting behavior, handling of invalid levels, and basic subsetting, building on the vector concepts from earlier sections.\n\n2.7.1 Creating and Sorting Factors\nFactors are created using the factor() function, which converts a vector (typically character) into a factor by defining its levels with the levels= argument. Without specified levels, factor() assigns levels alphabetically based on the input, which may vary across systems.\n\nx1 &lt;- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\")\nfactor(x1)\n\n[1] Dec Apr Jan Mar\nLevels: Apr Dec Jan Mar\n\n\nTo impose a meaningful order, provide a levels= argument. The sort() function then respects this order rather than alphabetical sorting. Controlling the levels is important for statistical models because the first level is treated as the baseline, influencing coefficient interpretation.\n\nmonth_levels &lt;- c(\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n)\ny1 &lt;- factor(x1, levels=month_levels)\nsort(y1)\n\n[1] Jan Mar Apr Dec\nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nlevels(y1)\n\n [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n\ntypeof(y1)\n\n[1] \"integer\"\n\nclass(y1)\n\n[1] \"factor\"\n\nnlevels(y1)\n\n[1] 12\n\n\nTo convert a factor to a character vector, you can use the as.character() function.\n\nas.character(y1)\n\n[1] \"Dec\" \"Apr\" \"Jan\" \"Mar\"\n\n\nIf the input contains invalid levels (not in levels=), R assigns NA to those elements.\n\nx2 &lt;- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\")\ny2 &lt;- factor(x2, levels=month_levels)\ny2\n\n[1] Dec  Apr  &lt;NA&gt; Mar \nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\n\nNote that sorting is not meaningful for factors without defined levels, and system-dependent alphabetical order can lead to inconsistent results.\n\n\n2.7.2 Subsetting a Factor\nYou can extract elements from a factor using an index vector within square brackets. In the following example, a new factor is created containing only the first three elements of f. In f1, the oc level is empty but still part of the levels attribute, keeping the number of levels at 3. This can complicate interpretation in statistical functions.\n\nf &lt;- factor(c(\"la\", \"sb\", \"la\", \"oc\"), levels=c(\"la\", \"sb\", \"oc\"))\nf1 &lt;- f[1:3]\nf1\n\n[1] la sb la\nLevels: la sb oc\n\nnlevels(f1)\n\n[1] 3\n\n\nTo remove unused levels, use the following methods:\n\nfactor(f[1:3])\n\n[1] la sb la\nLevels: la sb\n\nf[1:3, drop=TRUE]\n\n[1] la sb la\nLevels: la sb\n\n\nThe drop=TRUE argument or reapplying factor() ensures unused levels are excluded, improving clarity in downstream analysis.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#matrices-and-arrays",
    "href": "objects1.html#matrices-and-arrays",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.8 Matrices and Arrays",
    "text": "2.8 Matrices and Arrays\nMatrices and arrays provide structured storage for data in tabular or multi-dimensional formats, extending the capabilities of vectors. This organization facilitates understanding and manipulation, especially in statistical and numerical computations. R offers optimized functions and operations for matrices and arrays, often outperforming vector-based approaches for larger datasets. This section explores their creation, concatenation, attributes, and basic element access, building on the vector foundation from earlier sections.\n\n2.8.1 Creating a Matrix\nA matrix is a two-dimensional array, created by assigning a dim attribute with two values (rows, columns) to a vector. The storage mode of the matrix matches that of its elements (e.g., double, integer).\n\nv &lt;- c(2.9, 3.5, 4.5, NA, 3, 2.4)\nv\n\n[1] 2.9 3.5 4.5  NA 3.0 2.4\n\ndim(v) &lt;- c(2,3)\nv\n\n     [,1] [,2] [,3]\n[1,]  2.9  4.5  3.0\n[2,]  3.5   NA  2.4\n\n\nAlternatively, use the matrix() function, which offers more control. By default, it fills the matrix column-wise.\n\nm &lt;- matrix(v, nrow=2, ncol=3)\nm\n\n     [,1] [,2] [,3]\n[1,]  2.9  4.5  3.0\n[2,]  3.5   NA  2.4\n\n\nTo fill row-wise, set byrow=TRUE.\n\nm1 &lt;- matrix(v, 2, 3, byrow = TRUE)\nm1\n\n     [,1] [,2] [,3]\n[1,]  2.9  3.5  4.5\n[2,]   NA  3.0  2.4\n\n\nThe t() function transposes a matrix, swapping rows and columns.\n\nt(m)\n\n     [,1] [,2]\n[1,]  2.9  3.5\n[2,]  4.5   NA\n[3,]  3.0  2.4\n\n\n\n\n2.8.2 Concatenating Matrices\nThe cbind() and rbind() functions combine vectors or matrices by columns or rows, respectively. For cbind(), all arguments must have the same number of rows; for rbind(), the same number of columns is required.\n\nn1 &lt;- matrix(1:4, nrow=2)\nn1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nn2 &lt;- matrix(5:10, nrow=2)\nn2\n\n     [,1] [,2] [,3]\n[1,]    5    7    9\n[2,]    6    8   10\n\ncbind(n1, n2)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n\nrbind(v, n2)\n\n     [,1] [,2] [,3]\n[1,]  2.9  4.5  3.0\n[2,]  3.5   NA  2.4\n[3,]  5.0  7.0  9.0\n[4,]  6.0  8.0 10.0\n\n\nIf the number of rows or columns differs, cbind() and rbind() may recycle elements or throw an error. For mismatched dimensions, Base R does not provide direct functions to align them automatically. Instead, consider package functions: plyr::rbind.fill() from the plyr package and dplyr::bind_rows() from the dplyr package for row binding, which can handle varying column numbers by filling with NA where needed.\nNote: Ensure compatible dimensions to avoid errors or unexpected recycling; use external packages for flexible concatenation.\n\n\n2.8.3 Matrix Attributes\nMatrices do not have a names attribute by default, but row and column names can be assigned using rownames() and colnames().\n\nrownames(v) &lt;- c(\"r1\", \"r2\")\ncolnames(v) &lt;- c(\"c1\", \"c2\", \"c3\")\nv\n\n    c1  c2  c3\nr1 2.9 4.5 3.0\nr2 3.5  NA 2.4\n\n\nThe dimnames() function assigns both row and column names simultaneously.\n\ndimnames(v) &lt;- list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\", \"c3\"))\nv\n\n    c1  c2  c3\nr1 2.9 4.5 3.0\nr2 3.5  NA 2.4\n\n\nUse length() for the total number of elements, but nrow(), ncol(), and dim() provide more meaningful dimension details. The attributes() function lists all attributes.\n\nlength(v)\n\n[1] 6\n\nnrow(v)\n\n[1] 2\n\nncol(v)\n\n[1] 3\n\ndim(v)\n\n[1] 2 3\n\nattributes(v)\n\n$dim\n[1] 2 3\n\n$dimnames\n$dimnames[[1]]\n[1] \"r1\" \"r2\"\n\n$dimnames[[2]]\n[1] \"c1\" \"c2\" \"c3\"\n\n\n\n\n2.8.4 Accessing Elements in a Matrix\nMatrix elements are accessed using two index vectors within square brackets, denoted as a[m, n], where m selects rows and n selects columns. Separate m and n with a comma. Omitting m (e.g., a[, n]) selects all rows for the specified columns, and omitting n (e.g., a[m, ]) selects all columns for the specified rows.\n\nv[2,3]\n\n[1] 2.4\n\nv[2,]\n\n c1  c2  c3 \n3.5  NA 2.4 \n\nv[,3]\n\n r1  r2 \n3.0 2.4 \n\n\nNote: This basic access is foundational; advanced indexing is covered in Chapter 4.\n\n\n2.8.5 Creating Arrays\nArrays are multi-dimensional extensions of matrices, created by specifying a dim attribute with a length of three or more. For example:\n\nx &lt;- 1:12\ndim(x) &lt;- c(2,2,3)\ndimnames(x) &lt;- list(c(\"r1\", \"r2\"), \n                    c(\"cl\", \"c2\"), \n                    c(\"pl\", \"p2\", \"p3\"))\nx\n\n, , pl\n\n   cl c2\nr1  1  3\nr2  2  4\n\n, , p2\n\n   cl c2\nr1  5  7\nr2  6  8\n\n, , p3\n\n   cl c2\nr1  9 11\nr2 10 12\n\nattributes(x)\n\n$dim\n[1] 2 2 3\n\n$dimnames\n$dimnames[[1]]\n[1] \"r1\" \"r2\"\n\n$dimnames[[2]]\n[1] \"cl\" \"c2\"\n\n$dimnames[[3]]\n[1] \"pl\" \"p2\" \"p3\"\n\n\nAlternatively, use the array() function.\n\nx &lt;- array(1:12, c(2,2,3))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects2.html",
    "href": "objects2.html",
    "title": "3  Objects - Lists and Data Frames",
    "section": "",
    "text": "3.1 Lists\nLists in R are essential because they can hold different types of data—such as vectors, matrices, data frames, or even other lists—making them ideal for creating your own functions. This flexibility is a game-changer in statistical work, where many R functions return results as lists, and mastering list manipulation is key to exploring those outputs. In this section, you’ll learn how to build and work with lists, a crucial skill for data analysis in R.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objects - Lists and Data Frames</span>"
    ]
  },
  {
    "objectID": "objects2.html#lists",
    "href": "objects2.html#lists",
    "title": "3  Objects - Lists and Data Frames",
    "section": "",
    "text": "3.1.1 Basic List Creation\nTo create a list, the list() function is utilized. The following example generates a list with three components: the first is a character vector, the second is a matrix, and the last one is a numeric vector.\n\na &lt;- list(c(\"a\", \"d\"), \n          matrix(1:4, nrow=2), \n          rep(c(1,2), 2))\na\n\n[[1]]\n[1] \"a\" \"d\"\n\n[[2]]\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n[[3]]\n[1] 1 2 1 2\n\n\nBecause a list is linear, similar to a vector, you can assign the names attribute to a list using the names() function. For example:\n\nnames(a) &lt;- c(\"one\", \"two\", \"three\")\na\n\n$one\n[1] \"a\" \"d\"\n\n$two\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n$three\n[1] 1 2 1 2\n\n\nAlternatively, you can create a list and simultaneously assign the names attribute using the name = value syntax.\n\na &lt;- list(one = c(\"a\", \"d\"), \n          two = matrix(1:4, nrow=2), \n          three = rep(c(1,2), 2))\nattributes(a)\n\n$names\n[1] \"one\"   \"two\"   \"three\"\n\n\nThe names() function not only assigns names but can also retrieve names from a list. Additionally, as a list is linear, the length() function can be employed to count the number of elements in a list.\n\nnames(a)\n\n[1] \"one\"   \"two\"   \"three\"\n\nlength(a)\n\n[1] 3\n\n\n\n\n3.1.2 Empty List\nYou can also create an empty list using list() with no arguments, which is useful for initializing a list to be populated later. It is also used with a loop since you can concatenate to an empty list at every iteration, building a collection of results.\n\nempty_list &lt;- list()\nempty_list\n\nlist()\n\n\nCheck its properties: length(empty_list) returns 0, and is.list(empty_list) confirms it’s a list.\n\nlength(empty_list)\n\n[1] 0\n\nis.list(empty_list)\n\n[1] TRUE\n\n\nYou can add elements to an empty list, for example:\n\nempty_list[[1]] &lt;- c(1, 2)\nempty_list\n\n[[1]]\n[1] 1 2\n\n\n\n\n3.1.3 Nested and Concatenated Lists\nLists are sometimes referred to as recursive vectors because they can contain other lists. In the following example,b contains two components: the first one is the list we just created, named a, and the second component is a factor.\n\nb &lt;- list(a, factor(\"a\"))\nb\n\n[[1]]\n[[1]]$one\n[1] \"a\" \"d\"\n\n[[1]]$two\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n[[1]]$three\n[1] 1 2 1 2\n\n\n[[2]]\n[1] a\nLevels: a\n\nlength(b)\n\n[1] 2\n\n\nWe often use the str() function to display a list with a large number of components or a list containing other lists. The str() function presents an object in a compact form and clearly shows its hierarchy.\n\nstr(b)\n\nList of 2\n $ :List of 3\n  ..$ one  : chr [1:2] \"a\" \"d\"\n  ..$ two  : int [1:2, 1:2] 1 2 3 4\n  ..$ three: num [1:4] 1 2 1 2\n $ : Factor w/ 1 level \"a\": 1\n\n\nSimilar to concatenating vectors, you can use the c() function to concatenate lists.\n\nc &lt;- c(A = a, B = b)\nstr(c)\n\nList of 5\n $ A.one  : chr [1:2] \"a\" \"d\"\n $ A.two  : int [1:2, 1:2] 1 2 3 4\n $ A.three: num [1:4] 1 2 1 2\n $ B1     :List of 3\n  ..$ one  : chr [1:2] \"a\" \"d\"\n  ..$ two  : int [1:2, 1:2] 1 2 3 4\n  ..$ three: num [1:4] 1 2 1 2\n $ B2     : Factor w/ 1 level \"a\": 1\n\n\n\n\n3.1.4 Accessing Components in a List\nIn R, both [ and [[ are used to access components from a list, but they behave differently.\nThe [ operator is used to extract sublists or elements from a list. It returns a sublist (another list). When using [, the result is always a list. Similar to accessing elements of a vector, you can specify the index position within square brackets. In the first example below, it accesses the first component, while in the second example, it returns the first, third, and fourth components.\n\nd &lt;- list(1, matrix(1:4, nrow=2), c(\"a\", \"d\"), list(\"John\"))\nd[2]\n\n[[1]]\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ntypeof(d[2])\n\n[1] \"list\"\n\nd[c(1,3,4)]\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\" \"d\"\n\n[[3]]\n[[3]][[1]]\n[1] \"John\"\n\ntypeof(d[c(1,3,4)])\n\n[1] \"list\"\n\n\nThe [[ double square bracket operator is used for extracting a single element from a list. It directly accesses the contents of the specified element rather than returning a sublist. When using [[, the result is the actual element, not a list containing that element.\nIn the example below, d[[2]] returns the second component, which is a matrix. In the expression d[[3]][1], [[3]] returns the third element, a character vector, and then [1] extracts the first element of the returned character vector.\n\nd[[2]]\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ntypeof(d[[2]])\n\n[1] \"integer\"\n\nclass(d[[2]])\n\n[1] \"matrix\" \"array\" \n\nd[[3]][1]\n\n[1] \"a\"\n\n\nWe cannot access more than one component from a list using double brackets. For example, [[3:4]] is not allowed.\nWhen a list is assigned names, we can access its elements by providing the component names.\n\nnames(d) &lt;- c(\"a\", \"b\", \"c\", \"d\")\nd[\"b\"]\n\n$b\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nd[c(\"a\", \"c\", \"d\")]\n\n$a\n[1] 1\n\n$c\n[1] \"a\" \"d\"\n\n$d\n$d[[1]]\n[1] \"John\"\n\n\nFor a list with names, we can also use the dollar sign ($) operator to return a single element. This behavior is similar to using the double [[. That means, $ only returns the actual element, not a list containing that element.\n\nd[[\"b\"]]\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nd$b\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\n\n\n3.1.5 Manipulating Lists\nMost statistical functions in R, such as those for regression or summary statistics, return results as lists, making list manipulation a common and essential task for data analysis. Lists can be manipulated using various functions, especially when working with statistical models. Many methods are designed to interact with list objects, such as summarizing models, making predictions, and extracting coefficients.\nTo demonstrate these methods, we’ll use the cars dataset, a built-in R dataset containing 50 observations of speed and stopping distance for cars.\n\nhead(cars)\n\n  speed dist\n1     4    2\n2     4   10\n3     7    4\n4     7   22\n5     8   16\n6     9   10\n\ndim(cars)\n\n[1] 50  2\n\n\nWe can fit a linear model to this data using the lm() function, which stands for “linear model.” The lm() function requires a formula to specify the relationship between variables. Below are examples of formula formats in R and their corresponding mathematical equations:\n\ny ~ x: \\(y = \\alpha + \\beta x\\)\nlog(y) ~ x1+x2: \\(\\log(y) = \\beta_{0} + \\beta_{1} x_{1}+ \\beta_{1} x_{2}\\)\ny ~ x1*x2: \\(y = \\beta_{0} + \\beta_{1} x_{1}+ \\beta_{1} x_{2} + \\beta_{3}x_{1}x_{2}\\)\n\n\ntypeof(y ~ x)\n\n[1] \"language\"\n\nclass(y ~ x)\n\n[1] \"formula\"\n\n\nLet’s create a model to predict stopping distance based on speed:\n\nm &lt;- lm(dist ~ speed, data = cars)\nm\n\n\nCall:\nlm(formula = dist ~ speed, data = cars)\n\nCoefficients:\n(Intercept)        speed  \n    -17.579        3.932  \n\ntypeof(m)\n\n[1] \"list\"\n\nclass(m)\n\n[1] \"lm\"\n\n\nThe object m returned by lm() belongs to the lm class, which may be new to us but is essentially a list under the hood. This allows us to manipulate it using list operations, such as accessing its components with $ or [[,\n\nstr(m)\n\nList of 12\n $ coefficients : Named num [1:2] -17.58 3.93\n  ..- attr(*, \"names\")= chr [1:2] \"(Intercept)\" \"speed\"\n $ residuals    : Named num [1:50] 3.85 11.85 -5.95 12.05 2.12 ...\n  ..- attr(*, \"names\")= chr [1:50] \"1\" \"2\" \"3\" \"4\" ...\n $ effects      : Named num [1:50] -303.914 145.552 -8.115 9.885 0.194 ...\n  ..- attr(*, \"names\")= chr [1:50] \"(Intercept)\" \"speed\" \"\" \"\" ...\n $ rank         : int 2\n $ fitted.values: Named num [1:50] -1.85 -1.85 9.95 9.95 13.88 ...\n  ..- attr(*, \"names\")= chr [1:50] \"1\" \"2\" \"3\" \"4\" ...\n $ assign       : int [1:2] 0 1\n $ qr           :List of 5\n  ..$ qr   : num [1:50, 1:2] -7.071 0.141 0.141 0.141 0.141 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. ..$ : chr [1:50] \"1\" \"2\" \"3\" \"4\" ...\n  .. .. ..$ : chr [1:2] \"(Intercept)\" \"speed\"\n  .. ..- attr(*, \"assign\")= int [1:2] 0 1\n  ..$ qraux: num [1:2] 1.14 1.27\n  ..$ pivot: int [1:2] 1 2\n  ..$ tol  : num 1e-07\n  ..$ rank : int 2\n  ..- attr(*, \"class\")= chr \"qr\"\n $ df.residual  : int 48\n $ xlevels      : Named list()\n $ call         : language lm(formula = dist ~ speed, data = cars)\n $ terms        :Classes 'terms', 'formula'  language dist ~ speed\n  .. ..- attr(*, \"variables\")= language list(dist, speed)\n  .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n  .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. .. ..$ : chr [1:2] \"dist\" \"speed\"\n  .. .. .. ..$ : chr \"speed\"\n  .. ..- attr(*, \"term.labels\")= chr \"speed\"\n  .. ..- attr(*, \"order\")= int 1\n  .. ..- attr(*, \"intercept\")= int 1\n  .. ..- attr(*, \"response\")= int 1\n  .. ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt; \n  .. ..- attr(*, \"predvars\")= language list(dist, speed)\n  .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n  .. .. ..- attr(*, \"names\")= chr [1:2] \"dist\" \"speed\"\n $ model        :'data.frame':  50 obs. of  2 variables:\n  ..$ dist : num [1:50] 2 10 4 22 16 10 18 26 34 17 ...\n  ..$ speed: num [1:50] 4 4 7 7 8 9 10 10 10 11 ...\n  ..- attr(*, \"terms\")=Classes 'terms', 'formula'  language dist ~ speed\n  .. .. ..- attr(*, \"variables\")= language list(dist, speed)\n  .. .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n  .. .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. .. .. ..$ : chr [1:2] \"dist\" \"speed\"\n  .. .. .. .. ..$ : chr \"speed\"\n  .. .. ..- attr(*, \"term.labels\")= chr \"speed\"\n  .. .. ..- attr(*, \"order\")= int 1\n  .. .. ..- attr(*, \"intercept\")= int 1\n  .. .. ..- attr(*, \"response\")= int 1\n  .. .. ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt; \n  .. .. ..- attr(*, \"predvars\")= language list(dist, speed)\n  .. .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n  .. .. .. ..- attr(*, \"names\")= chr [1:2] \"dist\" \"speed\"\n - attr(*, \"class\")= chr \"lm\"\n\nnames(m)\n\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n\nm[[1]]\n\n(Intercept)       speed \n -17.579095    3.932409 \n\nm$coefficients\n\n(Intercept)       speed \n -17.579095    3.932409 \n\n\nThere are many methods or functions that can be used to work with the results of an lm object, such as summary(). The summary() function is a generic tool that provides a detailed summary of an object, adapting its output based on the object’s class. For a statistical model like m, it returns coefficients, residuals, and goodness-of-fit measures. For a numeric vector, it provides a statistical summary. Let’s first see it with a vector example:\n\nsummary(c(1, 4, 6, 10, NA, 100))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n    1.0     4.0     6.0    24.2    10.0   100.0       1 \n\n\nNow, apply summary() to the model m to get a detailed statistical summary:\n\nm_summary &lt;- summary(m)\nm_summary\n\n\nCall:\nlm(formula = dist ~ speed, data = cars)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-29.069  -9.525  -2.272   9.215  43.201 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -17.5791     6.7584  -2.601   0.0123 *  \nspeed         3.9324     0.4155   9.464 1.49e-12 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 15.38 on 48 degrees of freedom\nMultiple R-squared:  0.6511,    Adjusted R-squared:  0.6438 \nF-statistic: 89.57 on 1 and 48 DF,  p-value: 1.49e-12\n\n\nCheck the class and type of m_summary, and list its components:\n\nclass(m_summary)\n\n[1] \"summary.lm\"\n\ntypeof(m_summary)\n\n[1] \"list\"\n\nnames(m_summary)\n\n [1] \"call\"          \"terms\"         \"residuals\"     \"coefficients\" \n [5] \"aliased\"       \"sigma\"         \"df\"            \"r.squared\"    \n [9] \"adj.r.squared\" \"fstatistic\"    \"cov.unscaled\" \n\n\nAccess specific elements, such as the coefficients table:\n\nm_summary$coefficients\n\n              Estimate Std. Error   t value     Pr(&gt;|t|)\n(Intercept) -17.579095  6.7584402 -2.601058 1.231882e-02\nspeed         3.932409  0.4155128  9.463990 1.489836e-12\n\n\nThese methods allow you to summarize data, extract key statistics, or prepare for further analysis.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objects - Lists and Data Frames</span>"
    ]
  },
  {
    "objectID": "objects2.html#data-frames",
    "href": "objects2.html#data-frames",
    "title": "3  Objects - Lists and Data Frames",
    "section": "3.2 Data Frames",
    "text": "3.2 Data Frames\nA data frame is a special case of a list. This means that functions used for lists and methods to access elements from a list can be applied to a data frame. The term ‘special case of a list’ is used for a data frame because each element in a data frame needs to be a vector with the same length, allowing them to be arranged into a structure resembling a matrix. Data frames are commonly imported by reading a file, from a spreadsheet, or from a database.\n\n3.2.1 Creating a Data Frame\nA data frame can be created from vectors of the same length using the data.frame() function.\n\nsex &lt;- c(\"M\", \"F\", \"F\", \"M\", \"M\")\nheight &lt;- c(65, 63, 60, 62, 57)\nweight &lt;- c(150, 140, 135, 165, 175)\nliveOnCampus &lt;- c(TRUE, TRUE, FALSE, FALSE, FALSE)\nd &lt;- data.frame(sex, height, weight, liveOnCampus)\nd\n\n  sex height weight liveOnCampus\n1   M     65    150         TRUE\n2   F     63    140         TRUE\n3   F     60    135        FALSE\n4   M     62    165        FALSE\n5   M     57    175        FALSE\n\n\nA data frame can be created by combining various object types, such as matrices and vectors. The following example demonstrates how to construct a data frame from a matrix and a vector. Suppose we have a numeric matrix with 5 rows and 2 columns, representing height (in inches) and weight (in pounds) for five individuals. Begin by creating a character vector with a length of 5 to assign groups to each row. Then, convert the matrix into a data frame and add vector v using the data.frame() function:\n\nv &lt;- c(\"A\", \"A\", \"B\", \"B\", \"C\")\nhw_matrix &lt;- matrix(c(rnorm(5, mean = 62, sd = 3), \n                      rnorm(5, mean = 150, sd = 15)), ncol = 2)\ncolnames(hw_matrix) &lt;- c(\"height\", \"weight\")\nhw_matrix\n\n       height   weight\n[1,] 66.66340 169.1774\n[2,] 60.84223 162.7399\n[3,] 63.56746 165.4398\n[4,] 56.39137 139.7122\n[5,] 57.57282 146.1678\n\ndata.frame(group = v, hw_matrix)\n\n  group   height   weight\n1     A 66.66340 169.1774\n2     A 60.84223 162.7399\n3     B 63.56746 165.4398\n4     B 56.39137 139.7122\n5     C 57.57282 146.1678\n\n\nThis example illustrates how the group variable, with values tailored to match the number of rows, is assigned to each row of the resulting data frame.\nIn the example above, the length of the group vector matches the number of rows in the matrix. Another common scenario involves an added variable with a length of one, as shown below:\n\ndata.frame(group = \"A\", hw_matrix)\n\n  group   height   weight\n1     A 66.66340 169.1774\n2     A 60.84223 162.7399\n3     A 63.56746 165.4398\n4     A 56.39137 139.7122\n5     A 57.57282 146.1678\n\n\nThe reason these examples work is that the data.frame() function implicitly coerces the matrix into a data frame. Alternatively, you can explicitly coerce an object to a data frame using the as.data.frame() function:\n\nA vector will become a one-column data frame.\nA matrix will become a data frame with the same dimensions.\nA list will become a data frame if its components have the same length.\n\n\nas.data.frame(1:4)\n\n  1:4\n1   1\n2   2\n3   3\n4   4\n\nas.data.frame(matrix(1:4, 2))\n\n  V1 V2\n1  1  3\n2  2  4\n\nas.data.frame(list(V1=c(1,2), V2=c(3,4)))\n\n  V1 V2\n1  1  3\n2  2  4\n\n\nYou can also create an empty data frame using data.frame() with no arguments, which is useful when incorporating it into a loop structure to build a data frame iteratively, similar to creating an empty list.\n\nempty_df &lt;- data.frame()\nempty_df\n\ndata frame with 0 columns and 0 rows\n\nnrow(empty_df)\n\n[1] 0\n\nncol(empty_df)\n\n[1] 0\n\n\n\n\n3.2.2 Data Frame Attributes\nBy using the following function to examine the attributes of data frame d, it reveals that a data frame is indeed a list.\n\ntypeof(d)\n\n[1] \"list\"\n\nclass(d)\n\n[1] \"data.frame\"\n\nattributes(d)\n\n$names\n[1] \"sex\"          \"height\"       \"weight\"       \"liveOnCampus\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3 4 5\n\n\nUnlike a list object, a data frame has a row.names attribute, as it resembles a matrix. It’s often noted that a data frame shares common properties with both a list and a matrix. Consequently, functions applicable to lists or matrices can also be used for data frames.\n\ncolnames(d) ## Treating d like a matrix\n\n[1] \"sex\"          \"height\"       \"weight\"       \"liveOnCampus\"\n\nnames(d) ## Treating d like a list\n\n[1] \"sex\"          \"height\"       \"weight\"       \"liveOnCampus\"\n\nrownames(d) ##  Treating d like a matrix\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\n\nRather than using the default row names generated by R, you have the option to assign new row names to a data frame. In the following example, ID is assigned as the row name of the data frame d. It’s important to note that even if ID is created as a numeric vector, once it is assigned as row names of a data frame, the values for the row names are converted as characters.\n\nid &lt;- c(2345, 1236, 2986, 6543, 6544)\nrownames(d) &lt;- id\nd\n\n     sex height weight liveOnCampus\n2345   M     65    150         TRUE\n1236   F     63    140         TRUE\n2986   F     60    135        FALSE\n6543   M     62    165        FALSE\n6544   M     57    175        FALSE\n\nrownames(d)\n\n[1] \"2345\" \"1236\" \"2986\" \"6543\" \"6544\"\n\n\nThe length of a data frame is equal to the number of columns, which is also the length of the underlying list. Given that a data frame shares properties with a matrix, you can use the functions ncol() and nrow() to retrieve the number of columns and rows, respectively.\n\nlength(d) ## Treating d like a list\n\n[1] 4\n\nncol(d) ##  Treating d like a matrix\n\n[1] 4\n\nnrow(d) ##  Treating d like a matrix\n\n[1] 5\n\n\n\n\n3.2.3 Accessing Components in a Data Frame\nSince a data frame resembles a matrix, one can access its elements in a manner similar to accessing a matrix by providing two indices within a pair of square brackets. The first index is used to select rows, and the second one is used to select columns. The following example accesses d by selecting the first three rows and the first, third, and fourth columns.\n\nd[1:3, c(1,3,4)]\n\n     sex weight liveOnCampus\n2345   M    150         TRUE\n1236   F    140         TRUE\n2986   F    135        FALSE\n\n\nYou can also access its elements by specifying row names and column names.\n\nd[c(\"6543\", \"6544\"), c(\"height\", \"weight\")]\n\n     height weight\n6543     62    165\n6544     57    175\n\n\nTo access a variable, you can use either the $ operator or [[, similar to what we do for a list object.\n\nd$height\n\n[1] 65 63 60 62 57\n\nd[[\"height\"]]\n\n[1] 65 63 60 62 57\n\nd[[2]]\n\n[1] 65 63 60 62 57\n\n\n\n\n3.2.4 Combining Data Frames\nData frames can be combined either column-wise or row-wise. Combining data column-wise is often used to add additional variables, such as appending measurement results or metadata to an existing dataset, enhancing its analytical depth. Alternatively, combining data row-wise is frequently employed when data were collected from different locations or time periods, allowing for the integration of observations into a comprehensive dataset for broader analysis.\nTo combine data frames column-wise, use the cbind() function, and it requires that the number of rows must be the same; however, row names do not need to be the same. R will use the row names of the first data frame in the cbind() function.\n\nd2 &lt;- data.frame(midterm = c(80, NA, 90, 40, 95),\n                 final = c(88, 100, 94, 88, 99))\nrownames(d2) &lt;- c(\"John\", \"Helen\", \"Mary\", \"Joe\", \"Art\")\nd2\n\n      midterm final\nJohn       80    88\nHelen      NA   100\nMary       90    94\nJoe        40    88\nArt        95    99\n\ncbind(d, d2)\n\n     sex height weight liveOnCampus midterm final\n2345   M     65    150         TRUE      80    88\n1236   F     63    140         TRUE      NA   100\n2986   F     60    135        FALSE      90    94\n6543   M     62    165        FALSE      40    88\n6544   M     57    175        FALSE      95    99\n\ncbind(d2, d)\n\n      midterm final sex height weight liveOnCampus\nJohn       80    88   M     65    150         TRUE\nHelen      NA   100   F     63    140         TRUE\nMary       90    94   F     60    135        FALSE\nJoe        40    88   M     62    165        FALSE\nArt        95    99   M     57    175        FALSE\n\n\nTo combine data frames row-wise, use the rbind() function, which requires the number of columns to be the same, and the names of the columns must match.\n\nd3 &lt;- data.frame(sex = c(\"M\", \"F\"), \n                 height = c(63, 60), \n                 weight = c(160, 146),\n                 liveOnCampus = c(FALSE, FALSE))\nrbind(d, d3)\n\n     sex height weight liveOnCampus\n2345   M     65    150         TRUE\n1236   F     63    140         TRUE\n2986   F     60    135        FALSE\n6543   M     62    165        FALSE\n6544   M     57    175        FALSE\n1      M     63    160        FALSE\n2      F     60    146        FALSE\n\n\n\n\n3.2.5 Adding Variables to a Data Frame\nAdding a variable is a common task in data analysis, driven by several practical reasons. Often, the existing variables may not fully capture the desired information, necessitating the inclusion of new ones to address specific research questions. Additionally, we frequently add variables based on summary statistics from existing variables, such as means or medians, to provide aggregated insights. Another reason is combining existing variables through operations like ratios or differences to derive new metrics. Furthermore, adding variables can facilitate data enrichment by incorporating external data sources or calculated indices relevant to the study.\nOne way to add new variables is to use the data.frame() function and include the existing data frame, plus the newly added variables. The following example demonstrates how to add the mean values of the height and weight variables to the data frame d.\n\nd4 &lt;-  data.frame(\n  d,  ## existing data frame\n  height_mean = mean(d$height),\n  weight_mean = mean(d$weight)\n)\nd4\n\n     sex height weight liveOnCampus height_mean weight_mean\n2345   M     65    150         TRUE        61.4         153\n1236   F     63    140         TRUE        61.4         153\n2986   F     60    135        FALSE        61.4         153\n6543   M     62    165        FALSE        61.4         153\n6544   M     57    175        FALSE        61.4         153\n\n\nYou can also use the dollar sign operator ($), [, or [[ to add new variables to an existing data frame.\n\nd$height_mean = mean(d$height)\nd['weight_mean'] = mean(d$weight)\nd[['weight_2']] = d[['weight']]^2\nd\n\n     sex height weight liveOnCampus height_mean weight_mean weight_2\n2345   M     65    150         TRUE        61.4         153    22500\n1236   F     63    140         TRUE        61.4         153    19600\n2986   F     60    135        FALSE        61.4         153    18225\n6543   M     62    165        FALSE        61.4         153    27225\n6544   M     57    175        FALSE        61.4         153    30625\n\n\n\n\n3.2.6 Reading Data Frames\nTypically, a data frame is generated by importing data from an external text file. The read.table() function plays a key role in reading such text files, where each field is separated by one or more separators. The output of the read.table() function is a data frame. With numerous arguments, the read.table() function offers flexibility in handling files with various formats, many of which come with default values.\nWhen utilizing the read.table() function to read external files, it’s crucial to consider the following format specifications of the input file:\n\nSeparators: The default separators include spaces, tabs, newlines, or carriage returns. To specify an alternative separator, use the sep= argument.\nHeader: If the first row of the external file contains variable names, specify header = TRUE. By default, this argument is set to FALSE, and read.table() will use V followed by the column number as the variable names.\nRow Names: If the header line is one column shorter than the body of the file, the first column is taken as row names. In this case, the header= option is automatically set to TRUE.\nMissing Values: read.table() recognizes NA as a missing value for any data type and treats NaN, Inf, and -Inf as missing for numeric data. Modify the default option using the na.strings= argument. For instance, if a period is considered a missing value, use na.strings = \".\". If missing values are represented by a non-NA value, such as blanks, it is safe to use the sep= option.\nComments: By default, read.table() treats any text after the # sign as comments. Change this default using the comment.char= argument. For example, comment.char =\"%\" means that any text after % is considered a comment and will not be read.\nSkip Lines: Skip a specified number of lines from the input file using the skip= option. For example, skip = 2 means skipping the first two lines.\nNumber of Rows: Regulate the maximum number of lines to read with the nrow= option. If, for instance, you set nrow = 5, the function will read the first 5 rows.”\n\nSuppose we need to read and examine example1.txt. Initially, let’s take a closer look at the data.\n\nEach field in the dataset is separated by a tab.\nThe first two lines contain comments marked with #.\nThe row following the comments contains variable names.\nNumerical missing values are represented as ..\n\nThe subsequent R code illustrates how to read in this file:\n\nexample1 = read.table(file=\"example1.txt\", header= T, na.strings = \".\")\nhead(example1)\n\n     Fname    Lname race age preg income\n1    KAREN    ARIAS    H  26    0  35000\n2 Caroline   Embrey    W  26    1  48000\n3      GEN ERECKSON    W  32    1  30000\n4     JOAN   RIVERA    W  17    0  59000\n5   ANDREA    Jones    B  29    1 120000\n6  BEVERLY    ROELL    W  26    1 113000\n\n\nThe example shown assumes that your data is located in your working directory. If it is not, you need to either change your working directory using setwd() or specify the entire file path (e.g., file = \"C:/path/to/example1.txt\").\nIn the read.table() function above:\n\nThe header= argument is set to TRUE since the variable names are in the input file.\nThe comment.char= argument is not used as # is the default value for indicating comments.\nna.strings= is set to . which represents the missing value for numerical values.\nSince each field is separated by tabs, the sep= option is not used. If you prefer to specify this option explicitly, you can write sep=\"\\t\".\n\nThere are other analogous functions for reading raw data, essentially serving as wrapper functions for read.table(). For instance:\n\nThe read.csv() function reads ‘comma-separated value’ files. It automatically sets header = TRUE and sep = \",\" for the read.table() function.\nThe read.delim() function reads delimited files, with the TAB character as the default delimiter and header = TRUE.\n\nBase R does not include functions for reading Excel files. You can leverage one of the following packages to read an Excel file:\n\nThe readxl package: data &lt;- read_excel(\"data.xlsx\")\nThe openxlsx package (reading and writing Excel files): data &lt;- read.xlsx(\"data.xlsx\")\nThe writexl package (primarily for writing): data &lt;- read_xlsx(\"data.xlsx\")\n\nThe haven package offers numerous useful functions for reading external files in various formats.\n\nRead SAS files (.sas7bdat) : read_sas()\nRead SPSS files(.sav): read_sav()\nRead STATA files (.dta): read_dta()\n\n\n\n3.2.7 Writing Data Frames\nOne common approach to save a data frame to a text file is by using the write.table() function. The key arguments frequently used with the write.table() function are as follows:\n\nfile=: The name of the output file.\nquote=: Either TRUE or FALSE, or a numeric vector.\n\nIf TRUE (default), character or factor columns will be enclosed in double quotes.\nIf FALSE, all quotes will be omitted.\nIf a numeric vector, its elements will be the indices of columns to be quoted.\n\nsep=: Used to specify the column separator. For instance, to separate columns by tabs, use sep = \"\\t\".\nna=: Default value is NA, which serves as a missing value in the output file.\nrow.names=: A logical value. By default (TRUE), the row names of the data frame will be included in the output dataset.\ncol.names=: A logical value. By default (TRUE), the column names of the data frame will be included in the output dataset.\n\nThe following example demonstrates writing the data frame, dat1, to an output file named dat1.txt.\n\ndat1 &lt;- data.frame(\n  numVar = c(round(rnorm(5), 2), NA),\n  charVar = c(NA, letters[1:5])\n  )\ndat1\n\n  numVar charVar\n1   1.31    &lt;NA&gt;\n2   1.53       a\n3   1.25       b\n4  -0.66       c\n5  -1.00       d\n6     NA       e\n\n\n\nwrite.table(dat1, file=\"dat1.txt\")\n\nWithout specifying arguments to control the arrangement of data in the external file, the provided R code might not create the file in the desired format using the default settings. For instance, by default, row names from 1 to 6 are included in the output file. All character values, including row and column names, are enclosed in quotation marks. Each column is separated by a single space. Lastly, missing values are represented as NA.\nHere’s an example to exert better control over the data arrangement in the external file. In the following R code, row names are omitted, and quotation marks for character values are suppressed. Each column is separated by tabs, and a blank value is used to represent missing values.\n\nwrite.table(dat1, file=\"dat1.txt\", row.names = F, \n            quote = F, sep = \"\\t\", na = \" \")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objects - Lists and Data Frames</span>"
    ]
  },
  {
    "objectID": "Subsetting.html",
    "href": "Subsetting.html",
    "title": "4  Subsetting Objects",
    "section": "",
    "text": "4.1 Index Vectors\nWhen subsetting an object in R, we use an index vector to specify which elements we want to extract. This index vector is placed inside square brackets after the object name. R supports five types of index vectors, and each type offers a different way to reference elements. It’s important to remember that these types should not be mixed within a single subsetting operation. In this section, we will introduce each of the five types and demonstrate how they can be used to subset a simple vector.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#index-vectors",
    "href": "Subsetting.html#index-vectors",
    "title": "4  Subsetting Objects",
    "section": "",
    "text": "4.1.1 Type 1: A Logical Index\nOne way to subset a vector in R is by using a logical index. A logical index is a vector made up of TRUE, FALSE, and NA values. When applied to a target vector, only the elements that correspond to TRUE in the logical index will be selected. Elements paired with FALSE are excluded, and those paired with NA will return NA in the output.\nIn the following example, we create a vector a that contains a missing value. To select only the non-missing elements, we use !is.na(a) as the logical index.\n\na &lt;- c(1, 3, 5, NA, 7)\nis.na(a)\n\n[1] FALSE FALSE FALSE  TRUE FALSE\n\n!is.na(a)\n\n[1]  TRUE  TRUE  TRUE FALSE  TRUE\n\na[!is.na(a)]\n\n[1] 1 3 5 7\n\n\nWe can also use logical conditions directly. For example, the expression a &gt; 3 creates a logical vector indicating which elements in a are greater than 3. However, be aware that if the vector contains missing values, the condition will return NA for those entries.\n\na &gt; 3\n\n[1] FALSE FALSE  TRUE    NA  TRUE\n\na[a &gt; 3]\n\n[1]  5 NA  7\n\n\nThis kind of indexing is particularly useful when filtering data based on conditions or when working with missing values.\n\n\n4.1.2 Type 2: A Positive Integer Index\nAnother common method for subsetting a vector is to use a positive integer index. This index vector specifies the positions of the elements to extract from the target vector. The index vector can be of any length—shorter or longer than the original vector—and the resulting output will include the values at those specified positions, in the order listed.\nIn the example below, we use a positive integer index to extract the first, second, third, and then second element again from vector a.\n\na &lt;- c(1, 3, 5, NA, 7)\na[c(1:3, 2)]\n\n[1] 1 3 5 3\n\n\nA useful tool when working with logical conditions is the which() function. Instead of returning a logical vector, which() returns the integer positions of elements that satisfy a condition, automatically excluding any NA values. This makes it a safer and often preferred option over direct logical indexing when the presence of missing values is a concern.\nCompare the results of the two approaches below:\n\na[a &gt; 3]\n\n[1]  5 NA  7\n\nwhich(a &gt; 3)\n\n[1] 3 5\n\na[which(a &gt; 3)]\n\n[1] 5 7\n\n\nThe first line returns a result with an NA due to the missing value in a, while the second line avoids this issue by subsetting only on valid positions.\nIt’s also worth noting that any 0 values in a positive integer index vector are ignored and do not return corresponding elements.\n\na[c(0, 2)]\n\n[1] 3\n\n\n\n\n4.1.3 Type 3: A Negative Integer Index\nIn addition to selecting specific elements, you can also exclude elements from a vector using a negative integer index. By placing a minus sign in front of the index values, R will omit those positions from the result.\nFor example, the following code removes the first and fourth elements from vector a:\n\na &lt;- c(1, 3, 5, NA, 7)\na[-c(1,4)]\n\n[1] 3 5 7\n\n\nThis approach is especially helpful when you want to drop a small number of elements from a larger vector without having to specify everything you want to keep.\nOne important rule to remember: you cannot mix positive and negative indices in the same index vector. Doing so will result in an error.\n\n\n4.1.4 Type 4: A Character Index\nIf a vector has a names attribute, you can subset it using a character index vector by specifying the element names. This method allows for intuitive selection when working with named elements.\nFor example, the following code attempts to select elements \"a\" and \"c\" from vector a. Initially, this returns NA values because a has no assigned names:\n\na &lt;- c(1, 3, 5, NA, 7)\na[c(\"a\",\"c\")]\n\n[1] NA NA\n\n\nTo make this operation meaningful, you must first assign names to the elements of a. After doing so, the same character index will correctly return the corresponding values:\n\nnames(a) &lt;- letters[1:5] ## Assign names with a - e\na[c(\"a\",\"c\")]\n\na c \n1 5 \n\n\nNote that the length of the character index vector can be shorter or longer than the target vector. If any name in the index is not found in the object, R will return NA for that position.\n\n\n4.1.5 Type 5: An Empty Index\nAn empty index can be used to select all elements from a vector. When you leave the square brackets empty, R returns the entire object without any subsetting:\n\na[]\n\n a  b  c  d  e \n 1  3  5 NA  7 \n\n\nWhile this may not seem especially helpful when working with vectors, it becomes much more useful for more complex structures like matrices, arrays, or data frames—particularly when you want to extract all rows or columns without specifying them explicitly.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#index-vector-replacement",
    "href": "Subsetting.html#index-vector-replacement",
    "title": "4  Subsetting Objects",
    "section": "4.2 Index Vector: Replacement",
    "text": "4.2 Index Vector: Replacement\nIn R, “replacement” refers to modifying existing values or attributes within an object. Many R functions support this operation. For instance, the names() function can both retrieve and assign names to an object. If you consult its help file, you will find the following syntax:\nnames(x)\nnames(x) &lt;- value\nThe second form illustrates the concept of replacement.\nJust like subsetting, all five types of index vectors can also be used for replacement. In the following example, we use a logical index vector to identify missing values in vector x, and then replace those values with 0:\n\nx &lt;- c(3, 6, NA, -1)\nx[is.na(x)] &lt;- 0\nx\n\n[1]  3  6  0 -1\n\n\nThe next example uses a positive integer index vector to replace the second and fourth elements with 10 and 20, respectively:\n\nx[c(2,4)] &lt;- c(10, 20)\nx\n\n[1]  3 10  0 20\n\n\nTo replace all elements in x except for the first and second, we use a negative integer index vector. All remaining elements are replaced with the value 4:\n\nx[-c(1,2)] &lt;- 4\nx\n\n[1]  3 10  4  4\n\n\nOnce names are assigned to a vector, we can also use a character index vector for replacement. Here, we replace the elements named \"a\" and \"c\" with 0:\n\nnames(x) &lt;- letters[1:4]\nx\n\n a  b  c  d \n 3 10  4  4 \n\nx[c(\"a\", \"c\")] &lt;- 0\nx\n\n a  b  c  d \n 0 10  0  4 \n\n\nFinally, an empty index can appear on the left-hand side of an assignment. This replaces all values while preserving the object’s structure and type. In this example, all elements of x are set to 0:\n\nx[] &lt;- 0\nx\n\na b c d \n0 0 0 0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#utilizing-index-vectors-in-various-applications",
    "href": "Subsetting.html#utilizing-index-vectors-in-various-applications",
    "title": "4  Subsetting Objects",
    "section": "4.3 Utilizing Index Vectors in Various Applications",
    "text": "4.3 Utilizing Index Vectors in Various Applications\n\n4.3.1 Recoding Variables\nOne common use of indexing is to recode variables, especially character vectors. In this example, we demonstrate how to use character indexing to recode a character vector named Sex, which contains values \"M\" and \"F\".\n\nSex &lt;-  c(\"M\", \"F\", \"F\", \"M\", \"M\", \"F\")\n\nOur goal is to convert this vector into a more descriptive form, replacing \"M\" with \"Male\" and \"F\" with \"Female\". To achieve this, we first create a named character vector called convert. The values are \"Male\" and \"Female\", with names \"M\" and \"F\":\n\nconvert &lt;- c(M = \"Male\", F = \"Female\")\n\nSince convert is a named vector, we can subset its components by specifying their names, as shown in the example below. Notice that the length of the index vector can vary, and the resulting output has the same length as the index vector.\nSince convert has names assigned, we can subset it by those names. Below are a few examples. Notice that the resulting output matches the length and order of the index vector:\n\nconvert[\"M\"]\n\n     M \n\"Male\" \n\nconvert[c(\"F\", \"M\")]\n\n       F        M \n\"Female\"   \"Male\" \n\nconvert[c(\"F\", \"M\", \"F\", \"F\")]\n\n       F        M        F        F \n\"Female\"   \"Male\" \"Female\" \"Female\" \n\n\nIn the final step, we use the Sex vector itself as the index to the convert vector. This produces the recoded values directly:\n\nSex_recode &lt;-convert[Sex]\nSex_recode\n\n       M        F        F        M        M        F \n  \"Male\" \"Female\" \"Female\"   \"Male\"   \"Male\" \"Female\" \n\n\n\n\n4.3.2 Imputing Missing Numerical Values\nImputation refers to the process of replacing missing or incomplete values in a dataset. This step is important to ensure the dataset is complete and suitable for analysis. A common approach is to substitute missing values with summary statistics, such as the mean, median, or mode. More advanced methods may involve regression or machine learning techniques, but simple imputation strategies are often sufficient for exploratory analysis.\nIn the following example, the numeric vector n contains missing values. To impute these missing values using the median, we first compute the median with the median() function. The na.rm = TRUE option tells R to ignore the NA values when performing the calculation. Then, we use a logical index vector generated by is.na() to locate the missing values and replace them with the computed median.\n\nn &lt;-  c(123, 210, NA, 100, 502, NA, 103, 240)\nm &lt;- median(n, na.rm=T) \nm\n\n[1] 166.5\n\nn[is.na(n)] &lt;- m\nn\n\n[1] 123.0 210.0 166.5 100.0 502.0 166.5 103.0 240.0\n\n\n\n\n4.3.3 Imputing Missing Character Values\nWhen dealing with character vectors, a common strategy for imputing missing values is to replace them with the most frequently occurring value. This approach helps maintain consistency and can be implemented using a few steps.\nLet’s start with a character vector that includes some missing values:\n\nc &lt;- c(\"A\", \"B\", \"A\", NA, \"C\", \"C\", \"A\")\n\nTo determine the most frequent value, we use the table() function, which returns a frequency table of the non-missing values:\n\ntab &lt;- table(c)\ntab\n\nc\nA B C \n3 1 2 \n\n\nThe output of the table() function is a named integer vector with the class \"table\". It can be treated like a regular named vector, where the names represent the unique values in the original data, and the values indicate their frequencies. You can view the names using the names() function:\n\nnames(tab)\n\n[1] \"A\" \"B\" \"C\"\n\n\nTo identify the most frequent value, we first compute the maximum frequency using the max() function:\n\nhf &lt;- max(tab)\n\nNext, we want to find which value in tab corresponds to this maximum frequency. This is done by comparing tab with hf, which gives a logical index vector:\n\nind &lt;- tab == hf \nind\n\nc\n    A     B     C \n TRUE FALSE FALSE \n\n\nWe then use this index to extract the name (i.e., value) associated with the highest frequency:\n\nhf_c &lt;- names(tab)[ind]\nhf_c\n\n[1] \"A\"\n\n\nFinally, we use is.na() to identify missing values in the original vector and replace them with hf_c, the most common value:\n\nc[is.na(c)] = hf_c\nc\n\n[1] \"A\" \"B\" \"A\" \"A\" \"C\" \"C\" \"A\"\n\n\nIf there is a tie for the most frequent value, only the first one in the result will be used, which may depend on the internal ordering in R.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#matrix-indexing",
    "href": "Subsetting.html#matrix-indexing",
    "title": "4  Subsetting Objects",
    "section": "4.4 Matrix Indexing",
    "text": "4.4 Matrix Indexing\nThe five types of index vectors can also be applied to matrices for selecting specific elements. Consider the following example:\n\nm &lt;- matrix(1:12, nrow=3)\nrownames(m) = c(\"i\", \"ii\", \"iii\")\ncolnames(m) = c(\"I\", \"II\", \"III\", \"IV\")\nm\n\n    I II III IV\ni   1  4   7 10\nii  2  5   8 11\niii 3  6   9 12\n\n\nTo extract elements from a matrix, two index vectors are placed inside square brackets, separated by a comma. The first index vector corresponds to the row positions, and the second to the column positions. For instance, the following command selects the element in the second row and fourth column:\n\nm[2,4]\n\n[1] 11\n\n\nLeaving either the row or column position empty selects all values along that dimension. For example:\n\nm[c(1,3),] ## select first and third rows\n\n    I II III IV\ni   1  4   7 10\niii 3  6   9 12\n\nm[,c(1,2)] ## select first and second columns\n\n    I II\ni   1  4\nii  2  5\niii 3  6\n\n\nDifferent types of index vectors can be used at each index position. In the next example, a negative integer index excludes the first row, and a character index selects the columns named \"I\" and \"IV\":\n\nm[-1, c(\"I\", \"IV\")]\n\n    I IV\nii  2 11\niii 3 12\n\n\nIn the following example, a character index is used to select rows with names \"i\" and \"ii\", while a numeric index selects the second through fourth columns:\n\nm[c(\"i\", \"ii\"), 2:4]\n\n   II III IV\ni   4   7 10\nii  5   8 11",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#subsetting-data-frames",
    "href": "Subsetting.html#subsetting-data-frames",
    "title": "4  Subsetting Objects",
    "section": "4.5 Subsetting Data Frames",
    "text": "4.5 Subsetting Data Frames\nA data frame in R shares features with both matrices and lists. Therefore, subsetting a data frame can be done using one or two index vectors, depending on how the data frame is treated.\n\n4.5.1 Subsetting a Data Frame as a Matrix\nWhen a data frame is treated like a matrix, two indices are required: the first index selects rows, and the second selects columns. For example, the following code selects the second and third rows from the data frame d, while retaining all columns:\n\nd &lt;- data.frame(\n  L = c(\"A\", \"B\", \"C\"),\n  M = 1:3,\n  N1 = c(T, F, NA)\n)\nd\n\n  L M    N1\n1 A 1  TRUE\n2 B 2 FALSE\n3 C 3    NA\n\nd[c(2,3), ]\n\n  L M    N1\n2 B 2 FALSE\n3 C 3    NA\n\n\nTo select specific columns, you can use a column index in the second position. The following command selects the first and third columns, including all rows:\n\nd[,c(1,3)]\n\n  L    N1\n1 A  TRUE\n2 B FALSE\n3 C    NA\n\n\nYou can also use a logical index to subset rows. The expression d$L == \"A\" creates a logical vector that identifies which rows have the value \"A\" in column L. This logical index is placed before the comma to select the corresponding rows:\n\nd$L == \"A\"\n\n[1]  TRUE FALSE FALSE\n\nd[d$L == \"A\", ]\n\n  L M   N1\n1 A 1 TRUE\n\n\nCharacter indexing can be used to select columns by name. The following example selects the columns named \"M\" and \"N1\":\n\nd[, c(\"M\", \"N1\")]\n\n  M    N1\n1 1  TRUE\n2 2 FALSE\n3 3    NA\n\n\nYou can combine both row and column indexing. The example below selects rows where column L equals \"A\" and returns only the \"M\" and \"N1\" columns:\n\nd[d$L == \"A\", c(\"M\", \"N1\")]\n\n  M   N1\n1 1 TRUE\n\n\n\n\n4.5.2 Subsetting a Data Frame as a List\nA data frame is also a special type of list, where each column is treated as a separate component. When subsetting a data frame as a list, you can only select columns—rows cannot be selected this way—and only a single index vector is used.\nFor instance, you can use a numeric index vector to select the second and third columns:\n\nd[c(2,3)]\n\n  M    N1\n1 1  TRUE\n2 2 FALSE\n3 3    NA\n\n\nAlternatively, use a character index vector to select columns by name:\n\nd[c(\"M\", \"N1\")]\n\n  M    N1\n1 1  TRUE\n2 2 FALSE\n3 3    NA\n\n\n\n\n4.5.3 Sorting a Data Frame\nTo sort a vector in R, the sort() function can be used. By default, this function sorts values in ascending order. If you want to sort the vector in descending order, set the decreasing= option to TRUE:\n\nx &lt;- c(5, 2, 1)\nsort(x)\n\n[1] 1 2 5\n\nsort(x, decreasing = TRUE)\n\n[1] 5 2 1\n\n\nSorting a data frame involves arranging its rows using an index vector of positive integers. This index vector must match the number of rows in the data frame. Typically, the order() function is used to generate this index.\nThe examples below make use of the painters dataset from the MASS package. This dataset includes subjective evaluations of 54 classical painters across four artistic dimensions: Composition, Drawing, Colour, and Expression. These evaluations were originally compiled by the 18th-century art critic, de Piles.\n\nlibrary(MASS)\ndim(painters)\n\n[1] 54  5\n\nhead(painters)\n\n              Composition Drawing Colour Expression School\nDa Udine               10       8     16          3      A\nDa Vinci               15      16      4         14      A\nDel Piombo              8      13     16          7      A\nDel Sarto              12      16      9          8      A\nFr. Penni               0      15      8          0      A\nGuilio Romano          15      16      4         14      A\n\n\nThe School variable in this dataset indicates the school each painter is associated with. To simplify the examples, we’ll extract a smaller subset of the data, painters_ABC, which includes only those painters whose schools are labeled \"A\", \"B\", or \"C\". The %in% operator is used to compare each entry in the School variable against these three values and create a logical index.\n\nABC_index &lt;- painters$School %in% c(\"A\", \"B\", \"C\")\nABC_index\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE FALSE FALSE FALSE FALSE\n\nsum(ABC_index)\n\n[1] 22\n\npainters_ABC &lt;- painters[ABC_index,]\ndim(painters_ABC)\n\n[1] 22  5\n\n\nThe first example shows how to sort painters_ABC by row names, which correspond to the painters’ names. The order() function returns an index that arranges the row names in ascending order. This index is then used to reorder the rows:\n\nname_Index &lt;- order(row.names(painters_ABC))\nname_Index\n\n [1] 17 18  1  2  3  4 11  5 12  6 19 20  7 13  8  9 14 10 15 21 22 16\n\npainters_ABC[name_Index, ]\n\n                Composition Drawing Colour Expression School\nBarocci                  14      15      6         10      C\nCortona                  16      14     12          6      C\nDa Udine                 10       8     16          3      A\nDa Vinci                 15      16      4         14      A\nDel Piombo                8      13     16          7      A\nDel Sarto                12      16      9          8      A\nF. Zucarro               10      13      8          8      B\nFr. Penni                 0      15      8          0      A\nFr. Salviata             13      15      8          8      B\nGuilio Romano            15      16      4         14      A\nJosepin                  10      10      6          2      C\nL. Jordaens              13      12      9          6      C\nMichelangelo              8      17      4          8      A\nParmigiano               10      15      6          6      B\nPerino del Vaga          15      16      7          6      A\nPerugino                  4      12     10          4      A\nPrimaticcio              15      14      7         10      B\nRaphael                  17      18     12         18      A\nT. Zucarro               13      14     10          9      B\nTesta                    11      15      0          6      C\nVanius                   15      15     12         13      C\nVolterra                 12      15      5          8      B\n\n\nThe next example sorts the data by the School variable in descending order. Here, the order() function is placed directly inside the square brackets, and the decreasing = TRUE argument ensures descending order:\n\npainters_ABC[order(painters_ABC$School, decreasing = T), ]\n\n                Composition Drawing Colour Expression School\nBarocci                  14      15      6         10      C\nCortona                  16      14     12          6      C\nJosepin                  10      10      6          2      C\nL. Jordaens              13      12      9          6      C\nTesta                    11      15      0          6      C\nVanius                   15      15     12         13      C\nF. Zucarro               10      13      8          8      B\nFr. Salviata             13      15      8          8      B\nParmigiano               10      15      6          6      B\nPrimaticcio              15      14      7         10      B\nT. Zucarro               13      14     10          9      B\nVolterra                 12      15      5          8      B\nDa Udine                 10       8     16          3      A\nDa Vinci                 15      16      4         14      A\nDel Piombo                8      13     16          7      A\nDel Sarto                12      16      9          8      A\nFr. Penni                 0      15      8          0      A\nGuilio Romano            15      16      4         14      A\nMichelangelo              8      17      4          8      A\nPerino del Vaga          15      16      7          6      A\nPerugino                  4      12     10          4      A\nRaphael                  17      18     12         18      A\n\n\nYou can also sort a data frame by more than one variable. The following command sorts by School, then by Drawing:\n\npainters_ABC[order(painters_ABC$School, \n                   painters_ABC$Drawing), ]\n\n                Composition Drawing Colour Expression School\nDa Udine                 10       8     16          3      A\nPerugino                  4      12     10          4      A\nDel Piombo                8      13     16          7      A\nFr. Penni                 0      15      8          0      A\nDa Vinci                 15      16      4         14      A\nDel Sarto                12      16      9          8      A\nGuilio Romano            15      16      4         14      A\nPerino del Vaga          15      16      7          6      A\nMichelangelo              8      17      4          8      A\nRaphael                  17      18     12         18      A\nF. Zucarro               10      13      8          8      B\nPrimaticcio              15      14      7         10      B\nT. Zucarro               13      14     10          9      B\nFr. Salviata             13      15      8          8      B\nParmigiano               10      15      6          6      B\nVolterra                 12      15      5          8      B\nJosepin                  10      10      6          2      C\nL. Jordaens              13      12      9          6      C\nCortona                  16      14     12          6      C\nBarocci                  14      15      6         10      C\nTesta                    11      15      0          6      C\nVanius                   15      15     12         13      C\n\n\nIf you specify decreasing = TRUE, the sorting is applied in descending order for all variables listed:\n\npainters_ABC[order(painters_ABC$School, \n                   painters_ABC$Colour,    \n                   painters_ABC$Drawing, \n                   decreasing = T),]\n\n                Composition Drawing Colour Expression School\nVanius                   15      15     12         13      C\nCortona                  16      14     12          6      C\nL. Jordaens              13      12      9          6      C\nBarocci                  14      15      6         10      C\nJosepin                  10      10      6          2      C\nTesta                    11      15      0          6      C\nT. Zucarro               13      14     10          9      B\nFr. Salviata             13      15      8          8      B\nF. Zucarro               10      13      8          8      B\nPrimaticcio              15      14      7         10      B\nParmigiano               10      15      6          6      B\nVolterra                 12      15      5          8      B\nDel Piombo                8      13     16          7      A\nDa Udine                 10       8     16          3      A\nRaphael                  17      18     12         18      A\nPerugino                  4      12     10          4      A\nDel Sarto                12      16      9          8      A\nFr. Penni                 0      15      8          0      A\nPerino del Vaga          15      16      7          6      A\nMichelangelo              8      17      4          8      A\nDa Vinci                 15      16      4         14      A\nGuilio Romano            15      16      4         14      A\n\n\nTo selectively sort one of the numeric variables in descending order, you can prefix it with a minus sign (-). For example, this command sorts by School, then by decreasing Colour, and finally by Drawing:\n\npainters_ABC[order(painters_ABC$School, \n                   -painters_ABC$Colour, \n                   painters_ABC$Drawing), ]\n\n                Composition Drawing Colour Expression School\nDa Udine                 10       8     16          3      A\nDel Piombo                8      13     16          7      A\nRaphael                  17      18     12         18      A\nPerugino                  4      12     10          4      A\nDel Sarto                12      16      9          8      A\nFr. Penni                 0      15      8          0      A\nPerino del Vaga          15      16      7          6      A\nDa Vinci                 15      16      4         14      A\nGuilio Romano            15      16      4         14      A\nMichelangelo              8      17      4          8      A\nT. Zucarro               13      14     10          9      B\nF. Zucarro               10      13      8          8      B\nFr. Salviata             13      15      8          8      B\nPrimaticcio              15      14      7         10      B\nParmigiano               10      15      6          6      B\nVolterra                 12      15      5          8      B\nCortona                  16      14     12          6      C\nVanius                   15      15     12         13      C\nL. Jordaens              13      12      9          6      C\nJosepin                  10      10      6          2      C\nBarocci                  14      15      6         10      C\nTesta                    11      15      0          6      C\n\n\nWhen working with character variables, the minus sign cannot be applied directly. Instead, use the xtfrm() function, which transforms the character variable into a numeric form that preserves the original sort order. This allows descending sorting for character data:\n\nxtfrm(c(\"A\", \"D\", \"B\", \"C\"))\n\n[1] 1 4 2 3\n\npainters_ABC[order(-xtfrm(painters_ABC$School),\n                   painters_ABC$Drawing), ]\n\n                Composition Drawing Colour Expression School\nJosepin                  10      10      6          2      C\nL. Jordaens              13      12      9          6      C\nCortona                  16      14     12          6      C\nBarocci                  14      15      6         10      C\nTesta                    11      15      0          6      C\nVanius                   15      15     12         13      C\nF. Zucarro               10      13      8          8      B\nPrimaticcio              15      14      7         10      B\nT. Zucarro               13      14     10          9      B\nFr. Salviata             13      15      8          8      B\nParmigiano               10      15      6          6      B\nVolterra                 12      15      5          8      B\nDa Udine                 10       8     16          3      A\nPerugino                  4      12     10          4      A\nDel Piombo                8      13     16          7      A\nFr. Penni                 0      15      8          0      A\nDa Vinci                 15      16      4         14      A\nDel Sarto                12      16      9          8      A\nGuilio Romano            15      16      4         14      A\nPerino del Vaga          15      16      7          6      A\nMichelangelo              8      17      4          8      A\nRaphael                  17      18     12         18      A\n\n\nBy default, missing values (NA) are placed at the end of the sorted result. To move missing values to the beginning, set na.last = FALSE. To remove rows with missing values from the sort entirely, use na.last = NA.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#the-differences-between-and",
    "href": "Subsetting.html#the-differences-between-and",
    "title": "4  Subsetting Objects",
    "section": "4.6 The Differences Between [, [[, and $",
    "text": "4.6 The Differences Between [, [[, and $\nR provides three operators—[, [[, and $—for subsetting objects. The choice of which operator to use depends on the type of object and the form of the result you want. Understanding the distinctions between these operators is important for writing clear and predictable code.\n\n4.6.1 Selecting a Single Column from a Data Frame\nWhen you use [ to select a single column from a data frame, the result is still a data frame:\n\nd\n\n  L M    N1\n1 A 1  TRUE\n2 B 2 FALSE\n3 C 3    NA\n\nd[3]\n\n     N1\n1  TRUE\n2 FALSE\n3    NA\n\nd[\"N1\"]\n\n     N1\n1  TRUE\n2 FALSE\n3    NA\n\nd[-c(1,2)]\n\n     N1\n1  TRUE\n2 FALSE\n3    NA\n\n\nIn contrast, using [[ returns a vector instead of a data frame:\n\nd[[3]]\n\n[1]  TRUE FALSE    NA\n\nd[[\"N1\"]]\n\n[1]  TRUE FALSE    NA\n\n\nSimilarly, the $ operator also returns a vector:\n\nd$N1\n\n[1]  TRUE FALSE    NA\n\n\n\n\n4.6.2 Selecting One or Several Components from an Object\nThe [ operator allows selection of multiple components (e.g., multiple columns from a data frame). However, both [[ and $ can be used to select only a single element at a time. For example:\n\nd[1:2]\n\n  L M\n1 A 1\n2 B 2\n3 C 3\n\nd[-3]\n\n  L M\n1 A 1\n2 B 2\n3 C 3\n\nd[c(\"L\", \"M\")]\n\n  L M\n1 A 1\n2 B 2\n3 C 3\n\n\nThis rule applies not only to data frames but also to other list-like objects.\n\n\n4.6.3 Using Operators for Evaluations\nThe [[ and [ operators evaluate their arguments, meaning you can pass in expressions. For instance:\n\nd[[1+2]]\n\n[1]  TRUE FALSE    NA\n\nd[c(1,2)+1]\n\n  M    N1\n1 1  TRUE\n2 2 FALSE\n3 3    NA\n\n\nIn contrast, the $ operator does not evaluate its argument. It expects a literal column name. As a result, the following will not work:\n\nd$1 + 2\n\nError in parse(text = input): &lt;text&gt;:1:3: unexpected numeric constant\n1: d$1\n      ^\n\n\n\n\n4.6.4 Partial Matching\nThe $ operator allows for partial matching of column names, whereas [ and [[ do not. In the example below, the column N1 is returned even though only N is specified:\n\nd$N\n\n[1]  TRUE FALSE    NA\n\n\nWhile partial matching can be convenient, it is generally discouraged. Using full, explicit names makes your code easier to understand and less error-prone.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#simplifying-and-preserving",
    "href": "Subsetting.html#simplifying-and-preserving",
    "title": "4  Subsetting Objects",
    "section": "4.7 Simplifying and Preserving",
    "text": "4.7 Simplifying and Preserving\nThis section is based in part on Advanced R by Hadley Wickham (2nd ed., https://adv-r.hadley.nz/subsetting.html)(Wickham 2019), which provides an in-depth treatment of how subsetting can return either simplified or preserved structures in R.\nWhen you subset an object, the result may not always retain the original structure. Simplifying subsets return the most compact possible result (e.g., a vector instead of a data frame), while preserving subsets maintain the structure of the original object. Choosing between them depends on your analysis goals—whether you want simplicity or consistency in data type.\n\n4.7.1 Simplifying and Preserving: Vectors\nLet’s consider a named vector. Using double brackets [[ simplifies the output by removing additional attributes like names. On the other hand, using single brackets [ preserves these attributes and returns a subset of the same type.\n\nv &lt;- 1:5\nnames(v) &lt;- letters[1:5]\nv\n\na b c d e \n1 2 3 4 5 \n\nv[[1]] ## Simplified output, no names\n\n[1] 1\n\nv[1]   ## Preserved output, names retained\n\na \n1 \n\n\n\n\n4.7.2 Simplifying and Preserving: Factors\nWhen extracting elements from a factor, simplification means dropping unused levels. This is done by setting drop = TRUE, which is the default. Preservation retains all original levels, even if they are not present in the subset.\n\nf &lt;- factor(c(\"A\", \"B\", \"C\"))\nf\n\n[1] A B C\nLevels: A B C\n\nf[1:2, drop=T]  ## Simplified: unused levels dropped\n\n[1] A B\nLevels: A B\n\nf[1:2]          ## Preserved: all levels retained\n\n[1] A B\nLevels: A B C\n\n\n\n\n4.7.3 Simplifying and Preserving: Matrices\nIn matrix subsetting, selecting a single row or column can return a simplified result (a vector). To retain the matrix structure, set drop = FALSE to preserve the two-dimensional format.\n\nm &lt;- matrix(1:4, 2)\nm\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nm[, 1]                ## Simplified: returns a vector\n\n[1] 1 2\n\nm[1, ]                ### Simplified: returns a vector\n\n[1] 1 3\n\nm[, 1, drop = FALSE]  ## Preserved: still a matrix\n\n     [,1]\n[1,]    1\n[2,]    2\n\nm[1, , drop = FALSE]  # Preserved: still a matrix\n\n     [,1] [,2]\n[1,]    1    3\n\n\n\n\n4.7.4 Simplifying and Preserving: Lists\nFor lists, double brackets [[ return the internal object directly (e.g., a vector or string), whereas single brackets [ return a sublist, preserving the list structure.\n\nl &lt;- list(a = 1:3, b = \"A\")\nl\n\n$a\n[1] 1 2 3\n\n$b\n[1] \"A\"\n\nl[[1]]  ## Simplifying\n\n[1] 1 2 3\n\nl[1]    ## Preserving\n\n$a\n[1] 1 2 3\n\n\n\n\n4.7.5 Simplifying and Preserving: Data Frames\nA data frame in R can behave either like a matrix or like a list. Depending on how you subset it, the result may either simplify to a vector or preserve the original data frame structure. Below, we illustrate both behaviors.\nTreating a Data Frame as a Matrix\nWhen using the single bracket operator [ with two indices — the first for rows and the second for columns — R treats the data frame like a matrix. Selecting a single column in this way returns a simplified result: a vector.\n\nd &lt;-  data.frame(\n  V1 = 1:3,\n  V2 = letters[1:3],\n  V3 = c(T, T, F)\n)\nd\n\n  V1 V2    V3\n1  1  a  TRUE\n2  2  b  TRUE\n3  3  c FALSE\n\nd[, 2]         ## Simplifying – returns a vector\n\n[1] \"a\" \"b\" \"c\"\n\n\nTo preserve the data frame structure when selecting one column, use the drop = FALSE option:\n\nd[, 2, drop = FALSE]  ## Preserving – returns a one-column data frame\n\n  V2\n1  a\n2  b\n3  c\n\n\nTreating a Data Frame as a List\nAlternatively, you can treat a data frame as a list, where each column is a component of the list. In this case, using double brackets [[ extracts a single component and simplifies the result:\n\nd[[2]]   ## Simplifying – returns a vector\n\n[1] \"a\" \"b\" \"c\"\n\n\nUsing single brackets [ with a numeric or character vector returns a sub-list, which preserves the data frame structure:\n\nd[2]     ## Preserving – returns a one-column data frame\n\n  V2\n1  a\n2  b\n3  c\n\n\nThis distinction between matrix-style and list-style subsetting is important when you want to control the structure of the output — whether you need a simple vector or wish to retain the data frame format for further processing.\n\n\n\n\nWickham, Hadley. 2019. Advanced r. 2nd ed. CRC Press. https://adv-r.hadley.nz/.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "5  Writing User-Defined Functions",
    "section": "",
    "text": "5.1 Creating Your Own Functions\nThis section introduces the motivation for writing functions and explains how to create them step by step. We begin with a practical example to show when a function is useful, then walk through the process of converting a sequence of R commands into a well-structured function. Along the way, we will highlight key concepts such as input arguments, return values, and testing your function for reliability. Writing your own functions is an essential skill for producing clean, reusable, and scalable R code.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Writing User-Defined Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#creating-your-own-functions",
    "href": "functions.html#creating-your-own-functions",
    "title": "5  Writing User-Defined Functions",
    "section": "",
    "text": "5.1.1 Why Write a Function?\nIn R, we often find ourselves performing the same task multiple times—such as cleaning data, performing calculations, or creating plots. If the same block of code is used repeatedly with only slight changes, it becomes a good candidate for turning into a function. Writing a function allows us to package that code into a single, reusable unit.\nThere are several advantages to writing your own functions:\n\nClarity: A well-named function helps explain what the code does, making your script easier to read and understand.\nEfficiency: Once a function is defined, you can call it with different inputs as needed, instead of copying and modifying code manually.\nMaintainability: If you need to make changes, you only have to update the code in one place.\nError reduction: Using functions helps avoid small but hard-to-spot mistakes that often come from copying and pasting similar code blocks.\nModularity: Even if a task isn’t repeated, wrapping related commands into a function can help organize your code into logical sections. This makes it easier to manage, test, and reuse in future projects.\n\nFor example, Suppose we have the following vector:\n\nv1 &lt;- c(5, 10, NA, 15, 20, 100)\n\nNow we want to compute a few summary statistics, including mean, standard deviation, number of missing values, and then print the results in a readable format. Here is how we might write the code:\n\nMean &lt;- mean(v1, na.rm = TRUE)\nSD &lt;- sd(v1, na.rm = TRUE)\nn_missing &lt;- sum(is.na(v1))\n\ncat(\"Mean:\", Mean, \"\\n\")\n\nMean: 30 \n\ncat(\"Standard Deviation:\", SD, \"\\n\")\n\nStandard Deviation: 39.52847 \n\ncat(\"Number of Missing Values:\", n_missing, \"\\n\")\n\nNumber of Missing Values: 1 \n\n\nThe cat() function, short for concatenate and print, is used here to display all three results together in a readable format. It can take a varied number of arguments, each of which can be a constant (quoted text), a variable, or a special character like \"\\n\" (for a new line). All arguments are printed in the order they appear and, by default, are separated by a single space. The \"\\n\" tells R to move to a new line so that each printed value appears neatly on its own line.\nFor example:\n\nx &lt;- 10\ncat(\"The value of x is\", x, \"\\n\")  \n\nThe value of x is 10 \n\n\nIn the code above, cat() is used to combine static labels (\"Mean:\", \"Standard Deviation:\", etc.) with the corresponding computed values. This makes the output easier to read when the function is run.\nThis approach works well, but if we want to apply the same steps to many different vectors, it becomes repetitive and harder to manage.\n\n\n5.1.2 Turning Code into a Function\nWhen we write a function, we are building a small machine. This machine takes input, performs a sequence of operations, and produces output. Just like a vending machine accepts a selection and returns a snack, an R function accepts an argument, performs some computations, and either returns a result or carries out an action. Not all functions need to return a value. In our example, the function simply computes summary statistics and prints them, rather than returning them to be stored or reused.\nFunction Syntax\nThe general structure of a user-defined function is as follows:\nfunction_name &lt;- function(parameter1, parameter2, ...) {\n  # code block\n  # the final line is usually the value returned\n}\n\nfunction_name is the name you assign to your function\nInside the parentheses, you define parameters—these are placeholders for the input values\nThe curly braces {} contain the function body—this is the code that runs when the function is called\nWhen you later call the function and pass in specific values, those values are called arguments\n\nThis basic structure is described in many R references, including R for Data Science (Wickham, Çetinkaya-Rundel, and Grolemund 2023), which offers a practical introduction to writing clear, reusable functions in real-world analysis workflows.\nStep-by-Step: Turning Code into a Function\nLet’s return to the example from the previous section. We want to compute a few summary statistics, and then print the results. The previous code works well, but if we want to repeat these steps for several different vectors, it becomes repetitive. Instead, we can turn it into a function that takes any numeric vector as input and returns the cleaned result.\nStep 1: Choose a Function Name and Parameter\nWe’ll name the function summarize_vector. To decide what should become the parameter, we look back at the original code:\n\nMean &lt;- mean(v1, na.rm = TRUE)\nSD &lt;- sd(v1, na.rm = TRUE)\nn_missing &lt;- sum(is.na(v1))\n\ncat(\"Mean:\", Mean, \"\\n\")\n\nMean: 30 \n\ncat(\"Standard Deviation:\", SD, \"\\n\")\n\nStandard Deviation: 39.52847 \n\ncat(\"Number of Missing Values:\", n_missing, \"\\n\")\n\nNumber of Missing Values: 1 \n\n\nIn this code, the object v1 appears multiple times. It’s used to calculate the mean, the standard deviation, and the number of missing values. This repetition suggests that v1 is the natural input to the function—it’s the part that changes when we want to analyze a different vector.\nTo make the code reusable, we generalize v1 to a parameter called x. Later, when we call the function, we can pass any numeric vector to x.\nBefore turning this into a full function, it’s a good idea to test whether your edits work. One simple way to do this is to assign v1 to a new variable x, then manually replace all instances of v1 with x in your code. This lets you verify that your logic still works with the parameter name you’ll use inside the function. For example:\n\nx &lt;- v1    ## parameter &lt;- argument\n\nMean &lt;- mean(x, na.rm = TRUE)  # replace v1 with x\nSD &lt;- sd(x, na.rm = TRUE)      # replace v1 with x\nn_missing &lt;- sum(is.na(x))     # replace v1 with x\n\ncat(\"Mean:\", Mean, \"\\n\")\n\nMean: 30 \n\ncat(\"Standard Deviation:\", SD, \"\\n\")\n\nStandard Deviation: 39.52847 \n\ncat(\"Number of Missing Values:\", n_missing, \"\\n\")\n\nNumber of Missing Values: 1 \n\n\nIf this modified version runs correctly, you’re ready to move on to the next step—placing the code into a function definition.\nStep 2: Move the Code into the Function Body\nNext, we place the modified code into the function definition. The input vector x is now the function’s parameter, and everything inside the curly braces {} becomes the body of the function. This is the set of instructions that will be executed whenever the function is called.\n\nsummarize_vector &lt;- function(x) {\n  Mean &lt;- mean(x, na.rm = TRUE)\n  SD &lt;- sd(x, na.rm = TRUE)\n  n_missing &lt;- sum(is.na(x))\n  \n  cat(\"Mean:\", Mean, \"\\n\")\n  cat(\"Standard Deviation:\", SD, \"\\n\")\n  cat(\"Number of Missing Values:\", n_missing, \"\\n\")\n}\n\nAt this point, the function is ready to use. We’ve made the code self-contained and reusable by identifying the input (x) and wrapping the logic inside a clearly named function.\nStep 3: Call the Function with Different Arguments\nNow that the function is defined, we can reuse it on any numeric vector by supplying an argument to the parameter x.\n\nsummarize_vector(v1)\n\nMean: 30 \nStandard Deviation: 39.52847 \nNumber of Missing Values: 1 \n\nsummarize_vector(c(2, 4, 6, NA, 8, 10, NA))\n\nMean: 6 \nStandard Deviation: 3.162278 \nNumber of Missing Values: 2 \n\n\nEach time we call the function, the argument we provide replaces the parameter x inside the function body. The same block of code runs, but it operates on the new data we supplied—saving time and reducing errors compared to copying and pasting the same code repeatedly.\n\n\n5.1.3 Return Values\nThe original version of summarize_vector() simply printed the results using cat(), but it did not return a value. In practice, we often want a function to return an object so that the result can be stored or used later in further computations.\nIn R, the value returned by a function is typically the result of the final (unassigned) expression in the function body. If we want to return multiple values, we usually combine them into a single object. The most common way to do this is to return a list.\nHere’s a revised version of the function that prints the results and returns a list:\n\nsummarize_vector &lt;- function(x) {\n  Mean &lt;- mean(x, na.rm = TRUE)\n  SD &lt;- sd(x, na.rm = TRUE)\n  n_missing &lt;- sum(is.na(x))\n  \n  cat(\"Mean:\", Mean, \"\\n\")\n  cat(\"Standard Deviation:\", SD, \"\\n\")\n  cat(\"Number of Missing Values:\", n_missing, \"\\n\")\n  \n  list(\n    Mean = Mean,\n    SD = SD,\n    N_miss = n_missing\n  )\n}\nv1_summary &lt;- summarize_vector(v1)\n\nMean: 30 \nStandard Deviation: 39.52847 \nNumber of Missing Values: 1 \n\nv1_summary\n\n$Mean\n[1] 30\n\n$SD\n[1] 39.52847\n\n$N_miss\n[1] 1\n\n\nAlternatively, if all the values share the same data type, you can return them as a named vector instead of a list:\n\nsummarize_vector &lt;- function(x) {\n  Mean &lt;- mean(x, na.rm = TRUE)\n  SD &lt;- sd(x, na.rm = TRUE)\n  n_missing &lt;- sum(is.na(x))\n  \n  cat(\"Mean:\", Mean, \"\\n\")\n  cat(\"Standard Deviation:\", SD, \"\\n\")\n  cat(\"Number of Missing Values:\", n_missing, \"\\n\")\n  \n  c(\n    Mean = Mean,\n    SD = SD,\n    N_miss = n_missing\n  )\n}\nv1_summary &lt;- summarize_vector(v1)\n\nMean: 30 \nStandard Deviation: 39.52847 \nNumber of Missing Values: 1 \n\nv1_summary\n\n    Mean       SD   N_miss \n30.00000 39.52847  1.00000 \n\n\nThe important idea here is that a function must return exactly one object. That object can be as simple as a number or as complex as a list or data frame—it just has to be one object. This often requires some thoughtful design, especially when returning multiple pieces of related information.\nFinally, you can also use the return() function to explicitly return a value. Although it’s not required in most cases, return() can be useful if you want to stop a function early and send back a result. You’ll find this especially helpful later when we learn about if statements.\n\nreturn(c(Mean = Mean, SD = SD, N_miss = n_missing))",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Writing User-Defined Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#execution-order-in-functions",
    "href": "functions.html#execution-order-in-functions",
    "title": "5  Writing User-Defined Functions",
    "section": "5.2 Execution Order in Functions",
    "text": "5.2 Execution Order in Functions\nWhen we write functions, it’s not just the individual commands that matter—it’s the order in which we execute them. In most real-world applications, each step depends on the output of a previous step, so getting the sequence right is essential. In this section, we’ll explore this idea using a few concrete examples, starting with some simple ones and building up to more practical applications.\n\n5.2.1 Sequential Execution with Simple Calculations\nWhen writing a function, it’s important to pay attention to the order in which the commands are executed. Many operations depend on results from earlier steps. If you skip a step or rearrange the code incorrectly, the function may fail or return the wrong result.\nLet’s work through a simple example. Suppose we want to standardize the values in a numeric vector, and print the results in a readable format.\nWe can begin by testing this in open code using a sample vector v1.\n\nv1 &lt;- c(5, 10, 12, 15, 18, 100)\n\nmean_v1 &lt;- mean(v1, na.rm = TRUE)\nsd_v1 &lt;- sd(v1, na.rm = TRUE)\n\nz &lt;- (v1 - mean_v1) / sd_v1\nextreme_count &lt;- sum(abs(z) &gt; 2)\n\ncat(\"Standardized values:\", round(z, 2), \"\\n\")\n\nStandardized values: -0.6 -0.46 -0.41 -0.32 -0.24 2.03 \n\ncat(\"Number of extreme values:\", extreme_count, \"\\n\")\n\nNumber of extreme values: 1 \n\n\nEvery line here builds on the previous one. For example, we cannot compute z without calculating the mean and standard deviation first. If you change the order of these statements, the code won’t work.\nWe apply round(z, 2) inside cat() to make the printed output easier to read. The internal calculations are still done with full precision.\nTo make this task reusable, we can write a function. This time, we’ll use two parameters:\n\nx: the numeric vector\ncutoff: the threshold for identifying extreme values\n\nHere’s the function version:\n\nsummarize_extremes &lt;- function(x, cutoff) {\n  mean_x &lt;- mean(x, na.rm = TRUE)\n  sd_x &lt;- sd(x, na.rm = TRUE)\n\n  z &lt;- (x - mean_x) / sd_x\n  extreme_count &lt;- sum(abs(z) &gt; cutoff)\n\n  cat(\"Standardized values:\", round(z, 2), \"\\n\")\n  cat(\"Number of extreme values:\", extreme_count, \"\\n\")\n}\n\nLet’s test the function:\n\nsummarize_extremes(v1, 2)\n\nStandardized values: -0.6 -0.46 -0.41 -0.32 -0.24 2.03 \nNumber of extreme values: 1 \n\nsummarize_extremes(c(1, 2, 3, 4, 100), 1.5)\n\nStandardized values: -0.48 -0.46 -0.44 -0.41 1.79 \nNumber of extreme values: 1 \n\n\nThis example highlights two important ideas about writing functions:\n\nThe order of commands matters—each step often depends on values computed earlier.\nFunctions can be made more flexible by accepting multiple parameters, such as the data and a threshold value.\n\n\n\n5.2.2 Application: Imputing Numeric Variables\nIn the previous chapter, we examined how to replace missing values in a numeric vector with the median. Now, suppose we want to apply this idea more generally—to replace missing values in a column of a data frame. Since this task could be useful across many datasets and variables, it makes sense to write a reusable function.\nWe’ll name this function impute_num().\nChoosing Parameters\nTo make the function flexible, we need to allow both the data frame and the target variable to change. So our function will take two parameters:\n\ndat: the data frame\nvar_name: the name of the numeric variable (as a string)\n\nWe begin by setting up the function shell:\n\nimpute_num &lt;- function(dat, var_name){\n  # Function body\n}\n\nLet’s walk through how to build the function body step by step. We’ll use the patient dataset as our working example:\n\nload(\"patient.RData\")\npatient\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88  NA  32  99    Y    Y     Y\n2   B   NA 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120    N    N     N\n4   D   NA 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88  NA  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190    N    N     N\n10  J   90  NA  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\n\nWe plan to test the function using impute_num(patient, \"GLUC\"). To simulate what happens inside the function, we first assign the argument values to the parameter names:\n\ndat &lt;- patient     ## input argument 1\nvar_name &lt;- \"GLUC\" ## input argument 2\n\nSequential Steps\nNow we can write out the logic. The goal is to replace all NA values in a numeric column with its median. Here’s how we’ll do it:\n\nExtract the numeric column from the data frame using [[ ]]\nCalculate the median of the extracted vector\nReplace the missing values with the median\nInsert the cleaned vector back into the original data frame\n\nEach step must be done in order. For example, we can’t calculate the median before we extract the column. The process looks like this:\n\nselect_var &lt;- dat[[var_name]]                  ## step 1: \nselect_var\n\n [1]  88  NA 110  NA  90  88 120 110  NA  90\n\nreplace_value &lt;- median(select_var, na.rm=T)   ## step 2\nreplace_value\n\n[1] 90\n\nselect_var[is.na(select_var)] &lt;- replace_value ## step 3: \nselect_var \n\n [1]  88  90 110  90  90  88 120 110  90  90\n\ndat[[var_name]] &lt;- select_var                  ## step 4\ndat\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88  NA  32  99    Y    Y     Y\n2   B   90 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120    N    N     N\n4   D   90 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88  NA  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   90 190  NA 190    N    N     N\n10  J   90  NA  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\n\nOnce all the pieces work individually, we can bundle them into our function:\n\nimpute_num &lt;- function(dat, var_name){\n  select_var &lt;- dat[[var_name]]                  ## step 1: \n  replace_value &lt;- median(select_var, na.rm=T)   ## step 2\n  select_var[is.na(select_var)] &lt;- replace_value ## step 3: \n  dat[[var_name]] &lt;- select_var                  ## step 4\n  dat           ## returned value\n}\n\nLet’s test it on different columns:\n\nimpute_num (patient, \"GLUC\")\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88  NA  32  99    Y    Y     Y\n2   B   90 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120    N    N     N\n4   D   90 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88  NA  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   90 190  NA 190    N    N     N\n10  J   90  NA  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\nimpute_num (patient, \"TGL\")   ## try another variable\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88 180  32  99    Y    Y     Y\n2   B   NA 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110 180  NA 120    N    N     N\n4   D   NA 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88 180  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190    N    N     N\n10  J   90 180  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\n\nThis example demonstrates how each step in a function builds on the last—and why preserving the correct order is essential for correct results.\n\n\n5.2.3 Application: Imputing Character Variables\nJust like with numeric variables, we often encounter missing values in character columns—such as patient status, gender, or treatment group. A common strategy is to fill in these missing values using the most frequent (or most common) category.\nIn this section, we’ll create a function called impute_char() to do exactly that. Similar to impute_num(), this function will take two parameters:\n\ndat: the data frame\nvar_name: the name of the character variable (as a string)\n\nLet’s begin with the function shell:\n\nimpute_char &lt;- function(dat, var_name) {\n  # Function body\n}\n\nWe’ll use the same patient dataset to test the commands before writing the complete function. To simulate the function behavior, we assign the test arguments to their corresponding parameter names:\n\ndat &lt;- patient        ## input parameter 1\nvar_name &lt;- \"HRT\"     ## input parameter 2\n\nOur goal is to replace missing values in a character vector with the value that occurs most frequently. Here’s the sequence of operations we’ll follow:\n\nExtract the character column from the data frame.\nCreate a frequency table.\nIdentify the most common value.\nReplace all missing values with that value.\nInsert the updated column back into the data frame.\n\nLet’s test each step:\n\nselect_var &lt;- dat[[var_name]]         # Step 1: extract variable\ntab_result &lt;- table(select_var)       # Step 2: frequency table\nhigh_freq  &lt;- max(tab_result)         # Step 3a: get highest frequency\nreplace_value &lt;- names(tab_result)[tab_result == high_freq]  # Step 3b\nselect_var[is.na(select_var)] &lt;- replace_value  # Step 4\ndat[[var_name]] &lt;- select_var         # Step 5: put it back\ndat\n\n   ID GLUC TGL HDL LDL HRT MAMM SMOKE\n1   A   88  NA  32  99   Y    Y     Y\n2   B   NA 150  60  NA   Y &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120   N    N     N\n4   D   NA 200  65 165   Y &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150   Y    Y     Y\n6   F   88  NA  32 210   Y &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA   Y    Y     Y\n8   H  110 170  70 188   Y &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190   N    N     N\n10  J   90  NA  75  NA   Y &lt;NA&gt;  &lt;NA&gt;\n\n\nAfter confirming these steps work correctly, we can write the full function:\n\nimpute_char &lt;- function(dat, var_name){\n  select_var &lt;- dat[[var_name]]                   # step 1\n  tab_result &lt;- table(select_var)                 # step 2\n  high_freq &lt;- max(tab_result)                    # step 3a\n  replace_value &lt;- names(tab_result)[tab_result == high_freq]  # step 3b\n  select_var[is.na(select_var)] &lt;- replace_value  # step 4\n  dat[[var_name]] &lt;- select_var                   # step 5\n  dat  # return updated data frame\n}\n\nLet’s test it out:\n\nimpute_char(patient, \"HRT\")\n\n   ID GLUC TGL HDL LDL HRT MAMM SMOKE\n1   A   88  NA  32  99   Y    Y     Y\n2   B   NA 150  60  NA   Y &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120   N    N     N\n4   D   NA 200  65 165   Y &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150   Y    Y     Y\n6   F   88  NA  32 210   Y &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA   Y    Y     Y\n8   H  110 170  70 188   Y &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190   N    N     N\n10  J   90  NA  75  NA   Y &lt;NA&gt;  &lt;NA&gt;\n\n\nThis example reinforces the importance of logic and order: we must first identify the most frequent value before using it to fill in missing entries.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Writing User-Defined Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#function-parameters",
    "href": "functions.html#function-parameters",
    "title": "5  Writing User-Defined Functions",
    "section": "5.3 Function Parameters",
    "text": "5.3 Function Parameters\nWhen we define a function, we often include one or more parameters—placeholders that will be filled with actual values, known as arguments, when the function is called. Understanding how arguments are matched to parameters, how default values work, and how R evaluates them is essential for writing clear, reusable, and flexible functions. In the following subsections, we explore different ways arguments can be passed to parameters, how default values simplify function calls, and when certain types of parameter behavior matter in practice.\n\n5.3.1 Matching Arguments to Parameters\nIn the impute_num() function, there are two parameters: dat and var_name. When we call the function like this:\n\nimpute_num(patient, \"GLUC\")\n\nthe argument patient is assigned to the parameter dat, and \"GLUC\" is assigned to var_name. This method of matching arguments by their position in the function call is called positional matching.\nAn alternative approach is keyword matching, where we specify arguments using the parameter = argument format:\n\nimpute_num(dat = patient, var_name = \"GLUC\")\n\nWith keyword matching, we do not need to follow the parameter order:\n\nimpute_num(var_name = \"GLUC\", dat = patient)\n\nBoth positional and keyword matching can be used together, although once you use keyword matching in a function call, it’s best to continue using it for clarity.\n\n\n5.3.2 Default Arguments\nWe can assign default values to one or more parameters, making the function more flexible and easier to use. This is helpful when one parameter usually takes the same value. For example, suppose we use the patient dataset most of the time. We can set it as the default for dat:\n\nimpute_num &lt;- function(dat = patient, var_name) {\n  select_var &lt;- dat[[var_name]] \n  replace_value &lt;- median(select_var, na.rm = TRUE) \n  select_var[is.na(select_var)] &lt;- replace_value \n  dat[[var_name]] &lt;- select_var \n  dat \n}\n\nNow, we only need to specify var_name when using the patient dataset:\n\nimpute_num(var_name = \"GLUC\")\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88  NA  32  99    Y    Y     Y\n2   B   90 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120    N    N     N\n4   D   90 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88  NA  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   90 190  NA 190    N    N     N\n10  J   90  NA  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\n\nIf we supply a different data frame, it overrides the default:\n\nfoo &lt;- data.frame(var1 = c(1, 4, NA, 7, 9))\nimpute_num(foo, \"var1\")\n\n  var1\n1  1.0\n2  4.0\n3  5.5\n4  7.0\n5  9.0\n\n\n\n\n5.3.3 Why Use [[ Instead of $?\nInside the function, we extract a column with dat[[var_name]] rather than dat$var_name. This is because the $ operator does not evaluate variables, so writing dat$var_name will literally look for a column named \"var_name\", not the value stored in the var_name variable. The double bracket operator [[ ]], however, evaluates its argument and works with variable column names.\n\n\n5.3.4 Parameterless Functions\nNot all functions require input parameters. While less common for beginners, parameterless functions can still be useful. Here’s a simple example:\n\ngreeting_function &lt;- function() {\n  print(\"Hello, welcome to the world of R programming!\")\n}\ngreeting_function()\n\n[1] \"Hello, welcome to the world of R programming!\"\n\n\nThis function will always return the same greeting when called, without needing any input.\nIf a function body contains only a single command, the curly braces {} are optional. For example, the following version of greeting_function() is equivalent:\n\ngreeting_function &lt;- function() print(\"Hello, welcome to the world of R programming!\")\ngreeting_function()\n\n[1] \"Hello, welcome to the world of R programming!\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Writing User-Defined Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#condition-logic",
    "href": "functions.html#condition-logic",
    "title": "5  Writing User-Defined Functions",
    "section": "5.4 Condition Logic",
    "text": "5.4 Condition Logic\nIn programming, conditional logic allows us to control which pieces of code run based on whether certain conditions are true or false. Just as people make decisions based on situations (“If it’s raining, take an umbrella”), R functions can adapt their behavior using structures like if, else, and logical operators. These tools make our code smarter and more flexible—able to handle different inputs, trigger warnings, or change behavior depending on data values.\nThis section introduces several key components of conditional logic:\n\n5.4.1 The if Statement\nThe if statement is the most basic form of conditional logic in R. It allows your code to make decisions: if a certain condition is true, do one thing; if not, do something else. The general forms of the if statement are:\nif (condition) expression\nif (condition) expression else alternative_expression\nIn the first form, R evaluates the condition. If it is true, it runs the expression. If it is false, nothing happens.\nIn the second form, the else block provides an alternative. If the condition is false, R will execute the alternative_expression. This syntax and logic flow are consistent with standard base R practices, as outlined in R Programming for Data Science (Peng 2020).\nHere’s a simple example:\n\nscore &lt;- 73\nif (score &gt;=60) grade &lt;- \"pass\" else grade &lt;- \"fail\"\ngrade\n\n[1] \"pass\"\n\n\nIf your logic spans multiple lines, you should enclose the expressions inside curly braces {} to create a code block:\nif (condition) {\n  command_1\n  command_2\n  ...\n} else {\n  command_3\n  command_4\n  ...\n}\nFor example:\n\nscore &lt;- 73\nif (score &gt;=60) {\n  grade &lt;- \"pass\" \n  score &lt;- round(score/10)\n} else {\n  grade &lt;- \"fail\"\n  score &lt;- 0\n}\ngrade\n\n[1] \"pass\"\n\nscore\n\n[1] 7\n\n\nIf you need to check multiple conditions, you can chain them using else if:\nif (cond_1) {\n  command(s)\n} else if (cond_2){\n  command(s)\n} else if (cond_3){\n  command(s)\n} else{\n  command(s)\n}\nFor example:\n\nscore &lt;- 73\nif (score &gt;=90) {\n  grade &lt;- \"A\" \n} else if (score &gt;=80) {\n  grade &lt;- \"B\"\n} else if (score &gt;=70) {\n  grade &lt;- \"C\"\n} else if (score &gt;=60) {\n  grade &lt;- \"D\"\n} else {\n  grade &lt;- \"F\"\n} \ngrade\n\n[1] \"C\"\n\n\nEach condition is evaluated in order. Once a condition is found to be true, the corresponding block is executed, and the rest are skipped.\n\n\n5.4.2 Logical Operators\nLogical operators allow us to compare values and evaluate conditions. In R, the most commonly used logical operators are:\n\n& (element-wise AND)\n| (element-wise OR)\n! (logical NOT)\n\nThese operators compare vectors element by element:\n\na &lt;- c(3, 0, 9, -1, 0, 8, -2)\na &lt; 5 & a != 0    \n\n[1]  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE\n\na &lt; 3 | a &gt;= 8   \n\n[1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\nIn addition to the element-wise operators, R provides short-circuit logical operators:\n\n&& (short-circuit AND)\n|| (short-circuit OR)\n\nThese two operators evaluate expressions from left to right and stop as soon as the result is known. They are used primarily in control structures like if statements.\nImportant: Both && and || require each side to return a single logical value. Using them on vectors longer than one element will result in an error.\nThe following function uses a short-circuit && operator inside an if statement to ensure that the input is numeric and all values are positive before calculating square roots and logarithms:\n\nsqrt_log &lt;- function(x){\n  if (is.numeric(x) && min(x) &gt; 0){\n    x_sqrt &lt;- sqrt(x)\n    x_log &lt;- log(x)\n  } else {\n    x_sqrt &lt;- NA\n    x_log &lt;- NA\n  }\n  c(x_sqrt, x_log)\n}\n\nWhen the input meets the condition, the calculations proceed:\n\nsqrt_log(c(2,4,3))\n\n[1] 1.4142136 2.0000000 1.7320508 0.6931472 1.3862944 1.0986123\n\n\nIf not, the function returns NA values:\n\nsqrt_log(c(\"hello\"))\n\n[1] NA NA\n\n\nThis demonstrates how short-circuit logic can help ensure safe execution by checking multiple conditions before proceeding.\n\n\n5.4.3 Application: Print Customized Message\nWhen writing functions, it’s often helpful to provide feedback to users when inputs do not meet expectations. This can make functions easier to use and debug. There are several ways to communicate issues or guidance to users, depending on how severe the issue is and whether or not the function should continue running.\nstop(): Halt Execution with an Error Message\nUse the stop() function to terminate execution immediately when a critical condition is not met. This is useful when continuing the function could lead to incorrect results or unexpected behavior.\n\nsqrt_log &lt;- function(x){\n  if (is.numeric(x) && min(x) &gt; 0){\n    x_sqrt &lt;- sqrt(x)\n    x_log &lt;- log(x)\n  } else \n    stop (\"x must be a numeric vector with values &gt; 0.\")\n  c(x_sqrt, x_log)\n}\nsqrt_log(c(\"hello\"))\n\nError in sqrt_log(c(\"hello\")): x must be a numeric vector with values &gt; 0.\n\n\ncat(): Print a Message and Continue Execution\nThe cat() function can be used to print a message to the console without interrupting the flow of execution. You might use this when a non-critical issue arises but the function can still return a fallback result.\n\nsqrt_log &lt;- function(x){\n  if (is.numeric(x) && min(x) &gt; 0){\n    x_sqrt &lt;- sqrt(x)\n    x_log &lt;- log(x)\n  } else {\n    cat (\"x must be a numeric vector with values &gt; 0. \\n\")\n    x_sqrt &lt;- NA\n    x_log &lt;- NA\n  } \n  c(x_sqrt, x_log)\n}\nsqrt_log(c(\"hello\"))\n\nx must be a numeric vector with values &gt; 0. \n\n\n[1] NA NA\n\n\nwarning(): Signal a Warning but Continue Execution\nThe warning() function signals that something might be wrong, but it doesn’t stop execution. This is useful when the function can proceed, but the user should be alerted to a potential issue.\n\nsqrt_log &lt;- function(x){\n  if (is.numeric(x) && min(x) &gt; 0){\n    x_sqrt &lt;- sqrt(x)\n    x_log &lt;- log(x)\n  } else {\n    warning(\"x should be a numeric vector with values &gt; 0.\")\n    x_sqrt &lt;- NA\n    x_log &lt;- NA\n  } \n  c(x_sqrt, x_log)\n}\n\nsqrt_log(c(\"hello\"))  # Issues warning, returns NA\n\nWarning in sqrt_log(c(\"hello\")): x should be a numeric vector with values &gt; 0.\n\n\n[1] NA NA\n\n\nSummary\n\nUse stop() when the input is invalid and you want to halt the function.\nUse warning() when the input is questionable but the function can still proceed.\nUse cat() when you want to print a friendly message to the user without treating it as an error or warning.\n\n\n\n5.4.4 Application: The impute() Function\nTo avoid writing separate functions for numeric and character variables, we can combine both imputation tasks into a single function using conditional logic. The impute() function checks the variable type and then decides how to compute the replacement value. We also add a check to ensure the variable name is valid within the provided data frame.\nBefore defining the function, it’s a good idea to test the code line by line:\n\ndat &lt;- patient                  ## input data frame\nvar_name &lt;- \"HRT\"               ## name of the variable to impute\n\nif(!var_name %in% names(dat)){  ## check if var_name exists in dat\n  stop(var_name, \" is not in the given data\", \"\\n\")\n}\n\nselect_var &lt;- dat[[var_name]]   ## extract the variable from the data frame\n\nif(is.numeric(select_var)) {    ## if the variable is numeric...\n  replace_value &lt;- median(select_var, na.rm = TRUE)  ## compute the median\n} else {                        ## otherwise (e.g., character variable)...\n  tab_result &lt;- table(select_var)               ## create frequency table\n  high_freq &lt;- max(tab_result)                  ## find the max frequency\n  replace_value &lt;- names(tab_result)[tab_result == high_freq] \n                                                ## get most frequent value\n}\n\nselect_var[is.na(select_var)] &lt;- replace_value  ## replace missing values\ndat[[var_name]] &lt;- select_var                   ## update the original data\ndat                                             ## return the updated data\n\n   ID GLUC TGL HDL LDL HRT MAMM SMOKE\n1   A   88  NA  32  99   Y    Y     Y\n2   B   NA 150  60  NA   Y &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120   N    N     N\n4   D   NA 200  65 165   Y &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150   Y    Y     Y\n6   F   88  NA  32 210   Y &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA   Y    Y     Y\n8   H  110 170  70 188   Y &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190   N    N     N\n10  J   90  NA  75  NA   Y &lt;NA&gt;  &lt;NA&gt;\n\n\nOnce verified, we can wrap these steps into a reusable function:\n\nimpute &lt;- function(dat, var_name){\n  if(!var_name %in% names(dat)){\n    stop(var_name, \"is not in the given data\", \"\\n\")\n  }\n  select_var &lt;- dat[[var_name]]\n  if(is.numeric(select_var)) { \n    replace_value &lt;- median(select_var, na.rm=T)\n  } else{\n    tab_result &lt;- table(select_var)\n    high_freq &lt;- max(tab_result)\n    replace_value &lt;-names(tab_result)[tab_result == high_freq]\n  }\n  select_var[is.na(select_var)] &lt;- replace_value\n  dat[[var_name]] &lt;- select_var\n  dat\n}\nimpute(patient, \"HRT\")\n\n   ID GLUC TGL HDL LDL HRT MAMM SMOKE\n1   A   88  NA  32  99   Y    Y     Y\n2   B   NA 150  60  NA   Y &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120   N    N     N\n4   D   NA 200  65 165   Y &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150   Y    Y     Y\n6   F   88  NA  32 210   Y &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA   Y    Y     Y\n8   H  110 170  70 188   Y &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190   N    N     N\n10  J   90  NA  75  NA   Y &lt;NA&gt;  &lt;NA&gt;\n\nimpute(patient, \"GLUC\")\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88  NA  32  99    Y    Y     Y\n2   B   90 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120    N    N     N\n4   D   90 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88  NA  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   90 190  NA 190    N    N     N\n10  J   90  NA  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\n\n\n\n\n\nPeng, Roger D. 2020. R Programming for Data Science. Leanpub. https://bookdown.org/rdpeng/rprogdatascience/.\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023. R for Data Science. 2nd ed. O’Reilly Media. https://r4ds.hadley.nz/functions.html.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Writing User-Defined Functions</span>"
    ]
  },
  {
    "objectID": "iteration.html",
    "href": "iteration.html",
    "title": "6  Iteration",
    "section": "",
    "text": "6.1 Loops\nLoops allow you to perform the same operation multiple times, making them useful for automating repetitive tasks in R. While many tasks in R can be handled using vectorized functions, there are situations where loops offer more control and flexibility—especially when working with conditions, custom logic, or sequences of unknown length. In this section, we will focus on three types of loops in Base R: for, while, and repeat. Among them, the for loop is the most commonly used and is a good starting point for beginners. We will also revisit a practical example from the previous chapter to demonstrate how loops can make your code more efficient and adaptable.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "iteration.html#loops",
    "href": "iteration.html#loops",
    "title": "6  Iteration",
    "section": "",
    "text": "6.1.1 The for Loop\nA for loop allows you to repeat a task a specific number of times. This type of loop is most useful when the number of iterations is known ahead of time. Let’s use an example to walk through how a for loop is constructed.\nSuppose we have blood pressure and pulse measurements from several patients stored in a matrix called bp. Each column represents a different type of measurement—systolic pressure, diastolic pressure, and pulse rate.\n\nbp &lt;- cbind(\n  systolic  = c(120, 122, NA, 118, 130),\n  diastolic = c(80, 78, 85, 82, 79),\n  pulse     = c(70, 72, 68, 75, 71)\n)\n\nIf we want to calculate the mean value for each column, we could manually repeat the following commands:\n\nmean(bp[, 1], na.rm=T)  # systolic\n\n[1] 122.5\n\nmean(bp[, 2], na.rm=T)  # diastolic\n\n[1] 80.8\n\nmean(bp[, 3], na.rm=T)  # pulse\n\n[1] 71.2\n\n\nEach command is nearly identical except for the column index. In this situation, we can use a for loop to eliminate repetition and make the code more flexible.\nThree Components of a for Loop\nLet’s break the loop construction into three steps:\n1. Prepare a place to store the result\nSince we will compute one median per column, we need a numeric vector of the same length as the number of columns in bp. The numeric() function creates a numeric vector of the specified length.\n\noutput &lt;- numeric(3)\noutput\n\n[1] 0 0 0\n\n\nHowever, a more flexible version uses ncol(bp) so that the loop works even if the number of columns changes:\n\noutput &lt;- numeric(ncol(bp))\n\n2. Create a loop with an index variable\nTo repeat an operation three times—once for each column—we use a for loop. The index variable i will take on the values 1, 2, and 3 (ncol(bp)):\n\nfor (i in 1:ncol(bp)) {\n  ...\n}\n\n3. Write the loop body\nInside the loop, we want to compute the mean of the \\(i^{th}\\) column and store it in the \\(i^{th}\\) position of the output vector.\n\nfor (i in 1:ncol(bp)) {\n  output[i] &lt;- mean(bp[, i], na.rm=T)\n}\n\nFinal Code\nPutting it all together:\n\noutput &lt;- numeric(ncol(bp))\nfor (i in 1:ncol(bp)) {\n  output[i] &lt;- mean(bp[, i], na.rm=T)\n}\noutput\n\n[1] 122.5  80.8  71.2\n\n\nThis loop is functionally equivalent to:\n\noutput[1] &lt;- mean(bp[, 1], na.rm=T)\noutput[2] &lt;- mean(bp[, 2], na.rm=T)\noutput[3] &lt;- mean(bp[, 3], na.rm=T)\n\nUsing a loop avoids repetitive code and ensures your script remains flexible if the number of columns changes later.\n✻ Note: The structure of this example—first pre-allocating output, then defining the iteration sequence, and finally writing the loop body—is inspired by the clear and practical approach described in R for Data Science (Wickham, Çetinkaya-Rundel, and Grolemund 2023).\n\n\n6.1.2 More Examples of for Loops\nWhile the previous section focused on looping through columns of a matrix, we can also use for loops to process vectors, perform sequential comparisons, and work with lists. The following examples demonstrate how loops can be applied in various situations.\nIf you are unsure how to begin writing a loop, a good strategy is to first write out a few lines of code manually—without a loop—then identify the parts that repeat. This helps you recognize the pattern, making it easier to convert those lines into a loop structure. Each example below walks through this approach to reinforce the logic behind loop construction.\nIn the following example, we consider a list of sales figures from different stores. We want to calculate and report the average sales for each store. Let’s begin by creating the data:\n\nsales_data &lt;- list(\n  store_A = c(200, 250, 220),\n  store_B = c(300, 320, 310),\n  store_C = c(150, 180, 170)\n)\n\nTo calculate the average for each store without using a loop, we could write:\n\ncat(\"Average sales for store_A:\", mean(sales_data[[\"store_A\"]]), \"\\n\")\n\nAverage sales for store_A: 223.3333 \n\ncat(\"Average sales for store_B:\", mean(sales_data[[\"store_B\"]]), \"\\n\")\n\nAverage sales for store_B: 310 \n\ncat(\"Average sales for store_C:\", mean(sales_data[[\"store_C\"]]), \"\\n\")\n\nAverage sales for store_C: 166.6667 \n\n\nEach command follows the same structure: retrieve the sales vector by name, calculate the mean, and print the result. This kind of repetition is a good opportunity to switch to a loop.\nNow let’s write a for loop to handle the task more efficiently:\n\nfor (name in names(sales_data)) {\n  cat(\"Average sales for\", name, \":\", mean(sales_data[[name]]), \"\\n\")\n}\n\nAverage sales for store_A : 223.3333 \nAverage sales for store_B : 310 \nAverage sales for store_C : 166.6667 \n\n\nThe loop iterates over the names of the list elements. We are using the names of the list as the indexing sequence; at each iteration, the variable name is automatically assigned one of the list’s names (such as \"store_A\", \"store_B\", or \"store_C\"). It then retrieves the values associated with the current name using double square brackets ([[ ]]), computes the mean, and prints a message using cat(). This loop accomplishes the same result as before, but in a more compact and generalizable way.\nIn the following example, we are classifying a set of body temperature readings. If a temperature is 100.4°F or higher, we consider it “Fever”; otherwise, it is “Normal.”\nBefore jumping into a loop, one useful approach is to write out the steps manually for a few values. This helps clarify the pattern and logic:\n\nbody_temp &lt;- c(98.6, 101.2, 100.8, 98.7, 99.1)\nstatus &lt;- character(length(body_temp))\n\nif (body_temp[1] &gt;= 100.4) {\n  cat(body_temp[1], \": Fever\\n\")\n  status[1] &lt;- \"Fever\"\n} else {\n  cat(body_temp[1], \": Normal\\n\")\n  status[1] &lt;- \"Normal\"\n}\n\n98.6 : Normal\n\nif (body_temp[2] &gt;= 100.4) {\n  cat(body_temp[2], \": Fever\\n\")\n  status[2] &lt;- \"Fever\"\n} else {\n  cat(body_temp[2], \": Normal\\n\")\n  status[2] &lt;- \"Normal\"\n}\n\n101.2 : Fever\n\nif (body_temp[3] &gt;= 100.4) {\n  cat(body_temp[3], \": Fever\\n\")\n  status[3] &lt;- \"Fever\"\n} else {\n  cat(body_temp[3], \": Normal\\n\")\n  status[3] &lt;- \"Normal\"\n}\n\n100.8 : Fever\n\n\nThis approach becomes tedious and error-prone as the vector grows. Notice that only the index changes across each block. Once we recognize this repeating structure, we can rewrite the task using a for loop:\n\nbody_temp &lt;- c(98.6, 101.2, 100.8, 98.7, 99.1)\nstatus &lt;- character(length(body_temp))\nfor (i in seq_along(body_temp)) {\n  if (body_temp[i] &gt;= 100.4) {\n    cat(body_temp[i], \": Fever\\n\")\n    status[i] &lt;- \"Fever\"\n  } else {\n    cat(body_temp[i], \": Normal\\n\")\n    status[i] &lt;- \"Normal\"\n  }\n}\n\n98.6 : Normal\n101.2 : Fever\n100.8 : Fever\n98.7 : Normal\n99.1 : Normal\n\nstatus\n\n[1] \"Normal\" \"Fever\"  \"Fever\"  \"Normal\" \"Normal\"\n\n\nWe use seq_along(body_temp) rather than 1:length(body_temp) because it’s safer. If the input vector were ever empty, seq_along() would return an empty sequence, while 1:length(x) would return 1:0, which evaluates to c(1, 0)—an unexpected result that could cause bugs in your code.\nIn the next example, we will use the status vector we just created to detect how often a patient’s condition fluctuates over a series of temperature readings. Specifically, we want to count how many times the status changes from one reading to the next.\nA good way to approach this kind of problem is to begin by writing out a few comparisons manually, without using a loop. For example:\n\nstatus\n\n[1] \"Normal\" \"Fever\"  \"Fever\"  \"Normal\" \"Normal\"\n\nfluctuations &lt;- 0\nif (status[2] != status[1]) {\n  fluctuations &lt;- fluctuations + 1\n}\nif (status[3] != status[2]) {\n  fluctuations &lt;- fluctuations + 1\n}\nif (status[4] != status[3]) {\n  fluctuations &lt;- fluctuations + 1\n}\nif (status[5] != status[4]) {\n  fluctuations &lt;- fluctuations + 1\n}\nfluctuations\n\n[1] 2\n\n\nBy writing out these steps, we make the logic of the task explicit: each comparison checks whether the current status differs from the previous one, and if so, increments a counter. This repetition makes it a good candidate for a loop.\nWe can now rewrite the same logic using a for loop:\n\nfluctuations &lt;- 0\nfor (i in 2:length(status)) {\n  if (status[i] != status[i - 1]) {\n    fluctuations &lt;- fluctuations + 1\n  }\n}\nfluctuations\n\n[1] 2\n\n\nThis loop performs the same sequence of comparisons but in a more compact and scalable way. It also illustrates one of the strengths of loop structures: applying a repeated operation over a sequence of elements, especially when the current step depends on the previous one.\n\n\n6.1.3 Using while and repeat Loops\nIn many situations, we know ahead of time how many times a loop should run, which makes a for loop the natural choice. However, when the number of iterations is not known in advance, a while loop is more appropriate.\nA while loop consists of a condition and a body. The loop continues to run as long as the condition evaluates to TRUE, and this condition is checked at the beginning of each iteration:\n\nwhile (condition) {\n  ## code to execute\n}\n\nOne important difference between for and while loops is how the loop variable is controlled. In a forloop, the loop index is automatically incremented based on the sequence provided. In contrast, a while loop requires the programmer to explicitly manage the loop control — including setting up the condition and, if necessary, updating an index or accumulator variable within the loop body.\nIf you forget to increment the loop variable or define a proper stopping condition, the while loop may never terminate, resulting in an infinite loop. Therefore, it’s crucial to ensure that the condition will eventually become false to allow the loop to stop.\nSuppose we receive patient records in random order, and we want to search through them until we find the one with ID 1005.\n\npatient_ids &lt;- sample(1001:1010)  # randomly shuffled IDs\ni &lt;- 1\nwhile (patient_ids[i] != 1005) {\n  cat(\"Checked patient\", patient_ids[i], \"\\n\")\n  i &lt;- i + 1\n}\n\nChecked patient 1003 \nChecked patient 1010 \nChecked patient 1002 \nChecked patient 1008 \nChecked patient 1006 \nChecked patient 1009 \nChecked patient 1001 \nChecked patient 1007 \n\ncat(\"Found patient\", patient_ids[i], \"- stopping.\\n\")\n\nFound patient 1005 - stopping.\n\n\nIn this case, we do not know how many patients we’ll need to examine. The loop runs until we encounter the target ID. Note that the index variable i must be initialized before the loop and updated manually inside the loop body. Without this, the loop may never terminate. After the loop stops, which means we’ve found the ID, we should print it out to find out which one it is.\nAlthough any for loop can be rewritten as a while loop, the reverse is not true—some problems require while because the exit condition depends on dynamic logic, not a predefined sequence.\nWe can also mention two additional loop tools:\n\nThe repeat loop, which runs indefinitely until a break statement is encountered.\nThe break command, which can be used inside any loop to exit early when a condition is met.\n\nWe now revisit our earlier example using a while loop and show how the same task can be performed with a repeat loop. In this case, we continue scanning patient records until we find the one with ID 1005. The repeat loop provides a clean structure for this kind of task, especially when the number of iterations is not known in advance:\n\ni &lt;- 1\nrepeat {\n  if (patient_ids[i] == 1005) {\n    cat(\"Found patient\", patient_ids[i], \"- stopping.\\n\")\n    break\n  }\n  cat(\"Checked patient\", patient_ids[i], \"\\n\")\n  i &lt;- i + 1\n}\n\nChecked patient 1003 \nChecked patient 1010 \nChecked patient 1002 \nChecked patient 1008 \nChecked patient 1006 \nChecked patient 1009 \nChecked patient 1001 \nChecked patient 1007 \nFound patient 1005 - stopping.\n\n\nThis approach ensures the desired output is printed inside the loop, right when the match is found.\nWhile some programmers advise against using break because it interrupts the normal flow and may make the logic harder to trace in complex programs, it is entirely appropriate for small, well-structured search tasks like this one—especially when it improves clarity and reduces unnecessary control logic.\nThese tools are not commonly required for routine data analysis, so we will not explore them further here.\n\n\n6.1.4 Rewriting the impute() Function with a Loop\nIn the previous chapter, we introduced the impute() function, which handled missing values for a single variable at a time. However, when multiple variables require imputation, repeating the same function call is inefficient. A loop allows us to process all specified variables in one pass, making the function more flexible and scalable.\nTo rewrite the function, we start with defining the sequence of variables to loop over—here. We use a character vector called var_list that contains the names of the variables to impute. Then, we set up the for loop using seq_along(var_list) to generate the index. Finally, we write the loop body to apply the imputation logic to each variable in turn.\nAt the beginning of the loop, we extract the name of the current variable using var_name &lt;- var_list[i], and then proceed with the imputation logic used previously. After filling in the missing values, we update the column in the original dataset.\nHere is the final version of the function:\n\nimpute_N &lt;- function(dat, var_list){\n  for (i in seq_along(var_list)){\n    var_name &lt;- var_list[i]\n    select_var &lt;- dat[[var_name]]\n    if(is.numeric(select_var)) {\n      replace_value &lt;- median(select_var, na.rm=T)\n    } else{\n      tab_result &lt;- table(select_var)\n      high_freq &lt;- max(tab_result)\n      replace_value &lt;-names(tab_result)[tab_result == high_freq]\n    }\n    select_var[is.na(select_var)] &lt;- replace_value\n    dat[[var_name]] &lt;- select_var\n  }\n  dat\n}\n\nTo apply the function, we pass both the dataset and a character vector of variable names to be imputed:\n\nimpute_N(patient, c(\"TGL\", \"HDL\", \"LDL\", \"HRT\", \"MAMM\"))\n\n   ID GLUC TGL  HDL LDL HRT MAMM SMOKE\n1   A   88 180 32.0  99   Y    Y     Y\n2   B   NA 150 60.0 165   Y    Y  &lt;NA&gt;\n3   C  110 180 62.5 120   N    N     N\n4   D   NA 200 65.0 165   Y    Y  &lt;NA&gt;\n5   E   90 210 62.5 150   Y    Y     Y\n6   F   88 180 32.0 210   Y    Y  &lt;NA&gt;\n7   G  120 164 62.5 165   Y    Y     Y\n8   H  110 170 70.0 188   Y    Y  &lt;NA&gt;\n9   I   NA 190 62.5 190   N    N     N\n10  J   90 180 75.0 165   Y    Y  &lt;NA&gt;\n\n\nThis version of the impute() function can handle any number of variables and illustrates how a for loop can help automate repetitive tasks in a structured and reliable way.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "iteration.html#efficient-repetition-with-apply-type-functions",
    "href": "iteration.html#efficient-repetition-with-apply-type-functions",
    "title": "6  Iteration",
    "section": "6.2 Efficient Repetition with “Apply-type” Functions",
    "text": "6.2 Efficient Repetition with “Apply-type” Functions\nMany data analysis tasks involve performing the same computation repeatedly across different parts of a data structure—such as rows of a matrix, columns of a data frame, or elements of a list. While loops can be used for such repetition, R provides a set of vectorized tools called apply-type functions that often make code shorter, faster, and more expressive. The table below summarizes the most commonly used apply-type functions and highlights their typical inputs and outputs:\n\n\n\n\n\n\n\n\n\n\nFunction\nInput Type\nApplies Function To\nOutput Type\nNotes\n\n\n\n\napply()\nMatrix or data frame\nRows (1), Columns (2), or both\nVector, matrix, or list\nOften used for row/column operations\n\n\nlapply()\nVector, list or data frame\nEach element\nList\nAlways returns a list\n\n\nsapply()\nVector, list or data frame\nEach element\nSimplified result\nTries to simplify (e.g., to vector or matrix)\n\n\nvapply()\nVector or List\nEach element\nPre-specified format\nSafer, but more verbose than sapply()\n\n\ntapply()\nVector\nGroups defined by factor(s)\nArray or vector\nUsed for grouped summary statistics\n\n\nmapply()\nMultiple vectors\nElements in parallel\nList or simplified\nMultivariate version of sapply()\n\n\nMap()\nMultiple vectors\nElements in parallel\nList\nSimilar to mapply(), but returns a list always\n\n\nreplicate()\nExpression\nRepeated evaluation\nVector, matrix, or list\nUseful for simulation or bootstrapping\n\n\n\nNote: The functions mapply(), Map(), and replicate() are not covered in this chapter. You are encouraged to explore their usage by reading the official R documentation if you’re interested.\n\n6.2.1 Anonymous Functions\nBefore we learn how to use apply-type functions, let’s take a moment to understand anonymous functions, which are often used together with these tools.\nAn anonymous function is simply a function that does not have a name. Instead of assigning it to an object, we define and use it on the fly—typically for one-time or short-term use. This can be helpful when the function is simple and doesn’t need to be reused elsewhere.\nHere is the traditional syntax for writing a simple function:\n\ndouble &lt;- function(x) 2 * x\ndouble(10)\n\n[1] 20\n\n\nNote that we did not use curly braces since the function body contains only a single command. Now, we can define the same logic anonymously, without assigning the function to a name:\n\n(function(x) 2 * x)(10)\n\n[1] 20\n\n\nThis creates the function and immediately applies it to the value 10. The function works the same way because the named function double on the left-hand side of the assignment operator (&lt;-) is equivalent to everything on the right: function(x) 2 * x.\nStarting with R version 4.1.0, a new and more compact syntax was introduced: we can replace the keyword function with a backslash (\\). For example:\n\ndouble &lt;- \\(x) 2 * x\ndouble(10)\n\n[1] 20\n\n\nThis shorthand notation is especially useful when writing anonymous functions inline:\n\n(\\(x) 2 * x) (10)\n\n[1] 20\n\n\nAnonymous functions can also contain multiple statements by wrapping the body in curly braces. For example, here’s a function that prints a number, doubles it, and then returns the result:\n\n(\\(x) {\n  cat(\"Input value is:\", x, \"\\n\")\n  2 * x\n})(7)\n\nInput value is: 7 \n\n\n[1] 14\n\n\nAlthough short, one-line anonymous functions are more common, it’s good to know that multi-step logic can be included when needed.\n\n\n6.2.2 Apply to Matrices\nR provides several built-in functions for computing summary statistics across the rows or columns of a matrix, including rowSums(), rowMeans(), colSums(), and colMeans(). However, for more flexible and general-purpose operations, the apply() function is a powerful tool.\nThe apply() function takes the following arguments:\n\nX: a matrix or an array.\nMARGIN: an integer indicating the dimension(s) to apply the function over. Use 1 for rows, 2 for columns\nFUN: a function (either built-in or user-defined) to apply to each row or column.\n...: additional arguments to be passed to the function specified in FUN.\n\nThe result returned by apply() is typically a vector or matrix, depending on the output of the function and the margin specified.\nLet’s revisit our blood pressure matrix example:\n\nbp \n\n     systolic diastolic pulse\n[1,]      120        80    70\n[2,]      122        78    72\n[3,]       NA        85    68\n[4,]      118        82    75\n[5,]      130        79    71\n\n\nWhen we run:\n\napply(bp, 2, mean)\n\n systolic diastolic     pulse \n       NA      80.8      71.2 \n\n\nwe are instructing R to compute the median for each column of the matrix. Internally, the apply() function loops through the matrix column by column, passing each column (as a vector) into the mean() function. Similarly, if we want to compute the mean for each row:\n\napply(bp, 1, mean)\n\n[1] 90.00000 90.66667       NA 91.66667 93.33333\n\n\nthis time, each row is treated as the input to mean(). In both cases, apply() eliminates the need to write out a manual loop.\nBy default, mean() will return NA if any value is missing. To handle this, we need to specify the optional argument na.rm = TRUE. This additional argument is written in the form of parameter = value and placed after the function name:\n\napply(bp, 2, mean, na.rm = TRUE)\n\n systolic diastolic     pulse \n    122.5      80.8      71.2 \n\n\nThe optional arguments na.rm = TRUE are passed along directly to mean(). You can include as many optional arguments as needed. For example:\n\napply(bp, 2, mean, na.rm = TRUE, trim = 0.25)\n\n systolic diastolic     pulse \n121.00000  80.33333  71.00000 \n\n\n\n\n6.2.3 Applying to a List or a Vector\nMost R functions are designed to work element-by-element on vectors. However, these same functions do not always work directly on lists. To address this, R provides a family of apply-type functions specifically designed for iterating over the elements of a list or vector. The most commonly used ones are lapply(), sapply(), and vapply().\nThese functions share a similar interface:\n\nX: a vector or a list.\nFUN: a function to be applied to each element.\nFUN.VALUE: (for vapply() only) — a template that shows what kind of output you expect from the function. It helps R know exactly what type and length of result should come from each element. For example, FUN.VALUE = numeric(1) tells R that each result should be a single number.\n...: optional arguments passed to FUN.\n\nlapply() vs sapply()\nThe difference lies in what they return:\n\nlapply() always returns a list, regardless of the output of the applied function.\nsapply() tries to simplify the result to a vector, or matrix if possible. If not, it falls back to a list.\n\nLet’s walk through an example. Suppose we have a list where each element is a numeric vector. We want to calculate the mean of each component:\n\na &lt;- list(a = rnorm(20, 3, 4), \n          b = rnorm(10, 5, 2),\n          c = c(rnorm(15, 2, 1), NA))\nlapply(a, mean, na.rm = T)\n\n$a\n[1] 3.762096\n\n$b\n[1] 4.732654\n\n$c\n[1] 2.090286\n\nsapply(a, mean, na.rm = T)\n\n       a        b        c \n3.762096 4.732654 2.090286 \n\n\nNotice that the sapply() function above simplifies the result into a vector, whereas the lapply() function returns a list as the result.\nUsing Custom or Anonymous Functions\nYou are not limited to built-in functions. You can also apply your own:\n\nmean_sd &lt;- function(x){\n  c(MEAN = mean(x, na.rm = T), SD = sd(x, na.rm = T))\n}\nlapply(a, mean_sd)\n\n$a\n    MEAN       SD \n3.762096 3.653015 \n\n$b\n    MEAN       SD \n4.732654 1.911215 \n\n$c\n    MEAN       SD \n2.090286 0.720553 \n\n\nOr define the function inline using an anonymous function:\n\nsapply(a, function(x) {\n  c(MEAN = mean(x, na.rm = TRUE), SD = sd(x, na.rm = TRUE))\n})\n\n            a        b        c\nMEAN 3.762096 4.732654 2.090286\nSD   3.653015 1.911215 0.720553\n\n\nOr use the new function notation by typing the following:\n\nsapply(a, \\(x) {\n  c(MEAN = mean(x, na.rm = TRUE), SD = sd(x, na.rm = TRUE))\n})\n\n            a        b        c\nMEAN 3.762096 4.732654 2.090286\nSD   3.653015 1.911215 0.720553\n\n\nA Safer Alternative: vapply()\nWhile sapply() is convenient, it can be unpredictable in what it returns. This is where vapply() comes in—it requires you to specify the exact structure of the output, making the result more stable and safer to use in programming.\nFor example, if we know that the result should always be a single numeric value, we can use:\n\nvapply(a, mean, numeric(1), na.rm = TRUE)\n\n       a        b        c \n3.762096 4.732654 2.090286 \n\n\nIf each function call returns a vector of two named values, we can specify:\n\nvapply(a, \\(x) c(MEAN = mean(x, na.rm = TRUE), \n                        SD = sd(x, na.rm = TRUE)), \n       numeric(2))\n\n            a        b        c\nMEAN 3.762096 4.732654 2.090286\nSD   3.653015 1.911215 0.720553\n\n\nSpecifying the expected result type with numeric(2) ensures consistent output and helps catch errors early.\nLists vs Data Frames\nRemember that data frames are actually lists of equal-length vectors. This means we can apply these same functions to each column of a data frame.\n\nd &lt;- data.frame(\n  var1 = c(1, 3, 7),\n  var2 = c(3, 5, 10)\n)\n\napply(d, 2, sum)            # Treats data frame as matrix\n\nvar1 var2 \n  11   18 \n\nsapply(d, sum)              # Treats columns as list elements\n\nvar1 var2 \n  11   18 \n\nlapply(d, sum)              # Same, but returns a list\n\n$var1\n[1] 11\n\n$var2\n[1] 18\n\nvapply(d, sum, numeric(1))  # Safe version, ensures numeric output\n\nvar1 var2 \n  11   18 \n\n\nIn general:\n\nUse lapply() when you want list output.\nUse sapply() when you want a simplified output (but are okay with some risk).\nUse vapply() when you want strict control over the return type.\n\n\n\n6.2.4 Applying to Grouped Data\nThe tapply() function is designed to apply a function to subsets of a vector, where the subsets are defined by the levels of one or more categorical variables (factors). This is especially useful when you want to compute summary statistics within groups.\nHere are the key arguments of the tapply() function:\n\nX: A numeric (or character) vector containing the values to be operated on.\nINDEX: A factor or list of factors that defines the grouping. Each unique combination of factor levels determines one subset of X.\nFUN: The function to apply to each group.\n...: Additional arguments passed to FUN.\n\nWe will use the quine data frame from the MASS package to illustrate how tapply() works. This dataset includes information about school absences among children in Walgett, New South Wales, Australia. The Days column records the number of days a student was absent during the school year, and other columns classify students by Ethnicity (Eth), Age, Sex, and Learner status (Lrn).\n\nlibrary(MASS)\nhead(quine)\n\n  Eth Sex Age Lrn Days\n1   A   M  F0  SL    2\n2   A   M  F0  SL   11\n3   A   M  F0  SL   14\n4   A   M  F0  AL    5\n5   A   M  F0  AL    5\n6   A   M  F0  AL   13\n\n\nApplying tapply() with a Single Grouping Variable\nSuppose we want to calculate the mean number of days absent for each age group. We can do this by grouping quine$Days by quine$Age:\n\ntapply(quine$Days, quine$Age, mean)\n\n      F0       F1       F2       F3 \n14.85185 11.15217 21.05000 19.60606 \n\n\nThis returns the average number of days absent for each level of the Age factor.\nApplying tapply() with Multiple Grouping Variables\nWe can also apply a function across multiple grouping variables by passing a list of factors to the INDEX argument. For example, to compute the mean number of days absent by both Age and Sex:\n\ntapply(quine$Days, list(quine$Age, quine$Sex), mean)\n\n          F        M\nF0 18.70000 12.58824\nF1 12.96875  7.00000\nF2 18.42105 23.42857\nF3 14.00000 27.21429\n\n\nThis produces a table where each cell shows the average number of days absent for a specific combination of Age and Sex.\nWhen using multiple grouping variables, tapply() outputs a matrix-like structure (if possible) that makes cross-group comparisons easier.\nSplitting the Data\nSometimes, it’s more convenient to split the data into a list and then apply operations to each component using lapply() or sapply(). The split() function divides a data vector or a data frame based on one or more grouping factors. Its two primary arguments are:\n\nx: a vector or a data frame to be split.\nf: a factor (or list of factors) used to define the groups.\n\nThe result is a list, where each element corresponds to one level (or combination of levels) of the grouping factor(s).\nWhile the tapply() function offers a compact way to apply a function across groups, the split() + sapply() (or lapply()) approach offers greater flexibility, especially when you want to perform multiple operations on each group.\nFor example, to compute the mean number of days absent for each Age group in the quine dataset, we can first split the Days variable:\n\nDays_by_Age &lt;- split(quine$Days, quine$Age)\nDays_by_Age\n\n$F0\n [1]  2 11 14  5  5 13 20 22  3  5 11 24 45  6 17 67  0  0  2  7 11 12 25 10 11\n[26] 20 33\n\n$F1\n [1]  6  6 15  7 14  5  6  6  9 13 23 25 32 53 54  5  5 11 17 19  0  0  5  5  5\n[26] 11 17  3  4  5  7  0  1  5  5  5  5  7 11 15  5 14  6  6  7 28\n\n$F2\n [1]  6 32 53 57 14 16 16 17 40 43 46  8 13 14 20 47 48 60 81  2 22 30 36  8  0\n[26]  1  5  7 16 27  0  5 14  2  2  3  8 10 12  1\n\n$F3\n [1]  8 23 23 28 34 36 38  0  2  3  5 10 14 21 36 40  0 30 10 14 27 41 69  1  9\n[26] 22  3  3  5 15 18 22 37\n\n\nNow that we have a list, we can easily apply a function to each element:\n\nsapply(Days_by_Age, mean)\n\n      F0       F1       F2       F3 \n14.85185 11.15217 21.05000 19.60606 \n\n\nThis produces the same result as tapply(), but in a format that may be easier to extend or customize.\nWe can also perform multiple calculations per group. For example, to compute both the mean and the median:\n\nsapply(split(quine$Days, quine$Age), \n       \\(x){\n         c(Mean = mean(x), Median = median(x))\n       }\n)\n\n             F0       F1    F2       F3\nMean   14.85185 11.15217 21.05 19.60606\nMedian 11.00000  6.00000 14.00 18.00000\n\n\nTo group by more than one factor—say, both Age and Sex—we can pass a list of factors to split():\n\nsapply(split(quine$Days, list(quine$Age, quine$Sex)),\n       \\(x) {\n         c(Mean = mean(x), Median = median(x))\n       }\n)\n\n       F0.F     F1.F     F2.F F3.F     F0.M F1.M     F2.M     F3.M\nMean   18.7 12.96875 18.42105   14 12.58824  7.0 23.42857 27.21429\nMedian 15.5  7.00000 10.00000   10 11.00000  5.5 17.00000 27.50000\n\n\nThis approach is especially powerful when used with anonymous functions. It allows us to write concise, flexible code that can be adapted to a wide range of grouped operations.\nWhy Prefer split() with sapply()?\nAlthough tapply() is convenient for computing a single summary statistic per group, it becomes less manageable when:\n\nmore than one grouping factor is used, and\nthe applied function returns multiple values (e.g., mean and median).\n\nConsider the following example:\n\ntapply(quine$Days, list(quine$Age, quine$Sex), \\(x) {\n  c(Mean = mean(x), Median = median(x))\n})\n\n   F         M        \nF0 numeric,2 numeric,2\nF1 numeric,2 numeric,2\nF2 numeric,2 numeric,2\nF3 numeric,2 numeric,2\n\n\nThis returns a matrix-like object where each cell contains a vector of length two.\nWhile technically correct, this result can be cumbersome to work with, especially if you’re trying to extract or manipulate specific summary values later on.\nIn contrast, the combination of split() and sapply() provides more predictable and structured output, typically in the form of a named matrix or list. This makes it easier to interpret and use in subsequent steps of your analysis.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "iteration.html#when-to-use-loops-apply-type-functions-or-vectorized-calculations",
    "href": "iteration.html#when-to-use-loops-apply-type-functions-or-vectorized-calculations",
    "title": "6  Iteration",
    "section": "6.3 When to Use Loops, Apply-Type Functions, or Vectorized Calculations",
    "text": "6.3 When to Use Loops, Apply-Type Functions, or Vectorized Calculations\nIn R, you’ll often find that a task can be solved in several different ways. The three most common approaches are:\n\nUsing loops (for, while, or repeat)\nUsing apply-type functions (like apply(), lapply(), sapply(), tapply(), vapply())\nUsing vectorized operations (like mean(), sum(), ifelse(), colMeans(), and arithmetic on entire vectors)\n\nUnderstanding the strengths and use cases of each will help you write clearer and more efficient R code.\nWhen to Use Loops\nLoops give you full control over each step of a process. They’re ideal when:\n\nEach step depends on the result of the previous one. Example: tracking a running total or detecting state transitions in a time series\nYou need to perform a custom sequence of actions. Example: printing different messages, updating external variables\nThe logic is complex or has conditional branching. Example: applying different formulas based on user input or specific criteria\nYou are prototyping or still learning the logic. Loops are easy to read and good for step-by-step debugging\n\nHowever, a common downside of loops is that the result is often embedded inside the loop, such as being updated step by step. This can make it harder for others (or even yourself later) to figure out what the loop is producing unless they read through the whole body.\nWhen to Use Apply-Type Functions\nApply-type functions offer a middle ground between loops and vectorized code. They let you repeat an operation over elements of a list, matrix, or grouped data, often in fewer lines than a loop.\n\nUse apply() for rows or columns of a matrix\nUse lapply() or sapply() for elements in a list or columns in a data frame\nUse vapply() when you want to enforce the type and length of the result\nUse tapply() or split() + sapply() to summarize values by groups\n\nThese functions are especially useful when:\n\nThe task is repetitive and follows a predictable pattern\nYou want cleaner code without writing an explicit loop\nYou’re applying the same function to multiple elements or groups\n\nApply-type functions also work well with anonymous functions, such as \\(x) x^2, making them ideal for short, one-time logic.\nWhen to Use Vectorized Calculations\nVectorized operations are fast, expressive, and concise. Whenever your logic can be expressed as an operation on entire vectors, this is the preferred route.\nUse vectorized functions when:\n\nYou’re applying the same simple transformation to every element\nYou are classifying, summarizing, or transforming numeric or logical vectors\nBuilt-in functions already exist for the task (e.g., mean(), sum(), ifelse())\n\nVectorized code is usually more efficient because it’s executed in compiled C code under the hood. Examples:\n\nvalues &lt;- c(1, 10, 100, 1000)\nlog(values)  # Vectorized log transformation\n\n[1] 0.000000 2.302585 4.605170 6.907755\n\n\nIn general, start with loops when you’re developing or learning, then refactor using apply-type or vectorized solutions for clarity and performance. Prefer apply-type functions when you want a readable result that’s clearly assigned, rather than hidden inside the loop body.\n\n\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023. R for Data Science. 2nd ed. O’Reilly Media. https://r4ds.hadley.nz/functions.html.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "manipulations.html",
    "href": "manipulations.html",
    "title": "7  Data Manipulations",
    "section": "",
    "text": "7.1 Creating and Re-coding Variables\nCreating a new variable based on an existing one is a common task in data manipulation. You can add a new variable to an existing data frame using either the dollar sign ($) or square brackets ([ or [[). For example:\nd &lt;- data.frame(\n  a = 1:4,\n  b = 5:8\n)\nd$c &lt;- d$a + d$b             # using $ to add a new column\nd[\"d\"] &lt;- d[[\"a\"]] + 2       # using [ and [[ to add a new column\nd[[\"e\"]] &lt;- log(d[[\"b\"]])    \nd\n\n  a b  c d        e\n1 1 5  6 3 1.609438\n2 2 6  8 4 1.791759\n3 3 7 10 5 1.945910\n4 4 8 12 6 2.079442\nThis yields the data frame with the new variables c , d , and e added as combinations or transformations of the original columns.\nIn practice, creating new variables often goes hand-in-hand with recoding or transforming existing variables. Below, we explore several methods for creating or recoding variables in base R.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data Manipulations</span>"
    ]
  },
  {
    "objectID": "manipulations.html#creating-and-re-coding-variables",
    "href": "manipulations.html#creating-and-re-coding-variables",
    "title": "7  Data Manipulations",
    "section": "",
    "text": "7.1.1 Creating Variables Using Relational Operators\nWe often create indicator variables based on existing continuous or categorical variables, usually for modeling purposes or to present data differently. These indicators typically take values of 1 or 0 (or are represented as logical TRUE / FALSE values). They are easily created using relational operators. When comparing a variable with a value, the result is a logical vector of TRUE or FALSE. If we want the result as numeric values 1 and 0, we can wrap the expression in as.integer() to convert the logicals to 1/0.\nFor example, using the painters dataset from the MASS package, suppose we want to create a logical indicator variable showing whether each painter’s Drawing score is above or below the mean of all painters’Drawing scores. We can do this with the following commands:\n\nlibrary(MASS)\npainters$Drawing_ind &lt;- painters$Drawing &gt;= mean(painters$Drawing)\nhead(painters[, c(\"Drawing\", \"Drawing_ind\")])\n\n              Drawing Drawing_ind\nDa Udine            8       FALSE\nDa Vinci           16        TRUE\nDel Piombo         13        TRUE\nDel Sarto          16        TRUE\nFr. Penni          15        TRUE\nGuilio Romano      16        TRUE\n\n\nThe commands above add a new column Drawing_ind that is TRUE if the painter’s Drawing score is above the mean, and FALSE otherwise.\nWe can similarly use relational operators to create an ordinal categorical variable with more than two levels. For instance, suppose we want to create a new variable Comp_ord based on the painters’ Composition score with the following rules:\n\nIf Composition &lt; 8, assign Comp_ord = 1\nIf 8 \\(\\ge\\) Composition &lt; 12, assign Comp_ord = 2\nIf Composition \\(\\ge\\) 12, assign Comp_ord = 3\n\nWe can achieve this by exploiting the fact that logical comparisons in R can be coerced to 1/0 values. One concise method is:\n\npainters$Comp_ord &lt;- 1 +\n  (painters$Composition &gt;= 8) +\n  (painters$Composition &gt;= 12)\nhead(painters[, c(\"Composition\", \"Comp_ord\")])\n\n              Composition Comp_ord\nDa Udine               10        2\nDa Vinci               15        3\nDel Piombo              8        2\nDel Sarto              12        3\nFr. Penni               0        1\nGuilio Romano          15        3\n\n\nThe logic here is that the expression adds 1 for each threshold passed. All observations start at 1 (the lowest category). If Composition \\(\\ge\\) 8 , we add 1 (making it 2 for those cases). If Composition \\(\\ge\\) 12 , we add another 1 (making it 3 for those cases that exceed both thresholds).\nIt’s good practice to verify that the newly created variable is correct. One way to check Comp_ord is by using the tapply() function to compute the minimum and maximum Composition within each category of Comp_ord:\n\ntapply(painters$Composition, painters$Comp_ord, min)\n\n 1  2  3 \n 0  8 12 \n\ntapply(painters$Composition, painters$Comp_ord, max)\n\n 1  2  3 \n 6 11 18 \n\n\nThis should confirm that for Comp_ord category 1, Composition ranges 0–7; for category 2, 8–11; and for category 3, 12–18, matching our intended cut-offs.\n\n\n7.1.2 Creating Variables Using ifelse()\nThe ifelse() function is a vectorized conditional function handy for creating indicator, ordinal, or categorical variables. It has the form ifelse(test, yes, no) , where test is a logical condition, yes is the value to return for observations where the test is TRUE, and no is the value to return where the test is FALSE. The value returned by ifelse() will have the same length as the test vector, with each element filled by either the yes or no value depending on the condition(Matloff 2011).\nFor instance, consider again the painters data frame. The School variable in this dataset is a factor with levels A, B, C, D, E, F, G, H (denoting which art school each painter belonged to). Suppose we want to create a binary variable School2 which equals 1 if the school is A, B, or C, and 2 otherwise. We can use ifelse() with the %in% operator for this set membership test:\n\nSchool2 &lt;- ifelse(painters$School %in% c(\"A\",\"B\",\"C\"), 1, 2)\ntable(School2, painters$School)\n\n       \nSchool2  A  B  C  D  E  F  G  H\n      1 10  6  6  0  0  0  0  0\n      2  0  0  0 10  7  4  7  4\n\n\nThe table above will show that for schools A, B, C we have School2 = 1, and for the others it’s 2.\nWe can also nest ifelse() statements to create variables with more than two categories. Continuing the example above, suppose we want to create School3 such that: A/B/C map to 1, D/E map to 2, and F/G/H map to 3. We can nest a second ifelse() inside the first:\n\nSchool3 &lt;- ifelse(painters$School %in% c(\"A\",\"B\",\"C\"), 1,\n                  ifelse(painters$School %in% c(\"D\",\"E\"), 2, 3))\ntable(School3, painters$School)\n\n       \nSchool3  A  B  C  D  E  F  G  H\n      1 10  6  6  0  0  0  0  0\n      2  0  0  0 10  7  0  0  0\n      3  0  0  0  0  0  4  7  4\n\n\nWe see School3 assigns 1 to A/B/C, 2 to D/E, and 3 to F/G/H as intended.\n\n\n7.1.3 Creating Factors Using the cut() Function\nIn statistical analysis, it’s often useful to convert a continuous variable into a categorical factor by binning its values into intervals. The base R function cut() is designed for this purpose. The cut() function takes a numeric vector and converts it into a factor by dividing the range of the data into intervals (bins) and assigning each value to a bin.\nKey arguments of cut() include:\n\nx : the numeric vector to be binned.\nbreaks : a numeric vector of cut points (of length n+1 if you want n intervals), or a single number giving the number of intervals to cut x into.\nlabels : an optional vector of labels for the resulting factor levels. If not provided, cut will by default label the intervals like (a,b] (using parentheses for open intervals and brackets for closed intervals).\ninclude.lowest : logical, indicating if the lowest (first) interval should be closed on the left. By default the intervals are left-open, right-closed; setting include.lowest=TRUE will include the minimum value of x in the first interval (making it [a,b] for the first interval).\nright : logical for whether intervals should be closed on the right (and open on the left) or vice versa. The default right=TRUE means intervals like (a,b] ; if FALSE , you get [a,b) style.\n\nAs an example, suppose we want to categorize the painters’ Colour score into four groups representing quartiles (i.e., 0–25th percentile, 25–50th, 50–75th, 75–100th). We can do this by first finding the quartile cut points and then using cut():\n\nqt &lt;- quantile(painters$Colour, probs = c(0, 0.25, 0.5, 0.75, 1))\nqt\n\n   0%   25%   50%   75%  100% \n 0.00  7.25 10.00 16.00 18.00 \n\n\nNow use these as breakpoints:\n\npainters$ColourCat &lt;- cut(painters$Colour, \n                          breaks = qt,\n                          labels =  c(\"first\",\"second\",\"third\",\"fourth\"),\n                          include.lowest = TRUE)\ntable(painters$ColourCat)\n\n\n first second  third fourth \n    14     15     18      7 \n\n\nHere “first” corresponds to the lowest quarter of Colour values, and “fourth” the highest quarter. We set include.lowest = TRUE so that the minimum value (0 in this case) is included in the lowest interval.\nUsing cut() in this way allows us to introduce non-linear relationships or categorical distinctions into models (for example, using quartiles instead of a continuous variable) and to better interpret continuous variables by grouping their values into meaningful categories.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data Manipulations</span>"
    ]
  },
  {
    "objectID": "manipulations.html#handling-data-with-duplicated-elements",
    "href": "manipulations.html#handling-data-with-duplicated-elements",
    "title": "7  Data Manipulations",
    "section": "7.2 Handling Data with Duplicated Elements",
    "text": "7.2 Handling Data with Duplicated Elements\nData often contain duplicate records, which may occur intentionally or as errors (for instance, through data entry mistakes or merging datasets). Identifying and handling duplicates is typically part of data cleaning. Base R provides functions to detect and manage duplicates in vectors, matrices, and data frames.\n\n7.2.1 Duplicated Elements in Vectors\nFor vectors, the unique() function returns a vector of the distinct values. The companion function duplicated() returns a logical vector the same length as the input, indicating for each position whether that element is a duplicate of an earlier element. Both functions have an argument fromLast which, if set to TRUE, considers duplication from the reverse direction (this affects which element is considered the “first” occurrence).\n\nv &lt;- c(letters[1:4], \"d\", \"a\")\nv\n\n[1] \"a\" \"b\" \"c\" \"d\" \"d\" \"a\"\n\nunique(v)\n\n[1] \"a\" \"b\" \"c\" \"d\"\n\nunique(v, fromLast = TRUE)\n\n[1] \"b\" \"c\" \"d\" \"a\"\n\n\nHere unique(v) kept the first occurrence of each letter (so we see \"a\" from position 1, not the \"a\" from the end), whereas unique(v, fromLast=TRUE) kept the last occurrence of each duplicate (so it retained the \"a\" from the end and dropped the earlier one).\nNow check duplicated(v):\n\nduplicated(v)\n\n[1] FALSE FALSE FALSE FALSE  TRUE  TRUE\n\nduplicated(v, fromLast = TRUE)\n\n[1]  TRUE FALSE FALSE  TRUE FALSE FALSE\n\n\nIn the first output, the fifth element (\"d\") and sixth element (\"a\") are marked TRUE because they are duplicates of earlier elements in the vector. In the second output (fromLast=TRUE), it’s the first element \"a\" and fourth element \"d\" that are marked TRUE (because from the reverse direction, those become the “duplicate” instances).\nIf our goal is to extract only the unique values from a vector, we can use !duplicated() as a filtering index:\n\nv[!duplicated(v)]\n\n[1] \"a\" \"b\" \"c\" \"d\"\n\nv[!duplicated(v, fromLast = TRUE)]\n\n[1] \"b\" \"c\" \"d\" \"a\"\n\n\nThe first line returns the first occurrences of each unique value (same as unique(v)), while the second returns the last occurrences of each unique value.\n\n\n7.2.2 Duplicated Rows or Columns in Matrices\nThe concepts of unique() and duplicated() extend to matrices as well, working by rows (the default, MARGIN = 1). The unique() function will return a matrix with duplicate rows removed, and duplicated() will return a logical vector flagging duplicate rows. For example:\n\nmat &lt;- matrix(\n  c(rep(\"c\", 3), \"d\", \"c\", \n    rep(c(\"a\",\"b\",\"c\",\"c\",\"c\"), 2),\n    letters[1:3], \"d\", \"c\",\n    rep(\"c\", 5), letters[1:3], \"c\", \"c\"),\n  ncol = 5, byrow = TRUE\n)\nmat\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"c\"  \"c\"  \"c\"  \"d\"  \"c\" \n[2,] \"a\"  \"b\"  \"c\"  \"c\"  \"c\" \n[3,] \"a\"  \"b\"  \"c\"  \"c\"  \"c\" \n[4,] \"a\"  \"b\"  \"c\"  \"d\"  \"c\" \n[5,] \"c\"  \"c\"  \"c\"  \"c\"  \"c\" \n[6,] \"a\"  \"b\"  \"c\"  \"c\"  \"c\" \n\nunique(mat)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"c\"  \"c\"  \"c\"  \"d\"  \"c\" \n[2,] \"a\"  \"b\"  \"c\"  \"c\"  \"c\" \n[3,] \"a\"  \"b\"  \"c\"  \"d\"  \"c\" \n[4,] \"c\"  \"c\"  \"c\"  \"c\"  \"c\" \n\nduplicated(mat)\n\n[1] FALSE FALSE  TRUE FALSE FALSE  TRUE\n\n\nWe see that rows 3 and 6 were duplicates of earlier rows (row 3 duplicates row 2, and row 6 duplicates row 2 as well), which is why duplicated(mat) flags them as TRUE . The unique(mat) result kept one copy of each distinct row.\nIf we want to check for duplicated columns in a matrix, we can use the MARGIN argument with value 2 in unique() or duplicated() . By default, these functions act on rows (MARGIN=1). For example, unique(mat, MARGIN=2) would give the unique set of columns of the matrix, and duplicated(mat, MARGIN=2) would flag duplicate columns. In our mat example, we can test:\n\nunique(mat, MARGIN = 2)\n\n     [,1] [,2] [,3] [,4]\n[1,] \"c\"  \"c\"  \"c\"  \"d\" \n[2,] \"a\"  \"b\"  \"c\"  \"c\" \n[3,] \"a\"  \"b\"  \"c\"  \"c\" \n[4,] \"a\"  \"b\"  \"c\"  \"d\" \n[5,] \"c\"  \"c\"  \"c\"  \"c\" \n[6,] \"a\"  \"b\"  \"c\"  \"c\" \n\nduplicated(mat, MARGIN = 2)\n\n[1] FALSE FALSE FALSE FALSE  TRUE\n\n\nIf there were any identical columns, duplicated(mat, MARGIN=2) would mark them. (In the constructed matrix above, each column is actually unique.)\n\n\n7.2.3 Duplicated Records in Data Frames\nWorking with duplicate observations in a data frame is similar to the matrix case (except we cannot use MARGIN to target columns in one call). The unique() function applied to a data frame returns the data frame with duplicate rows removed. The duplicated() function applied to a data frame returns a logical vector indicating which rows are duplicates of a previous row.\nConsider an example data frame with a patient ID, a visit number, and a score, where some patients have multiple rows (multiple visits):\n\nset.seed(5)\ndat &lt;- data.frame(\n  ID = c(rep(\"A01\", 3), rep(\"A02\", 2), \"A03\", \"A04\", rep(\"A05\", 2)),\n  visit = c(3:1, 1, 2, rep(1, 4)),\n  score = round(rnorm(9, 5, 2))\n)\ndat\n\n   ID visit score\n1 A01     3     3\n2 A01     2     8\n3 A01     1     2\n4 A02     1     5\n5 A02     2     8\n6 A03     1     4\n7 A04     1     4\n8 A05     1     4\n9 A05     1     4\n\n\nWe can see that ID A01 appears 3 times, A02 twice, A05 twice, etc. If we use unique(dat) , it will return a data frame with duplicate rows removed. In this example, row 9 is an exact duplicate of row 8 (same ID, visit, score), so unique(dat) would drop one of those:\n\nunique(dat)\n\n   ID visit score\n1 A01     3     3\n2 A01     2     8\n3 A01     1     2\n4 A02     1     5\n5 A02     2     8\n6 A03     1     4\n7 A04     1     4\n8 A05     1     4\n\n\nUnderstanding these tools allows for many practical operations. For example, we can use them to extract the first or last occurrence of each group in a dataset. Returning to the dat example: to get each patient’s first visit and last visit, we can do the following:\n\n# 1. sort by ID then visit\ndat_sort &lt;- dat[order(dat$ID, dat$visit), ]  \n# 2. first row for each ID\nfirst_visit &lt;- dat_sort[!duplicated(dat_sort$ID), ] \nfirst_visit\n\n   ID visit score\n3 A01     1     2\n4 A02     1     5\n6 A03     1     4\n7 A04     1     4\n8 A05     1     4\n\n# 3. last row for each ID\nlast_visit &lt;- dat_sort[!duplicated(dat_sort$ID, fromLast=TRUE), ] \nlast_visit\n\n   ID visit score\n1 A01     3     3\n5 A02     2     8\n6 A03     1     4\n7 A04     1     4\n9 A05     1     4\n\n\nLet’s break down what we did:\n\nWe sorted the data frame by ID and then by visit number, storing it in dat_sort . This ensures that for each patient ID, the visits are in chronological order.\n!duplicated(dat_sort$ID) gives TRUE for the first occurrence of each unique ID (since the data is sorted, that will be the earliest visit for each patient). Subsetting dat_sort with this returns the first visit for each patient.\nSimilarly, using duplicated(dat_sort$ID, fromLast=TRUE) identifies the last occurrence of each ID (the last visit in order), and negating it (!) flags those last occurrences. Subsetting gives us the last visit for each patient.\n\nAnother scenario is splitting a dataset into two: one containing only individuals with multiple records, and one containing individuals with a single record. Using the dat example, we could do:\n\n# IDs that appear more than once\ndup_IDs &lt;- dat$ID[duplicated(dat$ID)] \n# all rows for IDs with duplicates\nmulti_record_df &lt;- dat[dat$ID %in% dup_IDs, ] \nmulti_record_df\n\n   ID visit score\n1 A01     3     3\n2 A01     2     8\n3 A01     1     2\n4 A02     1     5\n5 A02     2     8\n8 A05     1     4\n9 A05     1     4\n\n# rows for IDs that appear only once\nsingle_record_df &lt;- dat[!dat$ID %in% dup_IDs, ] \nsingle_record_df\n\n   ID visit score\n6 A03     1     4\n7 A04     1     4\n\n\nIn our data, dup_IDs would include “A01”, “A02”, “A05”. Thus, multi_record_df will contain all records for those IDs, and single_record_df will contain the records for A03 and A04 (the IDs that occur only once).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data Manipulations</span>"
    ]
  },
  {
    "objectID": "manipulations.html#merging-data-frames",
    "href": "manipulations.html#merging-data-frames",
    "title": "7  Data Manipulations",
    "section": "7.3 Merging Data Frames",
    "text": "7.3 Merging Data Frames\nMerging data is crucial for combining information from various sources, enabling us to uncover hidden patterns and relationships. It facilitates comprehensive analysis by integrating diverse datasets, leading to more informed decisions and deeper insights into the underlying phenomena.\nIn base R, the primary tool for merging data frames is the merge() function. This function allows us to join two data frames based on one or more common key variables.\nFor example, suppose we have two data frames we want to merge by an id column:\n\ndata1 &lt;- data.frame(\n  id = c(2, 1, 3),\n  var1 = c(\"A\", \"B\", \"C\")\n)\ndata1\n\n  id var1\n1  2    A\n2  1    B\n3  3    C\n\ndata2 &lt;- data.frame(\n  id = c(3, 4, 1),\n  var2 = c(1, 3, 9)\n)\ndata2\n\n  id var2\n1  3    1\n2  4    3\n3  1    9\n\nresult &lt;- merge(data1, data2)\nresult\n\n  id var1 var2\n1  1    B    9\n2  3    C    1\n\n\nBy default, data frames are merged using the columns with common names in both data frames. You can also specify the variable or variables explicitly with the by argument, such as by = \"id\". In this example, merging the two data frames by id results in a data frame that includes only the rows with matching id values in both data frames.\nThe merge() function performs an inner join (keeping only matching rows) by default. We can change this behavior with the arguments all.x , all.y , or all :\n\nall.x = TRUE: keeps all rows from the first data frame (a left join).\nall.y = TRUE: keeps all rows from the second data frame (a right join).\nall = TRUE: keeps all rows from both (a full outer join), inserting NA for missing matches.\n\nFor instance, using the same data1 and data2:\n\nmerge(data1, data2, by = \"id\", all.x = TRUE)\n\n  id var1 var2\n1  1    B    9\n2  2    A   NA\n3  3    C    1\n\n\nIn the example above, every id from data1 is retained. Notice id 2 had no match in data2, resulting in NA for var2. Similarly:\n\nmerge(data1, data2, by = \"id\", all.y = TRUE)\n\n  id var1 var2\n1  1    B    9\n2  3    C    1\n3  4 &lt;NA&gt;    3\n\n\nAnd setting all = TRUE keeps all ids from both:\n\nmerge(data1, data2, by = \"id\", all = TRUE)\n\n  id var1 var2\n1  1    B    9\n2  2    A   NA\n3  3    C    1\n4  4 &lt;NA&gt;    3\n\n\nNotice how id 4 (which was only in data2) and id 2 (only in data1) are included, with missing values filled in for the other data frame’s fields.\nIf the key columns have different names in the two data frames, we can use by.x and by.y to specify them. For example, if data2 had the identifier in a column named ID (capital letters) instead of id , we could do:\n\ndata3 &lt;- data.frame(\n  ID = c(1, 3, 4),\n  var2 = c(1, 8, 9)\n)\n\nmerge(data2, data3, by.x = \"id\", by.y = \"ID\")\n\n  id var2.x var2.y\n1  1      9      1\n2  3      1      8\n3  4      3      9\n\n\nThe command above merges data2 and data3 by matching data2$id to data3$ID. The result’s column names for the merged key will default to id (the name in the first data frame data2), and since both data frames had a var2 column, the output will have var2.x and var2.y to distinguish them.\nIn this example, .x and .y suffixes were auto-appended to distinguish the two var2 columns that came from data2 and data3. We can customize these suffixes using the suffixes argument if desired:\n\nmerge(data2, data3, by.x=\"id\", by.y=\"ID\",\n      suffixes=c(\".data2\",\".data3\"))\n\n  id var2.data2 var2.data3\n1  1          9          1\n2  3          1          8\n3  4          3          9\n\n\nMerging data frames in base R using merge() is quite powerful for relational operations. It’s worth noting, however, that there are other packages and tools (such as dplyr from the tidyverse, or the data.table package) that provide alternative syntax and potentially faster performance for merging and joining operations.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data Manipulations</span>"
    ]
  },
  {
    "objectID": "manipulations.html#reshaping-data",
    "href": "manipulations.html#reshaping-data",
    "title": "7  Data Manipulations",
    "section": "7.4 Reshaping Data",
    "text": "7.4 Reshaping Data\nIn data analysis, we often need to transform datasets between wide format and long format (and vice versa), or otherwise rearrange the shape of our data.\nBase R provides several functions for reshaping data, including stack(), unstack(), and the more general reshape() function. These functions allow us to reorganize data frames or vectors without losing information, only changing how that information is structured. Many modern R packages such as tidyr also offer powerful data reshaping tools, but we will focus on base R here.\n\n7.4.1 Stacking and Unstacking Data\nThe functions stack() and unstack() provide a convenient way to convert data between long and wide formats when the dataset is relatively simple. Stacking means taking data that is spread across multiple columns and stacking them into a single column (creating a longer, narrower dataset). Unstacking is the opposite: taking data from a single column that includes observations from multiple groups and spreading it out into separate columns (creating a wider dataset).\nIn base R, stack(x) takes a data frame or list x and concatenates the values into one long vector, while also creating an index that indicates the source column for each value . The result of stack() is a data frame with two columns: one named values (the stacked values) and one named ind (a factor indicating which column the value came from) . Conversely, unstack() takes such a stacked data frame (or a similar structure) and spreads it back out into separate vectors for each category.\nTo illustrate, consider the built-in dataset InsectSprays , which is in long format (one observation per row, with a factor indicating spray type). If we wanted a wide format with one column per spray type, we could unstack it. Conversely, if we start with the wide form, we could stack it back to long. The following example demonstrates unstacking:\n\nstr(InsectSprays)\n\n'data.frame':   72 obs. of  2 variables:\n $ count: num  10 7 20 14 14 12 10 23 17 20 ...\n $ spray: Factor w/ 6 levels \"A\",\"B\",\"C\",\"D\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nhead(InsectSprays)\n\n  count spray\n1    10     A\n2     7     A\n3    20     A\n4    14     A\n5    14     A\n6    12     A\n\nwideDF &lt;- unstack(InsectSprays)\nwideDF\n\n    A  B C  D E  F\n1  10 11 0  3 3 11\n2   7 17 1  5 5  9\n3  20 21 7 12 3 15\n4  14 11 2  6 5 22\n5  14 16 3  4 3 15\n6  12 14 1  3 6 16\n7  10 17 2  5 1 13\n8  23 17 1  5 1 10\n9  17 19 3  5 3 26\n10 20 21 0  5 2 26\n11 14  7 1  2 6 24\n12 13 13 4  4 4 13\n\n\nHere, unstack(InsectSprays) produced a data frame with separate columns A, B, C, D, E, F for each spray type, each column containing the count values. Essentially, it turned the balanced long format into a wide format. This works because the original data had the same number of observations for each spray type (a balanced design) (Braun n.d.).\nIf we stack() that wide data frame (or the original wide form, if we had it), we should get back to the long format. For instance:\n\nstackedDF &lt;- stack(wideDF)\nhead(stackedDF)\n\n  values ind\n1     10   A\n2      7   A\n3     20   A\n4     14   A\n5     14   A\n6     12   A\n\n\nThe stack() function in base R stacks only plain atomic vector columns — that is, columns for which is.vector() returns TRUE, such as numeric, character, or logical vectors. Columns with additional class attributes, like factors or matrices, are ignored with a warning, even though they are technically atomic under the hood. Additionally, when stacking columns of mixed types (e.g., numeric and character), R will coerce them to a common type, usually character, to ensure the values column remains consistent. For example:\n\ndf &lt;- data.frame(\n  a = 1:3,\n  b = letters[1:3],\n  c = factor(c(\"low\", \"medium\", \"high\")),\n  d = c(T, F, T)\n)\n\ndf\n\n  a b      c     d\n1 1 a    low  TRUE\n2 2 b medium FALSE\n3 3 c   high  TRUE\n\nstack(df)\n\nWarning in stack.data.frame(df): non-vector columns will be ignored\n\n\n  values ind\n1      1   a\n2      2   a\n3      3   a\n4      a   b\n5      b   b\n6      c   b\n7   TRUE   d\n8  FALSE   d\n9   TRUE   d\n\n\nThe unstack(x, form) function in base R reshapes a data frame from long to wide format using a formula interface. The formula should be written as value ~ group, where value is the column containing the measurements, and group is the column whose unique values will become new column names.\nFor example, suppose we have the following long-format data frame:\n\ndf &lt;- data.frame(\n  person = rep(c(\"A\", \"B\", \"C\"), each = 2),\n  variable = rep(c(\"height\", \"weight\"), times = 3),\n  value = c(160, 55, 170, 65, 180, 75)\n)\n\ndf\n\n  person variable value\n1      A   height   160\n2      A   weight    55\n3      B   height   170\n4      B   weight    65\n5      C   height   180\n6      C   weight    75\n\n\nThe function unstack(df, value ~ variable) spreads the value column into separate columns based on the variable column (height and weight):\n\nunstack(df, value ~ variable)\n\n  height weight\n1    160     55\n2    170     65\n3    180     75\n\n\nAlternatively, using unstack(df, value ~ person) spreads the values into columns named after each person (A, B, C):\n\nunstack(df, value ~ person)\n\n    A   B   C\n1 160 170 180\n2  55  65  75\n\n\nIf the data is in stacked format (e.g., created directly by stack()), then unstack() can be called without a formula.\n\n\n7.4.2 Reshaping Data Frames with reshape()\nThe reshape() function in base R is a flexible tool for converting data frames between wide and long formats, handling complex rearrangements that simpler functions like stack() or unstack() may not manage (e.g., multiple measured variables or unbalanced data).\nKey Arguments for reshape():\n\ndata: The data frame to reshape.\ndirection: \"long\" to stack multiple columns into one, or \"wide\" to spread one column into multiple.\nidvar: Column(s) identifying the observational unit (e.g., subject ID) that stay constant.\ntimevar: Column indicating the time or occasion, whose values become suffixes in wide format or a new column in long format.\nvarying: For wide-to-long, a vector or list of column names to stack into a single column. For long-to-wide, this is often inferred.\nv.names: The name of the measurement variable in long format.\n\nExample: Wide to Long Format\nSuppose we have a wide data frame where each subject (id) has scores measured at two time points (score_time1, score_time2):\n\nwideDF &lt;- data.frame(\n  id = 1:3,\n  score_time1 = c(5, 3, 4),\n  score_time2 = c(6, 2, 4)\n)\n\nwideDF\n\n  id score_time1 score_time2\n1  1           5           6\n2  2           3           2\n3  3           4           4\n\n\nTo reshape this to long format (one row per subject per time point), use reshape():\n\nlongDF1 &lt;- reshape(wideDF, \n                   direction = \"long\",\n                   idvar = \"id\", \n                   timevar = \"time\",\n                   varying = c(\"score_time1\", \"score_time2\"),\n                   v.names = \"score\")\nlongDF1\n\n    id time score\n1.1  1    1     5\n2.1  2    1     3\n3.1  3    1     4\n1.2  1    2     6\n2.2  2    2     2\n3.2  3    2     4\n\n\nHere:\n\nidvar = \"id\": Keeps id constant for each subject.\ntimevar = \"time\": Creates a new column time with values (1, 2) from the suffixes of score_time1 and score_time2.\nvarying = c(\"score_time1\", \"score_time2\"): Specifies columns to stack into one.\nv.names = \"score\": Names the stacked measurement column score.\n\nThe result has two rows per subject: one for time = 1 and one for time = 2, with corresponding scores. If column suffixes aren’t numeric (e.g., score_pre, score_post), use times = c(\"pre\", \"post\") to define time values explicitly. For example:\n\nlongDF2 &lt;- reshape(wideDF, \n                   direction = \"long\",\n                   idvar = \"id\", \n                   timevar = \"time\",\n                   times = c(\"pre\", \"post\"),\n                   varying = c(\"score_time1\", \"score_time2\"),\n                   v.names = \"score\")\nlongDF2\n\n       id time score\n1.pre   1  pre     5\n2.pre   2  pre     3\n3.pre   3  pre     4\n1.post  1 post     6\n2.post  2 post     2\n3.post  3 post     4\n\n\nExample: Long to Wide Format\nNow, let’s reshape the longDF back to wide format:\n\nreshape(longDF1, \n        direction = \"wide\", \n        idvar = \"id\", \n        timevar = \"time\")\n\n    id score.1 score.2\n1.1  1       5       6\n2.1  2       3       2\n3.1  3       4       4\n\n\nHere, reshape() spreads the score column into score.1 and score.2 based on time values. You can customize the column name separator with the sep argument. For example:\n\nreshape(longDF2, \n        direction = \"wide\", \n        idvar = \"id\", \n        timevar = \"time\",\n        sep = \"_\")\n\n      id score_pre score_post\n1.pre  1         5          6\n2.pre  2         3          2\n3.pre  3         4          4\n\n\nThe reshape() function is powerful but can be tricky due to its need for precise argument specification. Modern packages like tidyr (pivot_longer(), pivot_wider()) or reshape2 (melt(), dcast()) often provide simpler alternatives for reshaping tasks.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data Manipulations</span>"
    ]
  },
  {
    "objectID": "manipulations.html#aggregating-data",
    "href": "manipulations.html#aggregating-data",
    "title": "7  Data Manipulations",
    "section": "7.5 Aggregating Data",
    "text": "7.5 Aggregating Data\nIn data analysis, we frequently need to aggregate data — that is, to summarize or collapse detailed observations into higher-level summaries. Examples include calculating the average income by country, total sales by quarter, or the minimum and maximum values within categories. Base R provides several functions for group-wise computations: tapply(), aggregate(), by(), and ave() are among the most commonly used. We have already introduced tapply() in a previous chapter, so in this section, we will focus on the remaining three — each with its own use case and output format, depending on the structure of the data and the desired result.\nBefore diving into each function, note that all these functions ultimately achieve a “split-apply-combine” strategy: they split data into groups based on some factor or categorical variable, apply a function to each group, and then combine the results.\n\n7.5.1 Aggregation with aggregate()\nThe aggregate() function in base R is a powerful tool for summarizing data frames, offering a data-frame-oriented alternative to tapply(). Unlike tapply(), which applies a function to a vector split by factors and returns an array or vector, aggregate() handles multiple columns and returns a data frame, ideal for further manipulation or merging. The aggregate() function has two main methods: the formula method (using a formula like y ~ group) and the default method (using x, by, FUN). Below, we explain both methods and provide examples using the iris dataset, which contains measurements (e.g., Sepal.Length, Sepal.Width) for 50 flowers from each of three iris species.\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\nFormula Method\nThe formula method uses aggregate(formula, data, FUN), where:\n\nformula: Specifies the variable(s) to aggregate and grouping factor(s), e.g., y ~ group or cbind(y1, y2) ~ group.\ndata: The data frame containing the variables.\nFUN: The function to apply (e.g., mean, sd).\n\nFor example, to calculate the mean Sepal.Length for each species:\n\naggregate(Sepal.Length ~ Species, \n          data = iris, \n          FUN = mean)\n\n     Species Sepal.Length\n1     setosa        5.006\n2 versicolor        5.936\n3  virginica        6.588\n\n\nThis returns a data frame with one row per Species and a column for the mean Sepal.Length.\nTo compute the mean and standard deviation of Sepal.Length and Sepal.Width by species, use cbind() in the formula and a custom function:\n\naggregate(cbind(Sepal.Length, Sepal.Width) ~ Species, \n          data = iris, \n          \\(x) c(Mean = mean(x), SD = sd(x)))\n\n     Species Sepal.Length.Mean Sepal.Length.SD Sepal.Width.Mean Sepal.Width.SD\n1     setosa         5.0060000       0.3524897        3.4280000      0.3790644\n2 versicolor         5.9360000       0.5161711        2.7700000      0.3137983\n3  virginica         6.5880000       0.6358796        2.9740000      0.3224966\n\n\nThis returns a data frame with mean and standard deviation for both variables per species.\nIf you have multiple grouping factors (e.g., Species and a hypothetical some_factor), include them in the formula:\n\n# Hypothetical example\naggregate(Sepal.Length ~ Species + some_factor, \n          data = iris, \n          FUN = mean)\n\nDefault Method\nThe default method uses aggregate(x, by, FUN), where:\n\nx: A vector or data frame of variables to aggregate.\nby: A list of grouping factors (e.g., list(group = df$group)).\nFUN: The function to apply.\n\n\naggregate(x = iris[, 1:4], \n          by = list(Species = iris$Species), \n          FUN = mean)\n\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa        5.006       3.428        1.462       0.246\n2 versicolor        5.936       2.770        4.260       1.326\n3  virginica        6.588       2.974        5.552       2.026\n\n\nThis returns a data frame with one row per Species and columns for the mean of each measurement variable.\nThe formula method is often more intuitive for simple aggregations, while the default method is flexible for aggregating multiple columns without a formula. Both methods produce data frames, making aggregate() versatile. For more modern alternatives, consider dplyr’s group_by() and summarise() for streamlined aggregation.\n\n\n7.5.2 Applying Functions by Group with by()\nThe function by() is another approach to group-wise operations. The usage is by(data, INDICES, FUN, ...) , where:\n\ndata is typically a data frame.\nINDICES is a factor or list of factors by which to split the data frame. - FUN is the function to apply to each subset of the data frame.\n\nThe by() function will split the data frame by the factor(s) you provide, apply the function to each subset, and return an object of class \"by\" . When printed, this object shows the results for each group in a neat format.\nFor instance, using the iris data, if we want to get summary statistics of the numeric variables for each Species, we could do:\n\nby(iris[, 1:4], iris$Species, summary)\n\niris$Species: setosa\n  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n Min.   :4.300   Min.   :2.300   Min.   :1.000   Min.   :0.100  \n 1st Qu.:4.800   1st Qu.:3.200   1st Qu.:1.400   1st Qu.:0.200  \n Median :5.000   Median :3.400   Median :1.500   Median :0.200  \n Mean   :5.006   Mean   :3.428   Mean   :1.462   Mean   :0.246  \n 3rd Qu.:5.200   3rd Qu.:3.675   3rd Qu.:1.575   3rd Qu.:0.300  \n Max.   :5.800   Max.   :4.400   Max.   :1.900   Max.   :0.600  \n------------------------------------------------------------ \niris$Species: versicolor\n  Sepal.Length    Sepal.Width     Petal.Length   Petal.Width   \n Min.   :4.900   Min.   :2.000   Min.   :3.00   Min.   :1.000  \n 1st Qu.:5.600   1st Qu.:2.525   1st Qu.:4.00   1st Qu.:1.200  \n Median :5.900   Median :2.800   Median :4.35   Median :1.300  \n Mean   :5.936   Mean   :2.770   Mean   :4.26   Mean   :1.326  \n 3rd Qu.:6.300   3rd Qu.:3.000   3rd Qu.:4.60   3rd Qu.:1.500  \n Max.   :7.000   Max.   :3.400   Max.   :5.10   Max.   :1.800  \n------------------------------------------------------------ \niris$Species: virginica\n  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n Min.   :4.900   Min.   :2.200   Min.   :4.500   Min.   :1.400  \n 1st Qu.:6.225   1st Qu.:2.800   1st Qu.:5.100   1st Qu.:1.800  \n Median :6.500   Median :3.000   Median :5.550   Median :2.000  \n Mean   :6.588   Mean   :2.974   Mean   :5.552   Mean   :2.026  \n 3rd Qu.:6.900   3rd Qu.:3.175   3rd Qu.:5.875   3rd Qu.:2.300  \n Max.   :7.900   Max.   :3.800   Max.   :6.900   Max.   :2.500  \n\n\nThe main difference between by() and aggregate() lies in their output. Both functions split data into groups based on a factor and apply a function to each group. However, aggregate() returns a data frame, making it easier to use for further data manipulation. In contrast, by() returns a list-like \"by\" object, which can be useful for printing or inspecting group-specific results but may require additional steps if you want to combine or reshape the output for downstream analysis.\n\n\n7.5.3 Computing Group Summaries with ave()\nWhile functions like tapply() and aggregate() produce one summary value per group, there are situations where we want to compute a group summary but retain the full length of the original data. This is useful when we want to annotate each observation with a statistic derived from its group, such as the group mean. The ave() function is designed specifically for this purpose.\nThe ave() function takes a vector x, splits it according to the grouping factor(s), applies a function FUN (default is mean), and returns a vector of the same length as x where each element is replaced by the computed group summary. This makes it especially handy for adding new columns to data frames based on group-level statistics.\nFor example, consider a data frame of test scores for students across different classes:\n\nstudents &lt;- data.frame(\n  class = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"A\"),\n  score = c(85, 90, 78, 88, 84, 92)\n)\nstudents\n\n  class score\n1     A    85\n2     A    90\n3     B    78\n4     B    88\n5     B    84\n6     A    92\n\n\nWe can compute the class average for each student and store it in a new column using ave():\n\nstudents$class_avg &lt;- ave(students$score, \n                          students$class, \n                          FUN=mean)\nstudents\n\n  class score class_avg\n1     A    85  89.00000\n2     A    90  89.00000\n3     B    78  83.33333\n4     B    88  83.33333\n5     B    84  83.33333\n6     A    92  89.00000\n\n\nNow each student has a class_avg value corresponding to the mean score of their class. This technique is useful for comparisons, standardization, or visualization.\nAlthough the default function for ave() is mean, you can supply other summary functions like median, sd, or even custom ones as long as the function returns a single value per group. However, avoid using functions that return multiple values (like range), since ave() expects only one summary value per group.\nIn summary, ave() is a convenient way to create group-based summary columns that align with the structure of the original data. It complements other aggregation functions by expanding the result across the full dataset instead of collapsing it.\n\n\n\n\nBraun, W. John. n.d. “Introduction to r.” https://pages.stat.wisc.edu/~st849-1/Rnotes/1IntroD.pdf.\n\n\nMatloff, Norman. 2011. The Art of r Programming: A Tour of Statistical Software Design. No Starch Press.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data Manipulations</span>"
    ]
  }
]