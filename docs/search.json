[
  {
    "objectID": "iteration.html",
    "href": "iteration.html",
    "title": "6  Iteration",
    "section": "",
    "text": "6.1 Loops\nTLoops allow you to perform the same operation multiple times, making them useful for automating repetitive tasks in R. While many tasks in R can be handled using vectorized functions, there are situations where loops offer more control and flexibility—especially when working with conditions, custom logic, or sequences of unknown length. In this section, we will focus on three types of loops in Base R: for, while, and repeat. Among them, the for loop is the most commonly used and is a good starting point for beginners. We will also revisit a practical example from the previous chapter to demonstrate how loops can make your code more efficient and adaptable.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "iteration.html#loops",
    "href": "iteration.html#loops",
    "title": "6  Iteration",
    "section": "",
    "text": "6.1.1 The for Loop\nA for loop allows you to repeat a task a specific number of times. This type of loop is most useful when the number of iterations is known ahead of time. Let’s use an example to walk through how a for loop is constructed.\nSuppose we have blood pressure and pulse measurements from several patients stored in a matrix called bp. Each column represents a different type of measurement—systolic pressure, diastolic pressure, and pulse rate.\n\nbp &lt;- cbind(\n  systolic  = c(120, 122, NA, 118, 130),\n  diastolic = c(80, 78, 85, 82, 79),\n  pulse     = c(70, 72, 68, 75, 71)\n)\n\nIf we want to calculate the mean value for each column, we could manually repeat the following commands:\n\nmean(bp[, 1], na.rm=T)  # systolic\n\n[1] 122.5\n\nmean(bp[, 2], na.rm=T)  # diastolic\n\n[1] 80.8\n\nmean(bp[, 3], na.rm=T)  # pulse\n\n[1] 71.2\n\n\nEach command is nearly identical except for the column index. In this situation, we can use a for loop to eliminate repetition and make the code more flexible.\nThree Components of a for Loop\nLet’s break the loop construction into three steps:\n1. Prepare a place to store the result\nSince we will compute one median per column, we need a numeric vector of the same length as the number of columns in bp. The numeric() function creates a numeric vector of the specified length.\n\noutput &lt;- numeric(ncol(bp))\n\n2. Create a loop with an index variable\nTo repeat an operation three times—once for each column—we use a for loop. The index variable i will take on the values 1, 2, and 3:\n\nfor (i in 1:3) {\n  ...\n}\n\nHowever, a more flexible version uses ncol(bp) so that the loop works even if the number of columns changes:\n\nfor (i in 1:ncol(bp)) {\n  ...\n}\n\n3. Write the loop body\nInside the loop, we want to compute the mean of the \\(i^{th}\\) column and store it in the \\(i^{th}\\) position of the output vector.\n\nfor (i in 1:ncol(bp)) {\n  output[i] &lt;- mean(bp[, i], na.rm=T)\n}\n\nFinal Code\nPutting it all together:\n\noutput &lt;- numeric(ncol(bp))\nfor (i in 1:ncol(bp)) {\n  output[i] &lt;- mean(bp[, i], na.rm=T)\n}\noutput\n\n[1] 122.5  80.8  71.2\n\n\nThis loop is functionally equivalent to:\n\noutput[1] &lt;- mean(bp[, 1], na.rm=T)\noutput[2] &lt;- mean(bp[, 2], na.rm=T)\noutput[3] &lt;- mean(bp[, 3], na.rm=T)\n\nUsing a loop avoids repetitive code and ensures your script remains flexible if the number of columns changes later.\n✻ Note: The structure of this example—first pre-allocating output, then defining the iteration sequence, and finally writing the loop body—is inspired by the clear and practical approach described in R for Data Science (Wickham, Çetinkaya-Rundel, and Grolemund 2023).\n\n\n6.1.2 More Examples of for Loops\nWhile the previous section focused on looping through columns of a matrix, we can also use for loops to process vectors, perform sequential comparisons, and work with lists. The following examples demonstrate how loops can be applied in various situations.\nIf you are unsure how to begin writing a loop, a good strategy is to first write out a few lines of code manually—without a loop—then identify the parts that repeat. This helps you recognize the pattern, making it easier to convert those lines into a loop structure. Each example below walks through this approach to reinforce the logic behind loop construction.\nIn the following example, we consider a list of sales figures from different stores. We want to calculate and report the average sales for each store. Let’s begin by creating the data:\n\nsales_data &lt;- list(\n  store_A = c(200, 250, 220),\n  store_B = c(300, 320, 310),\n  store_C = c(150, 180, 170)\n)\n\nTo calculate the average for each store without using a loop, we could write:\n\ncat(\"Average sales for store_A:\", mean(sales_data[[\"store_A\"]]), \"\\n\")\n\nAverage sales for store_A: 223.3333 \n\ncat(\"Average sales for store_B:\", mean(sales_data[[\"store_B\"]]), \"\\n\")\n\nAverage sales for store_B: 310 \n\ncat(\"Average sales for store_C:\", mean(sales_data[[\"store_C\"]]), \"\\n\")\n\nAverage sales for store_C: 166.6667 \n\n\nEach command follows the same structure: retrieve the sales vector by name, calculate the mean, and print the result. This kind of repetition is a good opportunity to switch to a loop.\nNow let’s write a for loop to handle the task more efficiently:\n\nfor (name in names(sales_data)) {\n  cat(\"Average sales for\", name, \":\", mean(sales_data[[name]]), \"\\n\")\n}\n\nAverage sales for store_A : 223.3333 \nAverage sales for store_B : 310 \nAverage sales for store_C : 166.6667 \n\n\nThe loop iterates over the names of the list elements. We are using the names of the list as the indexing sequence; at each iteration, the variable name is automatically assigned one of the list’s names (such as \"store_A\", \"store_B\", or \"store_C\"). It then retrieves the values associated with the current name using double square brackets ([[ ]]), computes the mean, and prints a message using cat(). This loop accomplishes the same result as before, but in a more compact and generalizable way.\nIn the following example, we are classifying a set of body temperature readings. If a temperature is 100.4°F or higher, we consider it “Fever”; otherwise, it is “Normal.”\nBefore jumping into a loop, one useful approach is to write out the steps manually for a few values. This helps clarify the pattern and logic:\n\nbody_temp &lt;- c(98.6, 101.2, 100.8, 98.7, 99.1)\nstatus &lt;- character(length(body_temp))\n\nif (body_temp[1] &gt;= 100.4) {\n  cat(body_temp[1], \": Fever\\n\")\n  status[1] &lt;- \"Fever\"\n} else {\n  cat(body_temp[1], \": Normal\\n\")\n  status[1] &lt;- \"Normal\"\n}\n\n98.6 : Normal\n\nif (body_temp[2] &gt;= 100.4) {\n  cat(body_temp[1], \": Fever\\n\")\n  status[1] &lt;- \"Fever\"\n} else {\n  cat(body_temp[1], \": Normal\\n\")\n  status[1] &lt;- \"Normal\"\n}\n\n98.6 : Fever\n\nif (body_temp[3] &gt;= 100.4) {\n  cat(body_temp[1], \": Fever\\n\")\n  status[1] &lt;- \"Fever\"\n} else {\n  cat(body_temp[1], \": Normal\\n\")\n  status[1] &lt;- \"Normal\"\n}\n\n98.6 : Fever\n\n\nThis approach becomes tedious and error-prone as the vector grows. Notice that only the index changes across each block. Once we recognize this repeating structure, we can rewrite the task using a for loop:\n\nbody_temp &lt;- c(98.6, 101.2, 100.8, 98.7, 99.1)\nstatus &lt;- character(length(body_temp))\nfor (i in seq_along(body_temp)) {\n  if (body_temp[i] &gt;= 100.4) {\n    cat(body_temp[i], \": Fever\\n\")\n    status[i] &lt;- \"Fever\"\n  } else {\n    cat(body_temp[i], \": Normal\\n\")\n    status[i] &lt;- \"Normal\"\n  }\n}\n\n98.6 : Normal\n101.2 : Fever\n100.8 : Fever\n98.7 : Normal\n99.1 : Normal\n\nstatus\n\n[1] \"Normal\" \"Fever\"  \"Fever\"  \"Normal\" \"Normal\"\n\n\nWe use seq_along(body_temp) rather than 1:length(body_temp) because it’s safer. If the input vector were ever empty, seq_along() would return an empty sequence, while 1:length(x) would return 1:0, which evaluates to c(1, 0)—an unexpected result that could cause bugs in your code.\nIn the next example, we will use the status vector we just created to detect how often a patient’s condition fluctuates over a series of temperature readings. Specifically, we want to count how many times the status changes from one reading to the next.\nA good way to approach this kind of problem is to begin by writing out a few comparisons manually, without using a loop. For example:\n\nfluctuations &lt;- 0\n\nif (status[2] != status[1]) {\n  fluctuations &lt;- fluctuations + 1\n}\n\nif (status[3] != status[2]) {\n  fluctuations &lt;- fluctuations + 1\n}\n\nif (status[4] != status[3]) {\n  fluctuations &lt;- fluctuations + 1\n}\n\nif (status[5] != status[4]) {\n  fluctuations &lt;- fluctuations + 1\n}\n\nfluctuations\n\n[1] 2\n\n\nBy writing out these steps, we make the logic of the task explicit: each comparison checks whether the current status differs from the previous one, and if so, increments a counter. This repetition makes it a good candidate for a loop.\nWe can now rewrite the same logic using a for loop:\n\nfluctuations &lt;- 0\nfor (i in 2:length(status)) {\n  if (status[i] != status[i - 1]) {\n    fluctuations &lt;- fluctuations + 1\n  }\n}\nfluctuations\n\n[1] 2\n\n\nThis loop performs the same sequence of comparisons but in a more compact and scalable way. It also illustrates one of the strengths of loop structures: applying a repeated operation over a sequence of elements, especially when the current step depends on the previous one.\n\n\n6.1.3 The while Loop\nIn many situations, we know ahead of time how many times a loop should run, which makes for loops a natural choice. However, there are cases where the number of iterations is not known in advance. In those cases, we can use a while loop.\nA while loop contains a condition and a body. The loop continues to run as long as the condition evaluates to TRUE.\n\nwhile (condition) {\n  ## code to execute\n}\n\nThe key idea behind a while loop is that the stopping point depends on a condition that is evaluated within the loop. Let’s look at a practical example.\nSuppose we receive patient records in random order, and we want to search through them until we find the one with ID 1005.\n\npatient_ids &lt;- sample(1001:1010)  # randomly shuffled IDs\ni &lt;- 1\n\nwhile (patient_ids[i] != 1005) {\n  cat(\"Checked patient\", patient_ids[i], \"\\n\")\n  i &lt;- i + 1\n}\n\nChecked patient 1003 \nChecked patient 1010 \nChecked patient 1002 \nChecked patient 1008 \nChecked patient 1006 \nChecked patient 1009 \nChecked patient 1001 \nChecked patient 1007 \n\ncat(\"Found patient\", patient_ids[i], \"- stopping.\\n\")\n\nFound patient 1005 - stopping.\n\n\nIn this case, we do not know how many patients we’ll need to examine. The loop runs until we encounter the target ID. Note that the index variable i must be initialized before the loop and updated manually inside the loop body. Without this, the loop may never terminate.\nAlthough any for loop can be rewritten as a while loop, the reverse is not true—some problems require while because the exit condition depends on dynamic logic, not a predefined sequence.\nWe can also mention two additional loop tools:\n\nThe repeat loop, which runs indefinitely until a break statement is encountered.\nThe break command, which can be used inside any loop to exit early when a condition is met.\n\nThese constructs are not commonly needed for most routine data tasks, so we will not explore them further here.\n\n\n6.1.4 Rewriting the impute() Function with a Loop\nIn the previous chapter, we introduced the impute() function, which handled missing values for a single variable at a time. However, when multiple variables require imputation, repeating the same function call is inefficient. A loop allows us to process all specified variables in one pass, making the function more flexible and scalable.\nTo rewrite the function, we follow three basic steps. First, we identify the sequence of variables to loop over. In this case, we use a character vector var_list containing the names of the variables to be imputed. Second, we create the loop. This can be done with a standard index like 1:length(var_list), though it is generally safer to use seq_along(var_list) to avoid issues when the list is empty. Finally, we write the loop body, which applies the imputation logic to each variable.\nAt the beginning of the loop, we extract the name of the current variable using var_name &lt;- var_list[i], and then proceed with the imputation logic used previously. After filling in the missing values, we update the column in the original dataset.\nHere is the final version of the function:\n\nimpute_N &lt;- function(dat, var_list){\n  for (i in seq_along(var_list)){\n    var_name &lt;- var_list[i]\n    select_var &lt;- dat[[var_name]]\n    if(is.numeric(select_var)) {\n      replace_value &lt;- median(select_var, na.rm=T)\n    } else{\n      tab_result &lt;- table(select_var)\n      high_freq &lt;- max(tab_result)\n      replace_value &lt;-names(tab_result)[tab_result == high_freq]\n    }\n    select_var[is.na(select_var)] &lt;- replace_value\n    dat[[var_name]] &lt;- select_var\n  }\n  dat\n}\n\nTo apply the function, we pass both the dataset and a character vector of variable names to be imputed:\n\nimpute_N(patient, c(\"TGL\", \"HDL\", \"LDL\", \"HRT\", \"MAMM\"))\n\n   ID GLUC TGL  HDL LDL HRT MAMM SMOKE\n1   A   88 180 32.0  99   Y    Y     Y\n2   B   NA 150 60.0 165   Y    Y  &lt;NA&gt;\n3   C  110 180 62.5 120   N    N     N\n4   D   NA 200 65.0 165   Y    Y  &lt;NA&gt;\n5   E   90 210 62.5 150   Y    Y     Y\n6   F   88 180 32.0 210   Y    Y  &lt;NA&gt;\n7   G  120 164 62.5 165   Y    Y     Y\n8   H  110 170 70.0 188   Y    Y  &lt;NA&gt;\n9   I   NA 190 62.5 190   N    N     N\n10  J   90 180 75.0 165   Y    Y  &lt;NA&gt;\n\n\nThis version of the impute() function can handle any number of variables and illustrates how a for loop can help automate repetitive tasks in a structured and reliable way.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "iteration.html#utilizing-apply-type-functions",
    "href": "iteration.html#utilizing-apply-type-functions",
    "title": "6  Iteration",
    "section": "6.2 Utilizing Apply-type Functions",
    "text": "6.2 Utilizing Apply-type Functions\nR provides a series of functions that allow users to apply a function to a matrix, a vector, or a list efficiently. Some of these functions include apply(), lapply(), and others. These functions are incredibly useful because they automate repetitive tasks and streamline data manipulation processes.\n\n6.2.1 Applying a function to a Matrix\nR provides several functions to compute statistics for rows or columns of a matrix, including rowSums(), rowMeans(), colSums(), and colMeans(). However, for more generalized operations on successive sections of a matrix or an array, the apply() function proves invaluable. The apply() function accepts the following arguments:\n\nX: a matrix or an array.\nMARGIN: an integer vector indicating the subscripts of the dimension over which the function will be applied. For example, for a matrix, 1 indicates rows, 2 indicates columns, and c(1, 2) indicates rows and columns.\nFUN: a function, either built-in or user-defined, applied separately to each section.\n...: any additional arguments needed by the function can be included after the function.\n\nThe returned value from the apply() function is either a vector or a matrix. For example, to calculate the median value for each row and column of a matrix, we can execute the following commands:\n\napply(m, 1, median) ## calculate the median value for each row.\napply(m, 2, median) ## calculate the median value for each column.\n\nFor illustrative purposes, let’s consider an example where one element of the matrix m is set to missing. When using the median() function on a vector containing missing values, we need to set na.rm = TRUE. This additional argument for the median() function needs to be passed to the ... argument in the apply() function. For instance, to calculate the median for each column, we can use the following approach:\n\nm1 &lt;- m\nm1[1,1] &lt;- NA\napply(m1, 2, median, na.rm = TRUE)\n\n\n\n6.2.2 Applying a function to a List or a Vector\nMost R functions are designed to operate on each element of a vector, but they may not work directly on a list. To address this, R provides the lapply() and sapply() functions, which are specifically designed for operations on the individual components of lists or vectors. Interestingly, these two functions share the same set of arguments:\n\nX: represents either a vector or a list.\nFUN: denotes the function to be applied to each element of X.\n...: stands for optional arguments to be passed to FUN.\n\nThe distinction between the sapply and lapply functions lies in their output: sapply() attempts to simplify the result as a vector or an array if possible, whereas lapply() always returns a list. For instance, suppose we aim to calculate the mean of each component of the following list:\n\nset.seed(1)\na &lt;- list(a = rnorm(20, 3, 4), \n          b = rnorm(10, 5, 2),\n          c = c(rnorm(15, 2, 1), NA))\nlapply(a, mean, na.rm = T)\n\n$a\n[1] 3.762096\n\n$b\n[1] 4.732654\n\n$c\n[1] 2.090286\n\nsapply(a, mean, na.rm = T)\n\n       a        b        c \n3.762096 4.732654 2.090286 \n\n\nNotice that the sapply() function above simplifies the result into a vector, whereas the lapply() function returns a list as the result.\nThe FUN argument doesn’t have to be a built-in function; it can also be a user-defined function. Suppose we want to calculate both the mean and the standard deviation of each component simultaneously. We can achieve this by writing the following:\n\nmean_sd &lt;- function(x){\n  c(MEAN = mean(x, na.rm = T), SD = sd(x, na.rm = T))\n}\nlapply(a, mean_sd)\n\n$a\n    MEAN       SD \n3.762096 3.653015 \n\n$b\n    MEAN       SD \n4.732654 1.911215 \n\n$c\n    MEAN       SD \n2.090286 0.720553 \n\n\nInstead of creating a function separately, we can directly insert the user-defined function within the lapply() or sapply() function. The following example accomplishes the same task by applying a user-defined function within the sapply() function. Notice that the sapply() function simplifies the result into a matrix.\n\nsapply(a, \n       function(x) {\n         c(MEAN = mean(x, na.rm = T), SD = sd(x, na.rm = T))\n         }\n)\n\n            a        b        c\nMEAN 3.762096 4.732654 2.090286\nSD   3.653015 1.911215 0.720553\n\n\nWhen working with a data frame, we have the option to use either the apply() function or the lapply()/sapply() functions. The apply() function treats the data frame as a matrix, while lapply() and sapply() functions treat the data frame as a list. Consider the following data frame.\n\nd &lt;- data.frame(\n  var1 = c(1, 3, 7),\n  var2 = c(3, 5, 10)\n)\n\nTo calculate the sum of each column, when using the apply() function, we need to specify 2 as the second argument. For example:\n\napply(d, 2, sum)\n\nvar1 var2 \n  11   18 \n\n\nAlternatively, we can also use the lapply() or sapply() functions to accomplish the same task.\n\nsapply(d, sum)\n\nvar1 var2 \n  11   18 \n\nlapply(d, sum)\n\n$var1\n[1] 11\n\n$var2\n[1] 18\n\n\n\n\n6.2.3 Applying a function to Each Level of a Categorical Variable\nThe tapply() function is employed to apply a function to each group of values defined by unique combinations of levels of certain factors.Here are the main arguments for the tapply() function:\n\nX: typically represents a vector.\nINDEX: denotes the factor defining the groups. If the INDEX argument is a list of factors, the function is applied to each combination of cross-classification. FUN: represents the function to be applied. ...: optional arguments passed to FUN.\n\nWe will utilize the quine data frame from the MASS library to illustrate how to use the tapply() function. This data frame consists of 146 rows and 5 columns. It records the number of days absent from school in a particular school year for children from Walgett, New South Wales, Australia. These children were classified by Culture, Age, Sex, and Learner status.\n\nlibrary(MASS)\nhead(quine)\n\n  Eth Sex Age Lrn Days\n1   A   M  F0  SL    2\n2   A   M  F0  SL   11\n3   A   M  F0  SL   14\n4   A   M  F0  AL    5\n5   A   M  F0  AL    5\n6   A   M  F0  AL   13\n\n\nSuppose we want to calculate the mean number of days absent for each level of the Age group. We can use the tapply() function to accomplish this task.\n\ntapply(quine$Days, quine$Age, mean)\n\n      F0       F1       F2       F3 \n14.85185 11.15217 21.05000 19.60606 \n\n\nWhen we use more than one factor as the INDEX argument, we need to combine them into a list. The following calculates the mean number of Days absent for each level of the Age group and Sex.\n\ntapply(quine$Days, list(quine$Age, quine$Sex), mean)\n\n          F        M\nF0 18.70000 12.58824\nF1 12.96875  7.00000\nF2 18.42105 23.42857\nF3 14.00000 27.21429\n\n\n\n\n6.2.4 Splitting the Data\nSometimes, it’s more convenient to split the data into a list so that we can apply operations to each component using the lapply() or sapply() functions. The split() function divides a data vector or a data frame based on one or more factors. Here are the first two main arguments:\n\nx: represents a vector or a data frame.\nf: denotes one or a list of factors.\n\nThe result from the split() function is a list of vectors or a list of data frames, where each component corresponds to each level of the factor.\nPreviously, we used the tapply() function to perform an operation on each level of one or more factors. An alternative method is using the split() and sapply() functions. For example, to calculate the mean number of Days absent for each level of the Age group, we can split the Days variable by the Age group first.\n\nDays_by_Age &lt;- split(quine$Days, quine$Age)\nDays_by_Age\n\n$F0\n [1]  2 11 14  5  5 13 20 22  3  5 11 24 45  6 17 67  0  0  2  7 11 12 25 10 11\n[26] 20 33\n\n$F1\n [1]  6  6 15  7 14  5  6  6  9 13 23 25 32 53 54  5  5 11 17 19  0  0  5  5  5\n[26] 11 17  3  4  5  7  0  1  5  5  5  5  7 11 15  5 14  6  6  7 28\n\n$F2\n [1]  6 32 53 57 14 16 16 17 40 43 46  8 13 14 20 47 48 60 81  2 22 30 36  8  0\n[26]  1  5  7 16 27  0  5 14  2  2  3  8 10 12  1\n\n$F3\n [1]  8 23 23 28 34 36 38  0  2  3  5 10 14 21 36 40  0 30 10 14 27 41 69  1  9\n[26] 22  3  3  5 15 18 22 37\n\n\nSince Days_by_Age is a list of vectors, we can simply use the sapply() function to calculate the mean number of Days absent for each Age group.\n\nsapply(Days_by_Age, mean)\n\n      F0       F1       F2       F3 \n14.85185 11.15217 21.05000 19.60606 \n\n\nThe following command calculates the mean and median of Days for each level of the Age group. Notice that the split() function is embedded within the sapply() function.\n\nsapply(split(quine$Days, quine$Age), \n       function(x){\n         c(Mean = mean(x), Median = median(x))\n       }\n)\n\n             F0       F1    F2       F3\nMean   14.85185 11.15217 21.05 19.60606\nMedian 11.00000  6.00000 14.00 18.00000\n\n\nThe following example calculates the mean and median of Days for each combination level of the Age and Sex variables.\n\nsapply(split(quine$Days, list(quine$Age, quine$Sex)),\n       function(x) {\n         c(Mean = mean(x), Median = median(x))\n       }\n)\n\n       F0.F     F1.F     F2.F F3.F     F0.M F1.M     F2.M     F3.M\nMean   18.7 12.96875 18.42105   14 12.58824  7.0 23.42857 27.21429\nMedian 15.5  7.00000 10.00000   10 11.00000  5.5 17.00000 27.50000",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Getting Started with Base R",
    "section": "",
    "text": "1.1 Introduction to Base R and Setup\nR is a freely available and versatile tool for data analysis, statistics, and visualization, widely used by researchers and analysts (R Core Team 2025). Base R, the core version, equips you with essential features to explore data without additional packages. For beginners, mastering R involves understanding its diverse objects—such as vectors and lists—and learning to break them apart or combine them effectively. Equally critical is comprehending R’s syntax, including recognizing symbols like parentheses or brackets, interpreting help files, and applying functions to specific object types. These skills form the foundation for R proficiency.\nDeveloped from the S programming language by John Chambers, R was crafted by Robert Gentleman and Ross Ihaka, whose initials inspired its name. As part of the GNU open-source project, R’s code is accessible under the GNU General Public License, allowing anyone to use or enhance it (R Core Team 2025). To streamline your experience, RStudio, a free companion tool, provides an intuitive interface for coding and visualizing data, ideal for novices and experts (Posit 2025).\nInstallation of R, followed by RStudio, is the first step, as RStudio requires R to operate. Visit https://posit.co/download/rstudio-desktop/, which guides you through both steps (Posit 2025). The website identifies the operating system and provides a download link labeled ‘DOWNLOAD RSTUDIO DESKTOP FOR WINDOWS’ for Windows or ‘DOWNLOAD RSTUDIO DESKTOP FOR macOS’ for macOS.\nStep 1: Install R\nStep 2: Install RStudio\nFor additional guidance, view this video on RStudio installation: https://learnr-examples.shinyapps.io/ex-setup-r/#section-install-rstudio\nWith R and RStudio installed, you’re prepared to explore Base R’s objects and syntax.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#introduction-to-base-r-and-setup",
    "href": "intro.html#introduction-to-base-r-and-setup",
    "title": "1  Getting Started with Base R",
    "section": "",
    "text": "Under “1. Install R,” click the link to download R from the Comprehensive R Archive Network (CRAN).\nSelect a CRAN mirror site near your location and choose your system (Windows, macOS, or Linux).\nFor Windows, download the .exe installer (e.g., R-4.5.0-win.exe). For macOS, select the appropriate .pkg file (e.g., R-4.5.0-arm64.pkg for M1/M2 Macs or R-4.5.0-x86_64.pkg for Intel Macs).\nRun the installer, accepting default settings. On macOS, you may need a system password.\nOpen R, type 1 + 1 in the console, and press Enter. If you see 2, R is installed correctly.\n\n\n\nReturn to https://posit.co/download/rstudio-desktop/. Under “2. Install RStudio,” click the download button for RStudio Desktop (free version).\nFor Windows, download the .exe file (e.g., RStudio-2025.05.1-513.exe). For macOS, download the .dmg file (e.g., RStudio-2025.05.1-513.dmg).\nOn Windows, run the .exe and follow the prompts. On macOS, open the .dmg, drag RStudio to the Applications folder, and eject the disk image.\nOpen RStudio. The R console appears alongside tools for code writing and management.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#exploring-the-rstudio-environment",
    "href": "intro.html#exploring-the-rstudio-environment",
    "title": "1  Getting Started with Base R",
    "section": "1.2 Exploring the RStudio Environment",
    "text": "1.2 Exploring the RStudio Environment\nThe RStudio environment, a structured interface designed for data analysis and coding, provides a workspace for creating, managing, and visualizing R objects, such as lists and data frames, and for understanding syntax, including commands and associated symbols.\n\n\n\n\n\n\nFigure 1.1: RStudio Initial Interface\n\n\n\nAfter installing R and RStudio, the RStudio environment, a structured interface designed for data analysis and coding, provides a workspace for creating, managing, and visualizing R objects, such as lists and tables, and for understanding syntax, including commands and their associated symbols. The initial layout, shown in Figure 1.1, organizes tools for these tasks.\nThe default view includes the console on the left, where you can type and execute R commands directly, and panels on the right for the environment, history, and connections. The console displays R’s version and platform details, confirming your setup. For example, typing 1 + 1 and pressing Enter should yield 2, verifying the environment is operational. Although you can also work with the regular R console that you initially installed, it is recommended you work with RStudio, which offers a much better user-friendly interface and additional tools to enhance your experience.\n\n\n\n\n\n\nFigure 1.2: RStudio Interface with Script, Environment, and Plot\n\n\n\nTo enhance your workflow, you can create a script file to save and organize your commands. Select File &gt; New File &gt; R Script to open a new script editor, as shown in Figure 1.2. This editor, located in the upper-left pane, allows you to write and edit R code, such as defining vectors or performing calculations. The environment panel updates to reflect any objects you create, such as score1 or score2 from your script. Scripts are essential for documenting your work and revisiting it later, supporting your exploration of R’s objects and syntax.\nAs you work, the environment panel tracks your data objects, while the console executes your commands. Additionally, the plotting window in the lower right corner, as seen in Figure 1.2, displays visual representations of your data, such as graphs or charts, when you use commands like plot(). This feature allows you to explore relationships within your objects, enhancing your understanding of their structure and supporting your mastery of R’s syntax for visualization.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#understanding-r-commands",
    "href": "intro.html#understanding-r-commands",
    "title": "1  Getting Started with Base R",
    "section": "1.3 Understanding R Commands",
    "text": "1.3 Understanding R Commands\nR’s syntax is the foundation for instructing the program to perform tasks, and mastering it is essential for beginners.\n\n1.3.1 Constants and Variables\nA constant is a fixed value that remains unchanged, such as the number 1 or the text \"a\". When entered, these values produce specific outputs:\n\n1\n\n[1] 1\n\n\"a\"\n\n[1] \"a\"\n\n\nNotably, 1 is a numeric vector of length one, while \"a\" is a character vector of the same length. To reuse these values efficiently, you can assign them names, creating variables. For example:\n\nx &lt;- 1.12345 \nx\n\n[1] 1.12345\n\nb = \"a\" \nb\n\n[1] \"a\"\n\n\nHowever, typing an undefined variable name, such as y, will trigger an error, requiring prior assignment:\n\ny\n\nError: object 'y' not found\n\n\nThis naming process lays the foundation for storing and manipulating data, a principle that extends to how assignments function, as discussed next.\n\n\n1.3.2 Assignments\nAssignment associates a name with a value or object, storing it for later use. The primary operator is &lt;-, though = is also valid. To check a value, enter the name in the console:\n\nx &lt;- 5\nx\n\n[1] 5\n\ny = 10\ny\n\n[1] 10\n\n\nOnce assigned, variables like x and y can be used in calculations:\n\nx^2\n\n[1] 25\n\nx + y + 3\n\n[1] 18\n\n\nHere, x and y serve as variable names, enabling further manipulation and analysis within commands.\n\n\n1.3.3 Functions with Constants and Variables\nConstants and variables are frequently used with R functions, which perform specific operations. For example:\n\nsum(1, 2, 3)  \n\n[1] 6\n\nx &lt;- 1.23456\nround(x, 2)     ## round x to 2 decimal places\n\n[1] 1.23\n\nlog(b) \n\nError in log(b): non-numeric argument to mathematical function\n\n\nlog(b) is invalid (as \"a\" isn’t numeric), illustrating that functions require compatible object types. Functions enhance your ability to work with objects, a skill you’ll develop further.\n\n\n1.3.4 Operators and Their Function-Like Nature\nOperators differ from functions in that they are placed between constants or variables to perform calculations. For example:\n\n1:10       ## sequence operator :\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx * 2      ## multiplication operator *\n\n[1] 2.46912\n\n\nThese operators can be treated as functions by enclosing them within backticks, single quotes, or double quotes.\n\n3 + 5\n\n[1] 8\n\n`+`(3, 5)\n\n[1] 8\n\n'+'(3, 5)\n\n[1] 8\n\n\"+\"(3, 5)\n\n[1] 8\n\n\nHowever, this approach, by treating an operator as a function, is not commonly used in R and is typically reserved for advanced contexts, with the standard infix notation (e.g., 3 + 5) being preferred for readability.\n\n\n1.3.5 Braces and Special Symbols\nBraces and symbols are critical for structuring R code. Following an explanation of functions and operators, this section examines braces, which are fundamental to R’s syntax:\n\nParentheses (): Used to call functions and to group expressions for controlling order of operations.\n\nsum(1, 2) \n\n[1] 3\n\n(1 + 2) * 3\n\n[1] 9\n\n\nSquare Brackets []: Select elements from objects\n\nvec &lt;- c(1, 2, 3)\nvec[1]\n\n[1] 1\n\n\nCurly Braces {}: Group multiple commands into a single block, allowing them to be evaluated together.\n\n{\n  x &lt;- 5\n  print(x)\n}\n\n[1] 5\n\n\n\n\n\n1.3.6 Commands and Expressions\nAn R command is a complete line of code that directs R to perform a specific action, such as assigning values, loading packages, or analyzing data. Commands produce output and can be executed in the RStudio console. For example, x &lt;- 5 is a command that assigns a value.\nAn R expression is a component of a command or a standalone code segment that evaluates to a value. Within a command like log(2) + exp(5), log(2) is an expression yielding approximately 0.693. Expressions are the building blocks of commands, producing results in R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#an-overview-of-r-objects",
    "href": "intro.html#an-overview-of-r-objects",
    "title": "1  Getting Started with Base R",
    "section": "1.4 An Overview of R Objects",
    "text": "1.4 An Overview of R Objects\nWithin the R language, it is important to recognize that everything is treated as an object. R data objects can be classified based on their dimensionality and whether their contents share the same data type. The five common data types are organized in the following table:\n\n\n\nDimension\nHomogeneous\nHeterogeneous\n\n\n\n\n1\nVector\nList\n\n\n2\nMatrix\nData Frame\n\n\nN\nArray\n\n\n\n\nEach of these R objects possesses unique attributes, and the number of attributes varies from one object to another. When working with objects in R, it is crucial to distinguish between different R objects and to comprehend the distinctions among them.\n\n1.4.1 Storage Mode and Class\nThe characteristics of R objects are often described by their storage mode and class. You can determine the storage mode of each object using the typeof() function. For example:\n\nn1 &lt;- c(1, 4, pi, 10)\nn1\n\n[1]  1.000000  4.000000  3.141593 10.000000\n\ntypeof(n1)\n\n[1] \"double\"\n\n\nThe most frequently encountered modes include numeric (which can be either integer or double), character, and logical. The class attribute provides information about the data structure of an object. It is worth noting that the concept of class is closely related to object-oriented programming, though this is not covered in this course. You can determine the class of each object by using the class() function. For instance, the following command creates a matrix, n2, from n1 using the matrix() function:\n\nn2 &lt;- matrix(n1, nrow = 2)\nn2\n\n     [,1]      [,2]\n[1,]    1  3.141593\n[2,]    4 10.000000\n\ntypeof(n2)  \n\n[1] \"double\"\n\nclass(n2)   \n\n[1] \"matrix\" \"array\" \n\nclass(n1)   \n\n[1] \"numeric\"\n\n\nAn object can belong to more than one class, as seen with n2, which is both a matrix and, more broadly, an array with only two dimensions. It is important to note that the storage mode of n2 remains double. The distinction between n1 and n2 is primarily based on their class: n1 is a one-dimensional vector, while n2 is a matrix, a specific type of array.\nThe following example creates a list using the list() function, and both typeof() and class() functions return list:\n\nl1 &lt;- list(n = c(1, 3), ch = \"a\")\nl1\n\n$n\n[1] 1 3\n\n$ch\n[1] \"a\"\n\ntypeof(l1)  \n\n[1] \"list\"\n\nclass(l1)   \n\n[1] \"list\"\n\n\nYou can generate a data frame using the data.frame() function. A data frame is a particular type of list object. We will delve further into data frames in the upcoming chapter.\n\nd1 &lt;- data.frame(n = 1:26, L = LETTERS)\nd1\n\n    n L\n1   1 A\n2   2 B\n3   3 C\n4   4 D\n5   5 E\n6   6 F\n7   7 G\n8   8 H\n9   9 I\n10 10 J\n11 11 K\n12 12 L\n13 13 M\n14 14 N\n15 15 O\n16 16 P\n17 17 Q\n18 18 R\n19 19 S\n20 20 T\n21 21 U\n22 22 V\n23 23 W\n24 24 X\n25 25 Y\n26 26 Z\n\ntypeof(d1) \n\n[1] \"list\"\n\nclass(d1)   \n\n[1] \"data.frame\"\n\n\nAll these objects will be explored in detail in the next chapter.\n\n\n1.4.2 The is.xxx() Function\nThe function that starts with is. tests whether its argument is of a specified mode or class. The result from this type of function is either TRUE or FALSE. For example, you can use is.numeric(), is.character(), and is.logical() to check if an argument is numeric, character, or logical, respectively.\n\nis.numeric(n2)    \n\n[1] TRUE\n\nis.character(n2)  \n\n[1] FALSE\n\n\nThere are additional is.xxx() functions that can be employed to check whether an argument has a specific data structure, such as is.vector(), is.matrix(), and is.array().\n\nis.vector(n2)   \n\n[1] FALSE\n\nis.matrix(n2)   \n\n[1] TRUE\n\n\n\n\n1.4.3 Displaying Objects\nFor smaller objects, you can easily display them by typing their names. However, many R objects can be considerably large. In such cases, you can employ various R functions to gain insight into the internal structure of an object. Functions like str(), head(), tail(), and more can provide you with a summary of an object’s content and help you explore its properties.\nThe str() function can succinctly display the internal structure of an R object.\n\nstr(n1)  \n\n num [1:4] 1 4 3.14 10\n\nstr(d1)  \n\n'data.frame':   26 obs. of  2 variables:\n $ n: int  1 2 3 4 5 6 7 8 9 10 ...\n $ L: chr  \"A\" \"B\" \"C\" \"D\" ...\n\n\nYou can use the head() or tail() function to display the first or last portions of an object.\n\nhead(d1)  # First 6 rows\n\n  n L\n1 1 A\n2 2 B\n3 3 C\n4 4 D\n5 5 E\n6 6 F\n\ntail(d1)  # Last 6 rows\n\n    n L\n21 21 U\n22 22 V\n23 23 W\n24 24 X\n25 25 Y\n26 26 Z\n\n\n\n\n1.4.4 Missing Values\nMissing data can have a substantial impact on the accuracy and validity of your analyses. If not properly identified and addressed, they can introduce bias and lead to erroneous conclusions.\nIn R, missing values are typically represented as NA, which is a logical vector of length 1. When NA is included within the c() function, it is automatically coerced to the correct data type. It is important to note that missing values can be intentional or may arise from various factors, including computations or data type conversions.\nIn the following example, the missing values result from the as.numeric() function, which attempts to convert a character vector into a numeric vector.\n\nc1 &lt;- c(\"A\", \"B\", \"C\")\nas.numeric(c1) \n\nWarning: NAs introduced by coercion\n\n\n[1] NA NA NA\n\n\nThe is.na() function is a valuable tool for identifying missing values within a vector. It operates by returning a logical vector of the same length as its input, where each element corresponds to the presence or absence of a missing value. For example, if you apply is.na() to a vector, you will obtain a logical vector with TRUE at the positions where missing values are present and FALSE where data is available.\n\nn4 &lt;- c(1, NA, 3)\nis.na(n4)  \n\n[1] FALSE  TRUE FALSE\n\n\nTypically, when performing operations on missing value(s) represented by NA, the result is also a missing value(s) NA. However, almost all descriptive statistical functions, such as sum(), mean(), median(), and others, provide an na.rm= argument, and setting it to na.rm = TRUE allows the removal of missing values during these operations.\n\nsum(n4)       # Returns NA\n\n[1] NA\n\nsum(n4, na.rm = TRUE)  # Returns 4\n\n[1] 4",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#getting-help",
    "href": "intro.html#getting-help",
    "title": "1  Getting Started with Base R",
    "section": "1.5 Getting Help",
    "text": "1.5 Getting Help\nAccessing help resources in R is critical for understanding functions, resolving errors, and developing coding proficiency. R provides built-in tools to access documentation within the environment, complemented by external community resources.\nTo retrieve documentation for a specific function, the help() function or its shorthand, ?, is used. For instance, entering help(matrix) or ?matrix in the console displays the help file for the matrix() function, which creates a matrix from a vector with specified dimensions. Most R help files consist of the following sections, though some may be omitted depending on the function:\n\nDescription: Explains the function’s purpose, stating that matrix() constructs a matrix from a given vector.\nUsage: Shows the function’s syntax, such as matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL).\nArguments: Lists inputs, including data(the input vector), nrow (number of rows), and ncol (number of columns), with explanations of their roles.\nDetails: Provides additional context, such as how matrix() handles vector recycling if the data length does not match the specified dimensions.\nValue: Describes the output, typically the result of the function, though this section is not included in the matrix() help file.\nExamples: Provides sample code demonstrating practical applications, such as creating a 2x2 matrix.\n\nFor operators such as +, -, or ^, the operator must be enclosed in single or double quotes when accessing help:\n\nhelp(\"^\")\n\nTo examine a function’s arguments without opening the full help file, the args() function displays the argument list. For example:\n\nargs(matrix)\n\nfunction (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) \nNULL\n\n\nThis output indicates that matrix() accepts arguments such as data=, nrow=, and ncol=, enabling the creation of a matrix with specified dimensions.\nExternal resources provide additional support. Platforms such as Stack Overflow, the RStudio Community, and R-bloggers offer forums for posing questions and accessing solutions from the R community, enhancing the documentation available within R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#r-packages",
    "href": "intro.html#r-packages",
    "title": "1  Getting Started with Base R",
    "section": "1.6 R Packages",
    "text": "1.6 R Packages\nThe R system comprises two fundamental components: the base R system and contributed packages. The base R system, installed initially, includes essential packages containing core functions, such as matrix() for creating matrices. Additional packages, which extend R’s functionality, are available from repositories like the Comprehensive R Archive Network (CRAN) and Bioconductor.\nTo install a package from CRAN, the install.packages() function is used. For instance, the following command installs the survival package, which provides tools for survival analysis:\n\ninstall.packages(\"survival\")\n\nFor packages from Bioconductor, a repository for bioinformatics tools, the BiocManager::install() function is employed after installing the BiocManager package from CRAN. For example, to install the Biobase package, which supports genomic data analysis, the following commands are used:\n\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"Biobase\")\n\nOnce installed, packages are stored on the computer’s hard drive. To access a package’s functions in an R session, the library() function loads the package into the environment. For example:\n\nlibrary(survival)\n\nFunctions from the base R system, such as matrix(), require no package loading, as they are available by default.\nTo access a specific function from a package without loading it, the :: operator is used, specifying the package and function name, for example: survival::coxph(). This approach allows direct use of a function, such as coxph() from the survival package, without making all package functions readily available, which helps avoid conflicts between packages with similarly named functions.\nExternal resources, such as CRAN’s package documentation and Bioconductor’s support forums, provide further guidance on package usage and troubleshooting, complementing R’s built-in help system.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "intro.html#session-management",
    "href": "intro.html#session-management",
    "title": "1  Getting Started with Base R",
    "section": "1.7 Session Management",
    "text": "1.7 Session Management\n\n1.7.1 Working Directory\nThe working directory serves as the default location for file-related operations in R, such as loading data or saving files. It functions as the primary directory for an R session. To identify the working directory, the getwd() function is used:\n\ngetwd()\n\n[1] \"C:/Users/Public/Desktop\"\n\n\nTo list all files and folders in the working directory, the dir() function is employed:\n\ndir()\n\n[1] \"Adobe Acrobat XI Pro.lnk\" \"Adobe FormsCentral.lnk\"  \n[3] \"desktop.ini\"              \"Firefox.lnk\"             \n[5] \"Google Chrome.lnk\"        \"Mullvad VPN.lnk\"         \n[7] \"R 4.4.1.lnk\"              \"R 4.4.3.lnk\"             \n[9] \"WinEdt 11.lnk\"           \n\n\nTo change the working directory, the setwd() function specifies a new location within the file system. File paths in R should use forward slashes (/) rather than backslashes (\\), as backslashes are not valid in R. For example, a path copied from a Windows environment, such as C:\\Users\\art\\OneDrive, must be converted to use forward slashes:\n\nsetwd(\"C:/Users/art/OneDrive\")\n\nR also supports relative paths using shortcut notations:\n\n\".\" refers to the current directory\n\"..\" refers to the parent directory\n\"./folder\" refers to a subfolder named folder inside the current directory\n\"../folder\" accesses a subfolder one level above\n\nFor example:\n\nsetwd(\"../Documents/data\")\n\n\n\n1.7.2 Workspace\nThe R workspace serves as a temporary storage area for all objects created during a session, including variables, data frames, functions, and other data structures. To view the objects stored in the workspace, the ls() function displays their names in the console:\n\nls()\n\n [1] \"b\"   \"c1\"  \"d1\"  \"l1\"  \"n1\"  \"n2\"  \"n4\"  \"vec\" \"x\"   \"y\"  \n\n\nEach time data is created or loaded, variables are assigned, or calculations are performed, the resulting objects are stored in the workspace, making them available for use throughout the session. For example, assigning a matrix to a variable adds it to the workspace:\n\nm1 &lt;- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2)\nls()\n\n [1] \"b\"   \"c1\"  \"d1\"  \"l1\"  \"m1\"  \"n1\"  \"n2\"  \"n4\"  \"vec\" \"x\"   \"y\"  \n\n\nTo remove specific objects from the workspace, the rm() function is used. For instance, to delete objects named m1 and n1:\n\nrm(m1, n1)\nls()\n\n[1] \"b\"   \"c1\"  \"d1\"  \"l1\"  \"n2\"  \"n4\"  \"vec\" \"x\"   \"y\"  \n\n\nTo clear all objects, the command rm(list = ls()) removes everything listed by ls().\nThe workspace is temporary, and its contents are lost when the session ends unless explicitly saved. To save all workspace objects to a file in the working directory, the save.image() function is used, with the file path specified using forward slashes. For example:\n\nsave.image(\"C:/Users/art/OneDrive/lect1.RData\")\n\nTo save specific objects, the save() function specifies the objects and a file name:\n\nsave(c1, n1, file = \"C:/Users/art/OneDrive/c1_n1.RData\")\n\nAlternatively, to save a single object, the saveRDS() function serializes it to a file:\n\nsaveRDS(c1, file = \"C:/Users/art/OneDrive/c1.RDS\")\n\nTo retrieve saved objects, the load() function restores all objects from a file created by save() or save.image():\n\nload(\"C:/Users/art/OneDrive/lect1.RData\")\n\nTo retrieve a single object saved with saveRDS(), the readRDS() function reads it into the workspace, assigning it to a variable:\n\nc1 &lt;- readRDS(\"C:/Users/art/OneDrive/c1.RDS\")\n\nThese commands load objects from files into the workspace, enabling their use.\n\n\n\n\nPosit. 2025. “RStudio Desktop - Download.” Posit, PBC. https://posit.co/download/rstudio-desktop/.\n\n\nR Core Team. 2025. “R: A Language and Environment for Statistical Computing.” Vienna, Austria: R Foundation for Statistical Computing. https://www.r-project.org/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started with Base R</span>"
    ]
  },
  {
    "objectID": "objects1.html",
    "href": "objects1.html",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "",
    "text": "2.1 Vectors\nVectors are the simplest and most fundamental objects in R, serving as the building blocks for data analysis. They are one-dimensional, homogeneous collections of elements, meaning all elements must share the same data type. This section covers how to create vectors, understand their types and attributes, and perform basic operations like accessing elements and concatenation.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#vectors",
    "href": "objects1.html#vectors",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "",
    "text": "2.1.1 Types of Vectors\nVectors in R are atomic, meaning they cannot contain mixed data types, and come in four common types: integer, double, logical, and character. The c() function, which stands for “concatenate,” is the primary method for creating vectors. To explore a vector’s properties, use typeof() to check its storage mode (data type) and class() to confirm its structure, which for vectors is typically numeric, logical, or character. The length() function returns the number of elements in a vector, reflecting its linear structure.\n\nv &lt;- c(2.9, 3.5, 4.5, NA, 3, 2.4)\nv\n\n[1] 2.9 3.5 4.5  NA 3.0 2.4\n\ntypeof(v)\n\n[1] \"double\"\n\nclass(v)\n\n[1] \"numeric\"\n\nlength(v)\n\n[1] 6\n\n\nBy default, R stores numbers as double (double-precision real numbers). To create an integer vector, append the L suffix to numbers, explicitly indicating integer values. This is often encountered in vectors generated by R functions, such as sequences. For example, functions like seq() or operations in Bioconductor packages, such as those for genomic data analysis, may produce integer vectors to optimize storage efficiency. This is particularly common when handling large datasets where integer types reduce memory usage.\n\ni &lt;- c(1L, 3L, 10L)\ni\n\n[1]  1  3 10\n\ntypeof(i)\n\n[1] \"integer\"\n\nclass(i)\n\n[1] \"integer\"\n\n\nCharacter vectors are common when accessing text data, such as columns in a data frame read from external files. Enclose character values in quotation marks (\" \" or ' '), except for NA, which represents missing values.\n\ncolors &lt;- c(\"red\", \"green\", \"blue\", \"yellow\", NA, \"purple\")\ncolors\n\n[1] \"red\"    \"green\"  \"blue\"   \"yellow\" NA       \"purple\"\n\ntypeof(colors)\n\n[1] \"character\"\n\nclass(colors)\n\n[1] \"character\"\n\n\nLogical vectors, consisting of TRUE or FALSE (also T or F), often result from comparisons (covered later in this chapter). They are useful for filtering or conditional operations.\n\nlogical_vec &lt;- c(TRUE, NA, T, F)\ntypeof(logical_vec)\n\n[1] \"logical\"\n\nclass(logical_vec)\n\n[1] \"logical\"\n\n\n\n\n2.1.2 Accessing Elements in a Vector\nA common task is accessing or extracting elements from a vector. This section introduces positional indexing, one of five methods for accessing elements (additional methods are covered in Chapter 4). Since vectors are linear, elements are indexed by their position (1, 2, …, N). Use square brackets [] with an index vector to select elements. An index vector specifies the positions of elements to extract from the target vector.\n\nv &lt;- c(2.9, 3.5, 4.5, NA, 3, 2.4) \nv[1]\n\n[1] 2.9\n\n\nTo select multiple elements, create an index vector using c(). For example, to extract the first, second, and fourth elements:\n\nv[c(1,2,4)]\n\n[1] 2.9 3.5  NA\n\n\nFor consecutive elements, use the colon operator (:) to generate a sequence of positions. The following selects the second through fifth elements:\n\nv[2:5]\n\n[1] 3.5 4.5  NA 3.0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#attributes",
    "href": "objects1.html#attributes",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.2 Attributes",
    "text": "2.2 Attributes\nAttributes are metadata associated with R objects, such as vectors, providing additional information like names or custom descriptors. They enhance data organization and accessibility, especially in data analysis tasks.\n\n2.2.1 The Names Attribute\nVectors can have a names attribute to label elements, making them easier to reference. Use the names() function to assign or retrieve names.\n\nv &lt;- c(2, 3, 3.5, 6.7) \nnames(v) &lt;- c(\"a\", \"b\", \"c\", \"d\")\nv\n\n  a   b   c   d \n2.0 3.0 3.5 6.7 \n\nnames(v)\n\n[1] \"a\" \"b\" \"c\" \"d\"\n\n\nElements can be accessed using names within square brackets, offering a descriptive alternative to positional indexing.\n\nv[\"a\"]\n\na \n2 \n\nv[c(\"a\", \"c\")]\n\n  a   c \n2.0 3.5 \n\n\nNames can also be assigned during vector creation using the c() function with named arguments.\n\nv &lt;- c(first=1, second=pi, third = sqrt(2))\nv\n\n   first   second    third \n1.000000 3.141593 1.414214 \n\n\nA vector with a names attribute is called a named vector, commonly used for clarity in data analysis.\n\n\n2.2.2 User-defined Attributes\nBeyond the names attribute, you can create custom attributes using the attr() function. This allows attaching metadata, such as creation dates or descriptions, to objects. Use attr() to set or retrieve specific attributes, and attributes() to view all attributes.\n\nattr(v, \"when\") &lt;- \"Created on 6/24/25\"\nv\n\n   first   second    third \n1.000000 3.141593 1.414214 \nattr(,\"when\")\n[1] \"Created on 6/24/25\"\n\nattr(v, \"when\")\n\n[1] \"Created on 6/24/25\"\n\nattr(v, \"names\")\n\n[1] \"first\"  \"second\" \"third\" \n\nattributes(v)\n\n$names\n[1] \"first\"  \"second\" \"third\" \n\n$when\n[1] \"Created on 6/24/25\"\n\n\nThe attributes() function returns a list, highlighting that attributes are stored as a list object. As emphasized in Chapter 1, “everything in R is an object,” so always check the type and structure of function outputs using typeof() and class() to build proficiency.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#concatenation",
    "href": "objects1.html#concatenation",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.3 Concatenation",
    "text": "2.3 Concatenation\nConcatenation involves combining vectors of the same data type to create a larger vector. The c() function is the primary tool for this operation, essential for data manipulation tasks.\n\n2.3.1 Concatenating Vectors\nTo combine vectors, use c() to append elements or vectors.\n\nv\n\n   first   second    third \n1.000000 3.141593 1.414214 \nattr(,\"when\")\n[1] \"Created on 6/24/25\"\n\nv1 &lt;- c(v, 3)\nv1\n\n   first   second    third          \n1.000000 3.141593 1.414214 3.000000 \n\nv2 &lt;- c(v, v1)\nv2\n\n   first   second    third    first   second    third          \n1.000000 3.141593 1.414214 1.000000 3.141593 1.414214 3.000000 \n\nv3 &lt;-  c(v, extra = 3)\nv3\n\n   first   second    third    extra \n1.000000 3.141593 1.414214 3.000000 \n\n\nThe extra name in the last example assigns a label to the new element, preserving the original names from v while adding a descriptive identifier for clarity.\n\n\n2.3.2 Coercion\nWhen combining vectors of different data types, R applies coercion to convert them to a common type, following the hierarchy: logical → integer → double → character. This ensures operations proceed without errors but may affect data integrity.\nFor implicit coercion, R automatically converts types based on the hierarchy.\n\ntypeof(c(FALSE, 1L))\n\n[1] \"integer\"\n\ntypeof(c(1L, pi))\n\n[1] \"double\"\n\ntypeof(c(pi, \"pi\"))\n\n[1] \"character\"\n\n\nExplicit coercion uses as.xxx() functions (e.g., as.numeric(), as.character()) to control type conversion.\n\nas.logical(c(FALSE, 1L))\n\n[1] FALSE  TRUE\n\n\nCoercion can lead to data loss or missing values. For example, converting doubles to integers truncates decimals, and non-numeric characters to numbers produce NA.\n\nas.integer(c(1L, pi))\n\n[1] 1 3\n\nas.double(c(pi, \"pi\"))\n\nWarning: NAs introduced by coercion\n\n\n[1] 3.141593       NA\n\n\nBe cautious with coercion to avoid unintended data loss, and always verify the resulting data type using typeof() or class().",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#vectorized-operations",
    "href": "objects1.html#vectorized-operations",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.4 Vectorized Operations",
    "text": "2.4 Vectorized Operations\nVectorized operations are a cornerstone of R, enabling efficient and concise data manipulation by applying computations to entire vectors in a single expression. Unlike traditional programming languages that require explicit loops, R’s vectorized approach leverages optimized C and Fortran code, making it ideal for statistical computing and large datasets. This section explores how vectorized operations work on vectors, including element-wise arithmetic, scalar operations, and recycling, laying the groundwork for comparisons that produce logical vectors later in this chapter.\n\n2.4.1 Element-Wise Arithmetic\nWhen applying an arithmetic operation (e.g., +, -, *, /) to two vectors of the same length, R performs the operation element-wise, producing a new vector of the same length. Each element in the result corresponds to the operation applied to the paired elements of the input vectors.\n\nv1 &lt;- c(1, 2, 3)\nv2 &lt;- c(4, 5, 6)\nv1 + v2\n\n[1] 5 7 9\n\nv1 * v2\n\n[1]  4 10 18\n\n\nIn these examples, R adds or multiplies corresponding elements: \\(1 + 4 =5\\), \\(2 + 5 = 7\\), \\(3 + 6 = 9\\) for addition, and \\(1 \\times 4 = 4\\), \\(2 \\times 5 = 10\\), \\(3 \\times 6 = 18\\) for multiplication.\n\n\n2.4.2 Scalar Operations\nVectorized operations allow a single value (scalar) to be applied to every element of a vector. R automatically recycles the scalar to match the vector’s length, simplifying tasks like scaling or offsetting data values.\n\nv1 &lt;- c(1, 2, 3)\nv1 + 5\n\n[1] 6 7 8\n\nv1 * 2\n\n[1] 2 4 6\n\n\nHere, R adds 5 or multiplies by 2 for each element of v1, equivalent to operating with a vector c(5, 5, 5) or c(2, 2, 2).\n\n\n2.4.3 Recycling with Unequal Lengths\nWhen vectors have different lengths, R recycles the shorter vector to match the longer one’s length. If the longer vector’s length is a multiple of the shorter one, recycling is seamless. Otherwise, R issues a warning but completes the operation.\n\nv3 &lt;- c(7, 8)\nv1 + v3\n\nWarning in v1 + v3: longer object length is not a multiple of shorter object\nlength\n\n\n[1]  8 10 10\n\n\nIn this example, v3 is recycled as c(7, 8, 7) to match v1’s length, adding element-wise: \\(1+7=8\\), \\(2+8=10\\), \\(3+7=10\\). Be cautious with recycling, as mismatched lengths may lead to unintended results. Use length() to verify vector lengths before operations to avoid such issues.\n\n\n2.4.4 Vectorized Functions\nMany Base R functions, such as sqrt() and log(), are vectorized, applying computations to each element of a vector without loops. These are useful for transforming data in statistical analyses.\n\nv1 &lt;- c(1, 4, 9)\nsqrt(v1)\n\n[1] 1 2 3\n\nlog(v1)\n\n[1] 0.000000 1.386294 2.197225",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#numeric-vectors",
    "href": "objects1.html#numeric-vectors",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.5 Numeric Vectors",
    "text": "2.5 Numeric Vectors\nNumeric vectors, encompassing both integer and double types, are essential for quantitative data analysis in R. While the c() function is ideal for creating small vectors without patterns, R provides specialized functions like seq(), rep(), and random number generators to efficiently create numeric vectors with specific patterns or distributions. This section explores these functions, enabling you to generate sequences, replicate values, and simulate data, building on the vector concepts from earlier sections.\n\n2.5.1 The seq() Function\nThe colon operator (:) generates a sequence of integers with a step size of 1, in ascending or descending order.\n\n2:6\n\n[1] 2 3 4 5 6\n\n4:-3\n\n[1]  4  3  2  1  0 -1 -2 -3\n\n\nThe more frequently used method for generating a sequence of numbers is by employing the seq() function. The first two arguments, named from= and to=, define the starting and ending points of the sequence.\n\nseq(5, 10)\n\n[1]  5  6  7  8  9 10\n\n\nThe by= argument specifies the step size, while length.out= sets the desired number of elements. These arguments are mutually exclusive, as specifying both would create ambiguity in the sequence’s structure.\n\nseq(2, 20, by=3)\n\n[1]  2  5  8 11 14 17 20\n\nseq(2, 20, length.out=7)\n\n[1]  2  5  8 11 14 17 20\n\n\nThe seq_along() function generates a sequence of integers from 1 to the length of a given vector, useful for creating indices for data analysis tasks.\n\nmy_vector &lt;- c(\"apple\", \"banana\", \"cherry\")\nseq_along(my_vector)\n\n[1] 1 2 3\n\n\nThis sequence corresponds to the positions of elements in my_vector, facilitating tasks like iterating over vector elements.\n\n\n2.5.2 The rep() Function\nThe rep() function replicates a vector or its elements, offering flexibility for creating repeated patterns. Its main arguments are x= (the vector to replicate) and times= (the number of repetitions).\nWhen times is a single integer, the entire vector x is repeated that number of times.\n\ni &lt;- rep(2, 4)\ni\n\n[1] 2 2 2 2\n\nx &lt;- 1:4\ny &lt;- rep(x, 2)\ny\n\n[1] 1 2 3 4 1 2 3 4\n\n\nWhen times is a vector of the same length as x, each element x[i] is repeated times[i] times, allowing customized repetition patterns.\n\nz &lt;- rep(x, i)\nz\n\n[1] 1 1 2 2 3 3 4 4\n\nw &lt;- rep(x, x)\nw\n\n [1] 1 2 2 3 3 3 4 4 4 4\n\n\nUse length() to verify the resulting vector’s length, especially for complex repetition patterns.\n\n\n2.5.3 The Random Number Generator Functions\nRandom number generators in R create vectors based on probability distributions, such as uniform or normal, and are named with the prefix r (e.g., runif(), rnorm()). These functions are valuable for simulations in statistics and data analysis. Below is a table of common random number generators and their distributions.\n\n\n\nFunction\nDistribution\n\n\n\n\nrunif(n, min=0, max=1)\nUniform\n\n\nrnorm(n, mean=0, sd=1)\nNormal\n\n\nrbinom(n, size, prob)\nBinomial\n\n\nrpois(n, lambda)\nPoisson\n\n\nrexp(n, rate = 1)\nExponential\n\n\nrt(n, df)\nT\n\n\nrf(n, df1, df2)\nF\n\n\nrchisq(n, df)\nChi square\n\n\n\nTo generate 100 numbers from a normal distribution with mean 2 and standard deviation 3:\n\nn &lt;- rnorm(100, 2, 3)\nhead(n)\n\n[1]  0.7977841  4.0509202  4.3685625 -0.7756218  2.3435378  5.1765714\n\nmean(n)\n\n[1] 2.105272\n\nsd(n)\n\n[1] 3.453465\n\n\nThe set.seed() function ensures reproducibility by fixing the random number generator’s starting point. Setting the same seed produces identical random sequences, which is crucial for debugging and sharing results.\n\nset.seed(123)\nrandom_vector1 &lt;- rnorm(5, mean = 0, sd = 1)\nrandom_vector1\n\n[1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774\n\nset.seed(123)\nrandom_vector2 &lt;- rnorm(5, mean = 0, sd = 1)\nrandom_vector2\n\n[1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774\n\n\nAlways set a seed before generating random numbers to ensure consistent results across sessions.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#logical-vectors",
    "href": "objects1.html#logical-vectors",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.6 Logical Vectors",
    "text": "2.6 Logical Vectors\nLogical vectors, consisting of TRUE and FALSE values, are fundamental for conditional operations and data filtering in R. Logical Vectors are often generated through comparisons and manipulated using logical operators. This section explores how to create logical vectors with relational operators, handle missing values, apply Boolean algebra, and use logical vectors in practical data analysis tasks, such as counting or summarizing conditions.\n\n2.6.1 Generating Logical Vectors\nLogical vectors are commonly created using relational operators: &lt;, &lt;=, &gt;, &gt;=, == (exact equality), and != (exact inequality). These operators compare vectors element-wise, producing a logical vector where TRUE indicates the condition is met and FALSE indicates it is not.\n\nv &lt;- c(seq(2, 4), NA)\nv &gt; 3\n\n[1] FALSE FALSE  TRUE    NA\n\n\nIn this example, v &gt; 3 checks if each element exceeds 3, returning NA for missing values. Be cautious when using == with numeric vectors due to floating-point precision issues.\n\nx &lt;- c(1 / 49 * 49, sqrt(2)^2)\nx\n\n[1] 1 2\n\nx == c(1, 2)\n\n[1] FALSE FALSE\n\n\nThe which() function converts a logical vector to an integer vector of indices where the condition is TRUE, ignoring NA values.\n\nwhich(v &gt; 3)\n\n[1] 3\n\n\n\n\n2.6.2 Handling Missing Values\nOperations involving missing values (NA) in logical vectors typically result in NA, as the outcome depends on an unknown value.\n\nNA &gt; 5\n\n[1] NA\n\n10 == NA\n\n[1] NA\n\nNA == NA\n\n[1] NA\n\n\nUse is.na(), introduced in Chapter 1, to identify missing values in any vector type, returning TRUE for NA and FALSE otherwise.\n\nis.na(c(1, NA, 3))\n\n[1] FALSE  TRUE FALSE\n\nis.na(c(\"a\", NA, \"b\"))\n\n[1] FALSE  TRUE FALSE\n\nis.na(c(TRUE, NA, FALSE))\n\n[1] FALSE  TRUE FALSE\n\n\n\n\n2.6.3 Logical Operators and Boolean Algebra\nLogical operators &, |, and ! perform element-wise Boolean algebra on logical vectors. The & operator returns TRUE for elements where both vectors are TRUE (logical AND), | returns TRUE if at least one is TRUE (logical OR), and ! negates the vector.\n\nh &lt;- c(1, 10, 3.5, 8, 8)\nh1 &lt;- h &gt; 5\nh1\n\n[1] FALSE  TRUE FALSE  TRUE  TRUE\n\nh2 &lt;- h == 8\nh2 \n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\nh1 & h2\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\nh1 | h2\n\n[1] FALSE  TRUE FALSE  TRUE  TRUE\n\n!h1\n\n[1]  TRUE FALSE  TRUE FALSE FALSE\n\n\nFor missing values, Boolean operations follow specific rules due to the ambiguity of NA, which could be either TRUE or FALSE. The result and reasoning are summarized in the tables below.\nOR Logic (|)\n\n\n\n\n\n\n\n\nX\nx | NA\nreasoning\n\n\n\n\nTRUE\nTRUE\nAt least one is TRUE - result is guaranteed TRUE\n\n\nFALSE\nNA\nNA could be TRUE or FALSE - result is unknown\n\n\nNA\nNA\nBoth values unknown - result is unknown\n\n\n\nAND Logic (&)\n\n\n\n\n\n\n\n\nX\nx & NA\nreasoning\n\n\n\n\nTRUE\nNA\nNA could be TRUE or FALSE - result is unknown\n\n\nFALSE\nFALSE\nOne is FALSE - result is guaranteed FALSE\n\n\nNA\nNA\nBoth values unknown - result is unknown\n\n\n\nThe %in% operator checks if elements of one vector are present in another, returning TRUE for matches. Unlike ==, NA %in% NA is TRUE.\n\nc(1, 2, NA) %in% NA\n\n[1] FALSE FALSE  TRUE\n\nc(1, 2, NA) == NA\n\n[1] NA NA NA\n\nc(1:5, NA) %in% c(1, 5, 11)\n\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n\n\n\n\n2.6.4 The all() and any() Functions\nThe all() and any() functions summarize logical vectors. all() returns TRUE if all elements are TRUE, while any() returns TRUE if at least one element is TRUE. Missing values may affect results unless handled with na.rm=TRUE.\n\nf &lt;- c(3.01, 3.001, 3.0001, 3.00001)\nany (f == 3.001, na.rm=TRUE)\n\n[1] TRUE\n\nany (f &gt;3.1, na.rm=TRUE)\n\n[1] FALSE\n\nall (f &gt; 3.001, na.rm=TRUE)\n\n[1] FALSE\n\n\nInstead of using the any() or all() functions, we can solve problems based on what we’ve learned. For example, the following commands illustrates how to test if any elements in F equal 3.001?\nInstead of relying solely on any() or all(), you can use techniques learned earlier. For example, to test if any elements in f equal 3.001, follow these steps:\n\n## Step 1: Compare f with 3.001 using ==\nf == 3.001\n\n[1] FALSE  TRUE FALSE FALSE\n\n## Step 2: Count the number of elements in f equal to 3.001\nsum(f == 3.001, na.rm=TRUE)\n\n[1] 1\n\n## Step 3: Check if the count is greater than 0\nsum(f == 3.001, na.rm=TRUE) &gt; 0\n\n[1] TRUE\n\n\n\n\n2.6.5 Numeric Summaries\nLogical vectors are coerced to numeric values in arithmetic operations, with TRUE as 1 and FALSE as 0. This enables counting or proportion calculations, such as determining how many elements meet a condition. Additionally, mean() gives the proportion of TRUE values where x is a logical vector.\n\nv &lt;- c(seq(1, 6, by=0.5), 10)\nmean_v &lt;- mean(v, na.rm=TRUE)\nmean_v\n\n[1] 4.041667\n\nv &gt; mean_v\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nsum(v &gt; mean_v)\n\n[1] 5\n\nmean(v &gt; mean_v)\n\n[1] 0.4166667\n\n\nIn this example, sum(v &gt; mean_v) counts elements greater than the mean, and mean(v &gt; mean_v) gives the proportion.\nFor a vector with missing values, use na.rm=TRUE to compute the proportion accurately.\n\nv_with_na &lt;- c(1, 2, 3, NA, 5)\nmean(v_with_na &gt; 3, na.rm=TRUE)\n\n[1] 0.25\n\n\nIn this case, v_with_na &gt; 3 yields [FALSE FALSE FALSE NA TRUE], and mean(v_with_na &gt; 3, na.rm=TRUE) excludes the NA, giving a proportion of 0.25 (or 25%) based on the one TRUE value out of four non-missing elements.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#factors",
    "href": "objects1.html#factors",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.7 Factors",
    "text": "2.7 Factors\nFactors are a specialized type of vector in R, designed to represent categorical data with a fixed set of levels. Unlike character vectors, factors impose an order on their values, which is useful for statistical modeling and data analysis. This section covers the creation of factors, their sorting behavior, handling of invalid levels, and basic subsetting, building on the vector concepts from earlier sections.\n\n2.7.1 Creating and Sorting Factors\nFactors are created using the factor() function, which converts a vector (typically character) into a factor by defining its levels with the levels= argument. Without specified levels, factor() assigns levels alphabetically based on the input, which may vary across systems.\n\nx1 &lt;- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\")\nfactor(x1)\n\n[1] Dec Apr Jan Mar\nLevels: Apr Dec Jan Mar\n\n\nTo impose a meaningful order, provide a levels= argument. The sort() function then respects this order rather than alphabetical sorting. Controlling the levels is important for statistical models because the first level is treated as the baseline, influencing coefficient interpretation.\n\nmonth_levels &lt;- c(\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n)\ny1 &lt;- factor(x1, levels=month_levels)\nsort(y1)\n\n[1] Jan Mar Apr Dec\nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nlevels(y1)\n\n [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n\ntypeof(y1)\n\n[1] \"integer\"\n\nclass(y1)\n\n[1] \"factor\"\n\nnlevels(y1)\n\n[1] 12\n\n\nTo convert a factor to a character vector, you can use the as.character() function.\n\nas.character(y1)\n\n[1] \"Dec\" \"Apr\" \"Jan\" \"Mar\"\n\n\nIf the input contains invalid levels (not in levels=), R assigns NA to those elements.\n\nx2 &lt;- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\")\ny2 &lt;- factor(x2, levels=month_levels)\ny2\n\n[1] Dec  Apr  &lt;NA&gt; Mar \nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\n\nNote that sorting is not meaningful for factors without defined levels, and system-dependent alphabetical order can lead to inconsistent results.\n\n\n2.7.2 Subsetting a Factor\nYou can extract elements from a factor using an index vector within square brackets. In the following example, a new factor is created containing only the first three elements of f. In f1, the oc level is empty but still part of the levels attribute, keeping the number of levels at 3. This can complicate interpretation in statistical functions.\n\nf &lt;- factor(c(\"la\", \"sb\", \"la\", \"oc\"), levels=c(\"la\", \"sb\", \"oc\"))\nf1 &lt;- f[1:3]\nf1\n\n[1] la sb la\nLevels: la sb oc\n\nnlevels(f1)\n\n[1] 3\n\n\nTo remove unused levels, use the following methods:\n\nfactor(f[1:3])\n\n[1] la sb la\nLevels: la sb\n\nf[1:3, drop=TRUE]\n\n[1] la sb la\nLevels: la sb\n\n\nThe drop=TRUE argument or reapplying factor() ensures unused levels are excluded, improving clarity in downstream analysis.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects1.html#matrices-and-arrays",
    "href": "objects1.html#matrices-and-arrays",
    "title": "2  Objects - Vectors, Matrices, and Arrays",
    "section": "2.8 Matrices and Arrays",
    "text": "2.8 Matrices and Arrays\nMatrices and arrays provide structured storage for data in tabular or multi-dimensional formats, extending the capabilities of vectors. This organization facilitates understanding and manipulation, especially in statistical and numerical computations. R offers optimized functions and operations for matrices and arrays, often outperforming vector-based approaches for larger datasets. This section explores their creation, concatenation, attributes, and basic element access, building on the vector foundation from earlier sections.\n\n2.8.1 Creating a Matrix\nA matrix is a two-dimensional array, created by assigning a dim attribute with two values (rows, columns) to a vector. The storage mode of the matrix matches that of its elements (e.g., double, integer).\n\nv &lt;- c(2.9, 3.5, 4.5, NA, 3, 2.4)\nv\n\n[1] 2.9 3.5 4.5  NA 3.0 2.4\n\ndim(v) &lt;- c(2,3)\nv\n\n     [,1] [,2] [,3]\n[1,]  2.9  4.5  3.0\n[2,]  3.5   NA  2.4\n\n\nAlternatively, use the matrix() function, which offers more control. By default, it fills the matrix column-wise.\n\nm &lt;- matrix(v, nrow=2, ncol=3)\nm\n\n     [,1] [,2] [,3]\n[1,]  2.9  4.5  3.0\n[2,]  3.5   NA  2.4\n\n\nTo fill row-wise, set byrow=TRUE.\n\nm1 &lt;- matrix(v, 2, 3, byrow = TRUE)\nm1\n\n     [,1] [,2] [,3]\n[1,]  2.9  3.5  4.5\n[2,]   NA  3.0  2.4\n\n\nThe t() function transposes a matrix, swapping rows and columns.\n\nt(m)\n\n     [,1] [,2]\n[1,]  2.9  3.5\n[2,]  4.5   NA\n[3,]  3.0  2.4\n\n\n\n\n2.8.2 Concatenating Matrices\nThe cbind() and rbind() functions combine vectors or matrices by columns or rows, respectively. For cbind(), all arguments must have the same number of rows; for rbind(), the same number of columns is required.\n\nn1 &lt;- matrix(1:4, nrow=2)\nn1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nn2 &lt;- matrix(5:10, nrow=2)\nn2\n\n     [,1] [,2] [,3]\n[1,]    5    7    9\n[2,]    6    8   10\n\ncbind(n1, n2)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n\nrbind(v, n2)\n\n     [,1] [,2] [,3]\n[1,]  2.9  4.5  3.0\n[2,]  3.5   NA  2.4\n[3,]  5.0  7.0  9.0\n[4,]  6.0  8.0 10.0\n\n\nIf the number of rows or columns differs, cbind() and rbind() may recycle elements or throw an error. For mismatched dimensions, Base R does not provide direct functions to align them automatically. Instead, consider package functions: plyr::rbind.fill() from the plyr package and dplyr::bind_rows() from the dplyr package for row binding, which can handle varying column numbers by filling with NA where needed.\nNote: Ensure compatible dimensions to avoid errors or unexpected recycling; use external packages for flexible concatenation.\n\n\n2.8.3 Matrix Attributes\nMatrices do not have a names attribute by default, but row and column names can be assigned using rownames() and colnames().\n\nrownames(v) &lt;- c(\"r1\", \"r2\")\ncolnames(v) &lt;- c(\"c1\", \"c2\", \"c3\")\nv\n\n    c1  c2  c3\nr1 2.9 4.5 3.0\nr2 3.5  NA 2.4\n\n\nThe dimnames() function assigns both row and column names simultaneously.\n\ndimnames(v) &lt;- list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\", \"c3\"))\nv\n\n    c1  c2  c3\nr1 2.9 4.5 3.0\nr2 3.5  NA 2.4\n\n\nUse length() for the total number of elements, but nrow(), ncol(), and dim() provide more meaningful dimension details. The attributes() function lists all attributes.\n\nlength(v)\n\n[1] 6\n\nnrow(v)\n\n[1] 2\n\nncol(v)\n\n[1] 3\n\ndim(v)\n\n[1] 2 3\n\nattributes(v)\n\n$dim\n[1] 2 3\n\n$dimnames\n$dimnames[[1]]\n[1] \"r1\" \"r2\"\n\n$dimnames[[2]]\n[1] \"c1\" \"c2\" \"c3\"\n\n\n\n\n2.8.4 Accessing Elements in a Matrix\nMatrix elements are accessed using two index vectors within square brackets, denoted as a[m, n], where m selects rows and n selects columns. Separate m and n with a comma. Omitting m (e.g., a[, n]) selects all rows for the specified columns, and omitting n (e.g., a[m, ]) selects all columns for the specified rows.\n\nv[2,3]\n\n[1] 2.4\n\nv[2,]\n\n c1  c2  c3 \n3.5  NA 2.4 \n\nv[,3]\n\n r1  r2 \n3.0 2.4 \n\n\nNote: This basic access is foundational; advanced indexing is covered in Chapter 4.\n\n\n2.8.5 Creating Arrays\nArrays are multi-dimensional extensions of matrices, created by specifying a dim attribute with a length of three or more. For example:\n\nx &lt;- 1:12\ndim(x) &lt;- c(2,2,3)\ndimnames(x) &lt;- list(c(\"r1\", \"r2\"), \n                    c(\"cl\", \"c2\"), \n                    c(\"pl\", \"p2\", \"p3\"))\nx\n\n, , pl\n\n   cl c2\nr1  1  3\nr2  2  4\n\n, , p2\n\n   cl c2\nr1  5  7\nr2  6  8\n\n, , p3\n\n   cl c2\nr1  9 11\nr2 10 12\n\nattributes(x)\n\n$dim\n[1] 2 2 3\n\n$dimnames\n$dimnames[[1]]\n[1] \"r1\" \"r2\"\n\n$dimnames[[2]]\n[1] \"cl\" \"c2\"\n\n$dimnames[[3]]\n[1] \"pl\" \"p2\" \"p3\"\n\n\nAlternatively, use the array() function.\n\nx &lt;- array(1:12, c(2,2,3))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects - Vectors, Matrices, and Arrays</span>"
    ]
  },
  {
    "objectID": "objects2.html",
    "href": "objects2.html",
    "title": "3  Objects - Lists and Data Frames",
    "section": "",
    "text": "3.1 Lists\nLists in R are essential because they can hold different types of data—such as vectors, matrices, data frames, or even other lists—making them ideal for creating your own functions. This flexibility is a game-changer in statistical work, where many R functions return results as lists, and mastering list manipulation is key to exploring those outputs. In this section, you’ll learn how to build and work with lists, a crucial skill for data analysis in R.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objects - Lists and Data Frames</span>"
    ]
  },
  {
    "objectID": "objects2.html#lists",
    "href": "objects2.html#lists",
    "title": "3  Objects - Lists and Data Frames",
    "section": "",
    "text": "3.1.1 Basic List Creation\nTo create a list, the list() function is utilized. The following example generates a list with three components: the first is a character vector, the second is a matrix, and the last one is a numeric vector.\n\na &lt;- list(c(\"a\", \"d\"), \n          matrix(1:4, nrow=2), \n          rep(c(1,2), 2))\na\n\n[[1]]\n[1] \"a\" \"d\"\n\n[[2]]\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n[[3]]\n[1] 1 2 1 2\n\n\nBecause a list is linear, similar to a vector, you can assign the names attribute to a list using the names() function. For example:\n\nnames(a) &lt;- c(\"one\", \"two\", \"three\")\na\n\n$one\n[1] \"a\" \"d\"\n\n$two\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n$three\n[1] 1 2 1 2\n\n\nAlternatively, you can create a list and simultaneously assign the names attribute using the name = value syntax.\n\na &lt;- list(one = c(\"a\", \"d\"), \n          two = matrix(1:4, nrow=2), \n          three = rep(c(1,2), 2))\nattributes(a)\n\n$names\n[1] \"one\"   \"two\"   \"three\"\n\n\nThe names() function not only assigns names but can also retrieve names from a list. Additionally, as a list is linear, the length() function can be employed to count the number of elements in a list.\n\nnames(a)\n\n[1] \"one\"   \"two\"   \"three\"\n\nlength(a)\n\n[1] 3\n\n\n\n\n3.1.2 Empty List\nYou can also create an empty list using list() with no arguments, which is useful for initializing a list to be populated later. It is also used with a loop since you can concatenate to an empty list at every iteration, building a collection of results.\n\nempty_list &lt;- list()\nempty_list\n\nlist()\n\n\nCheck its properties: length(empty_list) returns 0, and is.list(empty_list) confirms it’s a list.\n\nlength(empty_list)\n\n[1] 0\n\nis.list(empty_list)\n\n[1] TRUE\n\n\nYou can add elements to an empty list, for example:\n\nempty_list[[1]] &lt;- c(1, 2)\nempty_list\n\n[[1]]\n[1] 1 2\n\n\n\n\n3.1.3 Nested and Concatenated Lists\nLists are sometimes referred to as recursive vectors because they can contain other lists. In the following example,b contains two components: the first one is the list we just created, named a, and the second component is a factor.\n\nb &lt;- list(a, factor(\"a\"))\nb\n\n[[1]]\n[[1]]$one\n[1] \"a\" \"d\"\n\n[[1]]$two\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n[[1]]$three\n[1] 1 2 1 2\n\n\n[[2]]\n[1] a\nLevels: a\n\nlength(b)\n\n[1] 2\n\n\nWe often use the str() function to display a list with a large number of components or a list containing other lists. The str() function presents an object in a compact form and clearly shows its hierarchy.\n\nstr(b)\n\nList of 2\n $ :List of 3\n  ..$ one  : chr [1:2] \"a\" \"d\"\n  ..$ two  : int [1:2, 1:2] 1 2 3 4\n  ..$ three: num [1:4] 1 2 1 2\n $ : Factor w/ 1 level \"a\": 1\n\n\nSimilar to concatenating vectors, you can use the c() function to concatenate lists.\n\nc &lt;- c(A = a, B = b)\nstr(c)\n\nList of 5\n $ A.one  : chr [1:2] \"a\" \"d\"\n $ A.two  : int [1:2, 1:2] 1 2 3 4\n $ A.three: num [1:4] 1 2 1 2\n $ B1     :List of 3\n  ..$ one  : chr [1:2] \"a\" \"d\"\n  ..$ two  : int [1:2, 1:2] 1 2 3 4\n  ..$ three: num [1:4] 1 2 1 2\n $ B2     : Factor w/ 1 level \"a\": 1\n\n\n\n\n3.1.4 Accessing Components in a List\nIn R, both [ and [[ are used to access components from a list, but they behave differently.\nThe [ operator is used to extract sublists or elements from a list. It returns a sublist (another list). When using [, the result is always a list. Similar to accessing elements of a vector, you can specify the index position within square brackets. In the first example below, it accesses the first component, while in the second example, it returns the first, third, and fourth components.\n\nd &lt;- list(1, matrix(1:4, nrow=2), c(\"a\", \"d\"), list(\"John\"))\nd[2]\n\n[[1]]\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ntypeof(d[2])\n\n[1] \"list\"\n\nd[c(1,3,4)]\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\" \"d\"\n\n[[3]]\n[[3]][[1]]\n[1] \"John\"\n\ntypeof(d[c(1,3,4)])\n\n[1] \"list\"\n\n\nThe [[ double square bracket operator is used for extracting a single element from a list. It directly accesses the contents of the specified element rather than returning a sublist. When using [[, the result is the actual element, not a list containing that element.\nIn the example below, d[[2]] returns the second component, which is a matrix. In the expression d[[3]][1], [[3]] returns the third element, a character vector, and then [1] extracts the first element of the returned character vector.\n\nd[[2]]\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ntypeof(d[[2]])\n\n[1] \"integer\"\n\nclass(d[[2]])\n\n[1] \"matrix\" \"array\" \n\nd[[3]][1]\n\n[1] \"a\"\n\n\nWe cannot access more than one component from a list using double brackets. For example, [[3:4]] is not allowed.\nWhen a list is assigned names, we can access its elements by providing the component names.\n\nnames(d) &lt;- c(\"a\", \"b\", \"c\", \"d\")\nd[\"b\"]\n\n$b\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nd[c(\"a\", \"c\", \"d\")]\n\n$a\n[1] 1\n\n$c\n[1] \"a\" \"d\"\n\n$d\n$d[[1]]\n[1] \"John\"\n\n\nFor a list with names, we can also use the dollar sign ($) operator to return a single element. This behavior is similar to using the double [[. That means, $ only returns the actual element, not a list containing that element.\n\nd[[\"b\"]]\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nd$b\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\n\n\n3.1.5 Manipulating Lists\nMost statistical functions in R, such as those for regression or summary statistics, return results as lists, making list manipulation a common and essential task for data analysis. Lists can be manipulated using various functions, especially when working with statistical models. Many methods are designed to interact with list objects, such as summarizing models, making predictions, and extracting coefficients.\nTo demonstrate these methods, we’ll use the cars dataset, a built-in R dataset containing 50 observations of speed and stopping distance for cars.\n\nhead(cars)\n\n  speed dist\n1     4    2\n2     4   10\n3     7    4\n4     7   22\n5     8   16\n6     9   10\n\ndim(cars)\n\n[1] 50  2\n\n\nWe can fit a linear model to this data using the lm() function, which stands for “linear model.” The lm() function requires a formula to specify the relationship between variables. Below are examples of formula formats in R and their corresponding mathematical equations:\n\ny ~ x: \\(y = \\alpha + \\beta x\\)\nlog(y) ~ x1+x2: \\(\\log(y) = \\beta_{0} + \\beta_{1} x_{1}+ \\beta_{1} x_{2}\\)\ny ~ x1*x2: \\(y = \\beta_{0} + \\beta_{1} x_{1}+ \\beta_{1} x_{2} + \\beta_{3}x_{1}x_{2}\\)\n\n\ntypeof(y ~ x)\n\n[1] \"language\"\n\nclass(y ~ x)\n\n[1] \"formula\"\n\n\nLet’s create a model to predict stopping distance based on speed:\n\nm &lt;- lm(dist ~ speed, data = cars)\nm\n\n\nCall:\nlm(formula = dist ~ speed, data = cars)\n\nCoefficients:\n(Intercept)        speed  \n    -17.579        3.932  \n\ntypeof(m)\n\n[1] \"list\"\n\nclass(m)\n\n[1] \"lm\"\n\n\nThe object m returned by lm() belongs to the lm class, which may be new to us but is essentially a list under the hood. This allows us to manipulate it using list operations, such as accessing its components with $ or [[,\n\nstr(m)\n\nList of 12\n $ coefficients : Named num [1:2] -17.58 3.93\n  ..- attr(*, \"names\")= chr [1:2] \"(Intercept)\" \"speed\"\n $ residuals    : Named num [1:50] 3.85 11.85 -5.95 12.05 2.12 ...\n  ..- attr(*, \"names\")= chr [1:50] \"1\" \"2\" \"3\" \"4\" ...\n $ effects      : Named num [1:50] -303.914 145.552 -8.115 9.885 0.194 ...\n  ..- attr(*, \"names\")= chr [1:50] \"(Intercept)\" \"speed\" \"\" \"\" ...\n $ rank         : int 2\n $ fitted.values: Named num [1:50] -1.85 -1.85 9.95 9.95 13.88 ...\n  ..- attr(*, \"names\")= chr [1:50] \"1\" \"2\" \"3\" \"4\" ...\n $ assign       : int [1:2] 0 1\n $ qr           :List of 5\n  ..$ qr   : num [1:50, 1:2] -7.071 0.141 0.141 0.141 0.141 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. ..$ : chr [1:50] \"1\" \"2\" \"3\" \"4\" ...\n  .. .. ..$ : chr [1:2] \"(Intercept)\" \"speed\"\n  .. ..- attr(*, \"assign\")= int [1:2] 0 1\n  ..$ qraux: num [1:2] 1.14 1.27\n  ..$ pivot: int [1:2] 1 2\n  ..$ tol  : num 1e-07\n  ..$ rank : int 2\n  ..- attr(*, \"class\")= chr \"qr\"\n $ df.residual  : int 48\n $ xlevels      : Named list()\n $ call         : language lm(formula = dist ~ speed, data = cars)\n $ terms        :Classes 'terms', 'formula'  language dist ~ speed\n  .. ..- attr(*, \"variables\")= language list(dist, speed)\n  .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n  .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. .. ..$ : chr [1:2] \"dist\" \"speed\"\n  .. .. .. ..$ : chr \"speed\"\n  .. ..- attr(*, \"term.labels\")= chr \"speed\"\n  .. ..- attr(*, \"order\")= int 1\n  .. ..- attr(*, \"intercept\")= int 1\n  .. ..- attr(*, \"response\")= int 1\n  .. ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt; \n  .. ..- attr(*, \"predvars\")= language list(dist, speed)\n  .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n  .. .. ..- attr(*, \"names\")= chr [1:2] \"dist\" \"speed\"\n $ model        :'data.frame':  50 obs. of  2 variables:\n  ..$ dist : num [1:50] 2 10 4 22 16 10 18 26 34 17 ...\n  ..$ speed: num [1:50] 4 4 7 7 8 9 10 10 10 11 ...\n  ..- attr(*, \"terms\")=Classes 'terms', 'formula'  language dist ~ speed\n  .. .. ..- attr(*, \"variables\")= language list(dist, speed)\n  .. .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n  .. .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. .. .. ..$ : chr [1:2] \"dist\" \"speed\"\n  .. .. .. .. ..$ : chr \"speed\"\n  .. .. ..- attr(*, \"term.labels\")= chr \"speed\"\n  .. .. ..- attr(*, \"order\")= int 1\n  .. .. ..- attr(*, \"intercept\")= int 1\n  .. .. ..- attr(*, \"response\")= int 1\n  .. .. ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt; \n  .. .. ..- attr(*, \"predvars\")= language list(dist, speed)\n  .. .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n  .. .. .. ..- attr(*, \"names\")= chr [1:2] \"dist\" \"speed\"\n - attr(*, \"class\")= chr \"lm\"\n\nnames(m)\n\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n\nm[[1]]\n\n(Intercept)       speed \n -17.579095    3.932409 \n\nm$coefficients\n\n(Intercept)       speed \n -17.579095    3.932409 \n\n\nThere are many methods or functions that can be used to work with the results of an lm object, such as summary(). The summary() function is a generic tool that provides a detailed summary of an object, adapting its output based on the object’s class. For a statistical model like m, it returns coefficients, residuals, and goodness-of-fit measures. For a numeric vector, it provides a statistical summary. Let’s first see it with a vector example:\n\nsummary(c(1, 4, 6, 10, NA, 100))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n    1.0     4.0     6.0    24.2    10.0   100.0       1 \n\n\nNow, apply summary() to the model m to get a detailed statistical summary:\n\nm_summary &lt;- summary(m)\nm_summary\n\n\nCall:\nlm(formula = dist ~ speed, data = cars)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-29.069  -9.525  -2.272   9.215  43.201 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -17.5791     6.7584  -2.601   0.0123 *  \nspeed         3.9324     0.4155   9.464 1.49e-12 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 15.38 on 48 degrees of freedom\nMultiple R-squared:  0.6511,    Adjusted R-squared:  0.6438 \nF-statistic: 89.57 on 1 and 48 DF,  p-value: 1.49e-12\n\n\nCheck the class and type of m_summary, and list its components:\n\nclass(m_summary)\n\n[1] \"summary.lm\"\n\ntypeof(m_summary)\n\n[1] \"list\"\n\nnames(m_summary)\n\n [1] \"call\"          \"terms\"         \"residuals\"     \"coefficients\" \n [5] \"aliased\"       \"sigma\"         \"df\"            \"r.squared\"    \n [9] \"adj.r.squared\" \"fstatistic\"    \"cov.unscaled\" \n\n\nAccess specific elements, such as the coefficients table:\n\nm_summary$coefficients\n\n              Estimate Std. Error   t value     Pr(&gt;|t|)\n(Intercept) -17.579095  6.7584402 -2.601058 1.231882e-02\nspeed         3.932409  0.4155128  9.463990 1.489836e-12\n\n\nThese methods allow you to summarize data, extract key statistics, or prepare for further analysis.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objects - Lists and Data Frames</span>"
    ]
  },
  {
    "objectID": "objects2.html#data-frames",
    "href": "objects2.html#data-frames",
    "title": "3  Objects - Lists and Data Frames",
    "section": "3.2 Data Frames",
    "text": "3.2 Data Frames\nA data frame is a special case of a list. This means that functions used for lists and methods to access elements from a list can be applied to a data frame. The term ‘special case of a list’ is used for a data frame because each element in a data frame needs to be a vector with the same length, allowing them to be arranged into a structure resembling a matrix. Data frames are commonly imported by reading a file, from a spreadsheet, or from a database.\n\n3.2.1 Creating a Data Frame\nA data frame can be created from vectors of the same length using the data.frame() function.\n\nsex &lt;- c(\"M\", \"F\", \"F\", \"M\", \"M\")\nheight &lt;- c(65, 63, 60, 62, 57)\nweight &lt;- c(150, 140, 135, 165, 175)\nliveOnCampus &lt;- c(TRUE, TRUE, FALSE, FALSE, FALSE)\nd &lt;- data.frame(sex, height, weight, liveOnCampus)\nd\n\n  sex height weight liveOnCampus\n1   M     65    150         TRUE\n2   F     63    140         TRUE\n3   F     60    135        FALSE\n4   M     62    165        FALSE\n5   M     57    175        FALSE\n\n\nA data frame can be created by combining various object types, such as matrices and vectors. The following example demonstrates how to construct a data frame from a matrix and a vector. Suppose we have a numeric matrix with 5 rows and 2 columns, representing height (in inches) and weight (in pounds) for five individuals. Begin by creating a character vector with a length of 5 to assign groups to each row. Then, convert the matrix into a data frame and add vector v using the data.frame() function:\n\nv &lt;- c(\"A\", \"A\", \"B\", \"B\", \"C\")\nhw_matrix &lt;- matrix(c(rnorm(5, mean = 62, sd = 3), \n                      rnorm(5, mean = 150, sd = 15)), ncol = 2)\ncolnames(hw_matrix) &lt;- c(\"height\", \"weight\")\nhw_matrix\n\n       height   weight\n[1,] 63.30285 170.1940\n[2,] 61.48304 164.8765\n[3,] 66.33615 160.9962\n[4,] 62.82940 135.7800\n[5,] 63.01254 145.2810\n\ndata.frame(group = v, hw_matrix)\n\n  group   height   weight\n1     A 63.30285 170.1940\n2     A 61.48304 164.8765\n3     B 66.33615 160.9962\n4     B 62.82940 135.7800\n5     C 63.01254 145.2810\n\n\nThis example illustrates how the group variable, with values tailored to match the number of rows, is assigned to each row of the resulting data frame.\nIn the example above, the length of the group vector matches the number of rows in the matrix. Another common scenario involves an added variable with a length of one, as shown below:\n\ndata.frame(group = \"A\", hw_matrix)\n\n  group   height   weight\n1     A 63.30285 170.1940\n2     A 61.48304 164.8765\n3     A 66.33615 160.9962\n4     A 62.82940 135.7800\n5     A 63.01254 145.2810\n\n\nThe reason these examples work is that the data.frame() function implicitly coerces the matrix into a data frame. Alternatively, you can explicitly coerce an object to a data frame using the as.data.frame() function:\n\nA vector will become a one-column data frame.\nA matrix will become a data frame with the same dimensions.\nA list will become a data frame if its components have the same length.\n\n\nas.data.frame(1:4)\n\n  1:4\n1   1\n2   2\n3   3\n4   4\n\nas.data.frame(matrix(1:4, 2))\n\n  V1 V2\n1  1  3\n2  2  4\n\nas.data.frame(list(V1=c(1,2), V2=c(3,4)))\n\n  V1 V2\n1  1  3\n2  2  4\n\n\nYou can also create an empty data frame using data.frame() with no arguments, which is useful when incorporating it into a loop structure to build a data frame iteratively, similar to creating an empty list.\n\nempty_df &lt;- data.frame()\nempty_df\n\ndata frame with 0 columns and 0 rows\n\nnrow(empty_df)\n\n[1] 0\n\nncol(empty_df)\n\n[1] 0\n\n\n\n\n3.2.2 Data Frame Attributes\nBy using the following function to examine the attributes of data frame d, it reveals that a data frame is indeed a list.\n\ntypeof(d)\n\n[1] \"list\"\n\nclass(d)\n\n[1] \"data.frame\"\n\nattributes(d)\n\n$names\n[1] \"sex\"          \"height\"       \"weight\"       \"liveOnCampus\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3 4 5\n\n\nUnlike a list object, a data frame has a row.names attribute, as it resembles a matrix. It’s often noted that a data frame shares common properties with both a list and a matrix. Consequently, functions applicable to lists or matrices can also be used for data frames.\n\ncolnames(d) ## Treating d like a matrix\n\n[1] \"sex\"          \"height\"       \"weight\"       \"liveOnCampus\"\n\nnames(d) ## Treating d like a list\n\n[1] \"sex\"          \"height\"       \"weight\"       \"liveOnCampus\"\n\nrownames(d) ##  Treating d like a matrix\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\n\nRather than using the default row names generated by R, you have the option to assign new row names to a data frame. In the following example, ID is assigned as the row name of the data frame d. It’s important to note that even if ID is created as a numeric vector, once it is assigned as row names of a data frame, the values for the row names are converted as characters.\n\nid &lt;- c(2345, 1236, 2986, 6543, 6544)\nrownames(d) &lt;- id\nd\n\n     sex height weight liveOnCampus\n2345   M     65    150         TRUE\n1236   F     63    140         TRUE\n2986   F     60    135        FALSE\n6543   M     62    165        FALSE\n6544   M     57    175        FALSE\n\nrownames(d)\n\n[1] \"2345\" \"1236\" \"2986\" \"6543\" \"6544\"\n\n\nThe length of a data frame is equal to the number of columns, which is also the length of the underlying list. Given that a data frame shares properties with a matrix, you can use the functions ncol() and nrow() to retrieve the number of columns and rows, respectively.\n\nlength(d) ## Treating d like a list\n\n[1] 4\n\nncol(d) ##  Treating d like a matrix\n\n[1] 4\n\nnrow(d) ##  Treating d like a matrix\n\n[1] 5\n\n\n\n\n3.2.3 Accessing Components in a Data Frame\nSince a data frame resembles a matrix, one can access its elements in a manner similar to accessing a matrix by providing two indices within a pair of square brackets. The first index is used to select rows, and the second one is used to select columns. The following example accesses d by selecting the first three rows and the first, third, and fourth columns.\n\nd[1:3, c(1,3,4)]\n\n     sex weight liveOnCampus\n2345   M    150         TRUE\n1236   F    140         TRUE\n2986   F    135        FALSE\n\n\nYou can also access its elements by specifying row names and column names.\n\nd[c(\"6543\", \"6544\"), c(\"height\", \"weight\")]\n\n     height weight\n6543     62    165\n6544     57    175\n\n\nTo access a variable, you can use either the $ operator or [[, similar to what we do for a list object.\n\nd$height\n\n[1] 65 63 60 62 57\n\nd[[\"height\"]]\n\n[1] 65 63 60 62 57\n\nd[[2]]\n\n[1] 65 63 60 62 57\n\n\n\n\n3.2.4 Combining Data Frames\nData frames can be combined either column-wise or row-wise. Combining data column-wise is often used to add additional variables, such as appending measurement results or metadata to an existing dataset, enhancing its analytical depth. Alternatively, combining data row-wise is frequently employed when data were collected from different locations or time periods, allowing for the integration of observations into a comprehensive dataset for broader analysis.\nTo combine data frames column-wise, use the cbind() function, and it requires that the number of rows must be the same; however, row names do not need to be the same. R will use the row names of the first data frame in the cbind() function.\n\nd2 &lt;- data.frame(midterm = c(80, NA, 90, 40, 95),\n                 final = c(88, 100, 94, 88, 99))\nrownames(d2) &lt;- c(\"John\", \"Helen\", \"Mary\", \"Joe\", \"Art\")\nd2\n\n      midterm final\nJohn       80    88\nHelen      NA   100\nMary       90    94\nJoe        40    88\nArt        95    99\n\ncbind(d, d2)\n\n     sex height weight liveOnCampus midterm final\n2345   M     65    150         TRUE      80    88\n1236   F     63    140         TRUE      NA   100\n2986   F     60    135        FALSE      90    94\n6543   M     62    165        FALSE      40    88\n6544   M     57    175        FALSE      95    99\n\ncbind(d2, d)\n\n      midterm final sex height weight liveOnCampus\nJohn       80    88   M     65    150         TRUE\nHelen      NA   100   F     63    140         TRUE\nMary       90    94   F     60    135        FALSE\nJoe        40    88   M     62    165        FALSE\nArt        95    99   M     57    175        FALSE\n\n\nTo combine data frames row-wise, use the rbind() function, which requires the number of columns to be the same, and the names of the columns must match.\n\nd3 &lt;- data.frame(sex = c(\"M\", \"F\"), \n                 height = c(63, 60), \n                 weight = c(160, 146),\n                 liveOnCampus = c(FALSE, FALSE))\nrbind(d, d3)\n\n     sex height weight liveOnCampus\n2345   M     65    150         TRUE\n1236   F     63    140         TRUE\n2986   F     60    135        FALSE\n6543   M     62    165        FALSE\n6544   M     57    175        FALSE\n1      M     63    160        FALSE\n2      F     60    146        FALSE\n\n\n\n\n3.2.5 Adding Variables to a Data Frame\nAdding a variable is a common task in data analysis, driven by several practical reasons. Often, the existing variables may not fully capture the desired information, necessitating the inclusion of new ones to address specific research questions. Additionally, we frequently add variables based on summary statistics from existing variables, such as means or medians, to provide aggregated insights. Another reason is combining existing variables through operations like ratios or differences to derive new metrics. Furthermore, adding variables can facilitate data enrichment by incorporating external data sources or calculated indices relevant to the study.\nOne way to add new variables is to use the data.frame() function and include the existing data frame, plus the newly added variables. The following example demonstrates how to add the mean values of the height and weight variables to the data frame d.\n\nd4 &lt;-  data.frame(\n  d,  ## existing data frame\n  height_mean = mean(d$height),\n  weight_mean = mean(d$weight)\n)\nd4\n\n     sex height weight liveOnCampus height_mean weight_mean\n2345   M     65    150         TRUE        61.4         153\n1236   F     63    140         TRUE        61.4         153\n2986   F     60    135        FALSE        61.4         153\n6543   M     62    165        FALSE        61.4         153\n6544   M     57    175        FALSE        61.4         153\n\n\nYou can also use the dollar sign operator ($), [, or [[ to add new variables to an existing data frame.\n\nd$height_mean = mean(d$height)\nd['weight_mean'] = mean(d$weight)\nd[['weight_2']] = d[['weight']]^2\nd\n\n     sex height weight liveOnCampus height_mean weight_mean weight_2\n2345   M     65    150         TRUE        61.4         153    22500\n1236   F     63    140         TRUE        61.4         153    19600\n2986   F     60    135        FALSE        61.4         153    18225\n6543   M     62    165        FALSE        61.4         153    27225\n6544   M     57    175        FALSE        61.4         153    30625\n\n\n\n\n3.2.6 Reading Data Frames\nTypically, a data frame is generated by importing data from an external text file. The read.table() function plays a key role in reading such text files, where each field is separated by one or more separators. The output of the read.table() function is a data frame. With numerous arguments, the read.table() function offers flexibility in handling files with various formats, many of which come with default values.\nWhen utilizing the read.table() function to read external files, it’s crucial to consider the following format specifications of the input file:\n\nSeparators: The default separators include spaces, tabs, newlines, or carriage returns. To specify an alternative separator, use the sep= argument.\nHeader: If the first row of the external file contains variable names, specify header = TRUE. By default, this argument is set to FALSE, and read.table() will use V followed by the column number as the variable names.\nRow Names: If the header line is one column shorter than the body of the file, the first column is taken as row names. In this case, the header= option is automatically set to TRUE.\nMissing Values: read.table() recognizes NA as a missing value for any data type and treats NaN, Inf, and -Inf as missing for numeric data. Modify the default option using the na.strings= argument. For instance, if a period is considered a missing value, use na.strings = \".\". If missing values are represented by a non-NA value, such as blanks, it is safe to use the sep= option.\nComments: By default, read.table() treats any text after the # sign as comments. Change this default using the comment.char= argument. For example, comment.char =\"%\" means that any text after % is considered a comment and will not be read.\nSkip Lines: Skip a specified number of lines from the input file using the skip= option. For example, skip = 2 means skipping the first two lines.\nNumber of Rows: Regulate the maximum number of lines to read with the nrow= option. If, for instance, you set nrow = 5, the function will read the first 5 rows.”\n\nSuppose we need to read and examine example1.txt. Initially, let’s take a closer look at the data.\n\nEach field in the dataset is separated by a tab.\nThe first two lines contain comments marked with #.\nThe row following the comments contains variable names.\nNumerical missing values are represented as ..\n\nThe subsequent R code illustrates how to read in this file:\n\nexample1 = read.table(file=\"example1.txt\", header= T, na.strings = \".\")\nhead(example1)\n\n     Fname    Lname race age preg income\n1    KAREN    ARIAS    H  26    0  35000\n2 Caroline   Embrey    W  26    1  48000\n3      GEN ERECKSON    W  32    1  30000\n4     JOAN   RIVERA    W  17    0  59000\n5   ANDREA    Jones    B  29    1 120000\n6  BEVERLY    ROELL    W  26    1 113000\n\n\nThe example shown assumes that your data is located in your working directory. If it is not, you need to either change your working directory using setwd() or specify the entire file path (e.g., file = \"C:/path/to/example1.txt\").\nIn the read.table() function above:\n\nThe header= argument is set to TRUE since the variable names are in the input file.\nThe comment.char= argument is not used as # is the default value for indicating comments.\nna.strings= is set to . which represents the missing value for numerical values.\nSince each field is separated by tabs, the sep= option is not used. If you prefer to specify this option explicitly, you can write sep=\"\\t\".\n\nThere are other analogous functions for reading raw data, essentially serving as wrapper functions for read.table(). For instance:\n\nThe read.csv() function reads ‘comma-separated value’ files. It automatically sets header = TRUE and sep = \",\" for the read.table() function.\nThe read.delim() function reads delimited files, with the TAB character as the default delimiter and header = TRUE.\n\nBase R does not include functions for reading Excel files. You can leverage one of the following packages to read an Excel file:\n\nThe readxl package: data &lt;- read_excel(\"data.xlsx\")\nThe openxlsx package (reading and writing Excel files): data &lt;- read.xlsx(\"data.xlsx\")\nThe writexl package (primarily for writing): data &lt;- read_xlsx(\"data.xlsx\")\n\nThe haven package offers numerous useful functions for reading external files in various formats.\n\nRead SAS files (.sas7bdat) : read_sas()\nRead SPSS files(.sav): read_sav()\nRead STATA files (.dta): read_dta()\n\n\n\n3.2.7 Writing Data Frames\nOne common approach to save a data frame to a text file is by using the write.table() function. The key arguments frequently used with the write.table() function are as follows:\n\nfile=: The name of the output file.\nquote=: Either TRUE or FALSE, or a numeric vector.\n\nIf TRUE (default), character or factor columns will be enclosed in double quotes.\nIf FALSE, all quotes will be omitted.\nIf a numeric vector, its elements will be the indices of columns to be quoted.\n\nsep=: Used to specify the column separator. For instance, to separate columns by tabs, use sep = \"\\t\".\nna=: Default value is NA, which serves as a missing value in the output file.\nrow.names=: A logical value. By default (TRUE), the row names of the data frame will be included in the output dataset.\ncol.names=: A logical value. By default (TRUE), the column names of the data frame will be included in the output dataset.\n\nThe following example demonstrates writing the data frame, dat1, to an output file named dat1.txt.\n\ndat1 &lt;- data.frame(\n  numVar = c(round(rnorm(5), 2), NA),\n  charVar = c(NA, letters[1:5])\n  )\ndat1\n\n  numVar charVar\n1   0.84    &lt;NA&gt;\n2  -0.45       a\n3  -0.48       b\n4  -0.17       c\n5   0.40       d\n6     NA       e\n\n\n\nwrite.table(dat1, file=\"dat1.txt\")\n\nWithout specifying arguments to control the arrangement of data in the external file, the provided R code might not create the file in the desired format using the default settings. For instance, by default, row names from 1 to 6 are included in the output file. All character values, including row and column names, are enclosed in quotation marks. Each column is separated by a single space. Lastly, missing values are represented as NA.\nHere’s an example to exert better control over the data arrangement in the external file. In the following R code, row names are omitted, and quotation marks for character values are suppressed. Each column is separated by tabs, and a blank value is used to represent missing values.\n\nwrite.table(dat1, file=\"dat1.txt\", row.names = F, \n            quote = F, sep = \"\\t\", na = \" \")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objects - Lists and Data Frames</span>"
    ]
  },
  {
    "objectID": "Subsetting.html",
    "href": "Subsetting.html",
    "title": "4  Subsetting Objects",
    "section": "",
    "text": "4.1 Index Vectors\nWhen subsetting an object in R, we use an index vector to specify which elements we want to extract. This index vector is placed inside square brackets after the object name. R supports five types of index vectors, and each type offers a different way to reference elements. It’s important to remember that these types should not be mixed within a single subsetting operation. In this section, we will introduce each of the five types and demonstrate how they can be used to subset a simple vector.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#index-vectors",
    "href": "Subsetting.html#index-vectors",
    "title": "4  Subsetting Objects",
    "section": "",
    "text": "4.1.1 Type 1: A Logical Index\nOne way to subset a vector in R is by using a logical index. A logical index is a vector made up of TRUE, FALSE, and NA values. When applied to a target vector, only the elements that correspond to TRUE in the logical index will be selected. Elements paired with FALSE are excluded, and those paired with NA will return NA in the output.\nIn the following example, we create a vector a that contains a missing value. To select only the non-missing elements, we use !is.na(a) as the logical index.\n\na &lt;- c(1, 3, 5, NA, 7)\nis.na(a)\n\n[1] FALSE FALSE FALSE  TRUE FALSE\n\n!is.na(a)\n\n[1]  TRUE  TRUE  TRUE FALSE  TRUE\n\na[!is.na(a)]\n\n[1] 1 3 5 7\n\n\nWe can also use logical conditions directly. For example, the expression a &gt; 3 creates a logical vector indicating which elements in a are greater than 3. However, be aware that if the vector contains missing values, the condition will return NA for those entries.\n\na &gt; 3\n\n[1] FALSE FALSE  TRUE    NA  TRUE\n\na[a &gt; 3]\n\n[1]  5 NA  7\n\n\nThis kind of indexing is particularly useful when filtering data based on conditions or when working with missing values.\n\n\n4.1.2 Type 2: A Positive Integer Index\nAnother common method for subsetting a vector is to use a positive integer index. This index vector specifies the positions of the elements to extract from the target vector. The index vector can be of any length—shorter or longer than the original vector—and the resulting output will include the values at those specified positions, in the order listed.\nIn the example below, we use a positive integer index to extract the first, second, third, and then second element again from vector a.\n\na &lt;- c(1, 3, 5, NA, 7)\na[c(1:3, 2)]\n\n[1] 1 3 5 3\n\n\nA useful tool when working with logical conditions is the which() function. Instead of returning a logical vector, which() returns the integer positions of elements that satisfy a condition, automatically excluding any NA values. This makes it a safer and often preferred option over direct logical indexing when the presence of missing values is a concern.\nCompare the results of the two approaches below:\n\na[a &gt; 3]\n\n[1]  5 NA  7\n\nwhich(a &gt; 3)\n\n[1] 3 5\n\na[which(a &gt; 3)]\n\n[1] 5 7\n\n\nThe first line returns a result with an NA due to the missing value in a, while the second line avoids this issue by subsetting only on valid positions.\nIt’s also worth noting that any 0 values in a positive integer index vector are ignored and do not return corresponding elements.\n\na[c(0, 2)]\n\n[1] 3\n\n\n\n\n4.1.3 Type 3: A Negative Integer Index\nIn addition to selecting specific elements, you can also exclude elements from a vector using a negative integer index. By placing a minus sign in front of the index values, R will omit those positions from the result.\nFor example, the following code removes the first and fourth elements from vector a:\n\na &lt;- c(1, 3, 5, NA, 7)\na[-c(1,4)]\n\n[1] 3 5 7\n\n\nThis approach is especially helpful when you want to drop a small number of elements from a larger vector without having to specify everything you want to keep.\nOne important rule to remember: you cannot mix positive and negative indices in the same index vector. Doing so will result in an error.\n\n\n4.1.4 Type 4: A Character Index\nIf a vector has a names attribute, you can subset it using a character index vector by specifying the element names. This method allows for intuitive selection when working with named elements.\nFor example, the following code attempts to select elements \"a\" and \"c\" from vector a. Initially, this returns NA values because a has no assigned names:\n\na &lt;- c(1, 3, 5, NA, 7)\na[c(\"a\",\"c\")]\n\n[1] NA NA\n\n\nTo make this operation meaningful, you must first assign names to the elements of a. After doing so, the same character index will correctly return the corresponding values:\n\nnames(a) &lt;- letters[1:5] ## Assign names with a - e\na[c(\"a\",\"c\")]\n\na c \n1 5 \n\n\nNote that the length of the character index vector can be shorter or longer than the target vector. If any name in the index is not found in the object, R will return NA for that position.\n\n\n4.1.5 Type 5: An Empty Index\nAn empty index can be used to select all elements from a vector. When you leave the square brackets empty, R returns the entire object without any subsetting:\n\na[]\n\n a  b  c  d  e \n 1  3  5 NA  7 \n\n\nWhile this may not seem especially helpful when working with vectors, it becomes much more useful for more complex structures like matrices, arrays, or data frames—particularly when you want to extract all rows or columns without specifying them explicitly.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#index-vector-replacement",
    "href": "Subsetting.html#index-vector-replacement",
    "title": "4  Subsetting Objects",
    "section": "4.2 Index Vector: Replacement",
    "text": "4.2 Index Vector: Replacement\nIn R, “replacement” refers to modifying existing values or attributes within an object. Many R functions support this operation. For instance, the names() function can both retrieve and assign names to an object. If you consult its help file, you will find the following syntax:\nnames(x)\nnames(x) &lt;- value\nThe second form illustrates the concept of replacement.\nJust like subsetting, all five types of index vectors can also be used for replacement. In the following example, we use a logical index vector to identify missing values in vector x, and then replace those values with 0:\n\nx &lt;- c(3, 6, NA, -1)\nx[is.na(x)] &lt;- 0\nx\n\n[1]  3  6  0 -1\n\n\nThe next example uses a positive integer index vector to replace the second and fourth elements with 10 and 20, respectively:\n\nx[c(2,4)] &lt;- c(10, 20)\nx\n\n[1]  3 10  0 20\n\n\nTo replace all elements in x except for the first and second, we use a negative integer index vector. All remaining elements are replaced with the value 4:\n\nx[-c(1,2)] &lt;- 4\nx\n\n[1]  3 10  4  4\n\n\nOnce names are assigned to a vector, we can also use a character index vector for replacement. Here, we replace the elements named \"a\" and \"c\" with 0:\n\nnames(x) &lt;- letters[1:4]\nx\n\n a  b  c  d \n 3 10  4  4 \n\nx[c(\"a\", \"c\")] &lt;- 0\nx\n\n a  b  c  d \n 0 10  0  4 \n\n\nFinally, an empty index can appear on the left-hand side of an assignment. This replaces all values while preserving the object’s structure and type. In this example, all elements of x are set to 0:\n\nx[] &lt;- 0\nx\n\na b c d \n0 0 0 0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#utilizing-index-vectors-in-various-applications",
    "href": "Subsetting.html#utilizing-index-vectors-in-various-applications",
    "title": "4  Subsetting Objects",
    "section": "4.3 Utilizing Index Vectors in Various Applications",
    "text": "4.3 Utilizing Index Vectors in Various Applications\n\n4.3.1 Recoding Variables\nOne common use of indexing is to recode variables, especially character vectors. In this example, we demonstrate how to use character indexing to recode a character vector named Sex, which contains values \"M\" and \"F\".\n\nSex &lt;-  c(\"M\", \"F\", \"F\", \"M\", \"M\", \"F\")\n\nOur goal is to convert this vector into a more descriptive form, replacing \"M\" with \"Male\" and \"F\" with \"Female\". To achieve this, we first create a named character vector called convert. The values are \"Male\" and \"Female\", with names \"M\" and \"F\":\n\nconvert &lt;- c(M = \"Male\", F = \"Female\")\n\nSince convert is a named vector, we can subset its components by specifying their names, as shown in the example below. Notice that the length of the index vector can vary, and the resulting output has the same length as the index vector.\nSince convert has names assigned, we can subset it by those names. Below are a few examples. Notice that the resulting output matches the length and order of the index vector:\n\nconvert[\"M\"]\n\n     M \n\"Male\" \n\nconvert[c(\"F\", \"M\")]\n\n       F        M \n\"Female\"   \"Male\" \n\nconvert[c(\"F\", \"M\", \"F\", \"F\")]\n\n       F        M        F        F \n\"Female\"   \"Male\" \"Female\" \"Female\" \n\n\nIn the final step, we use the Sex vector itself as the index to the convert vector. This produces the recoded values directly:\n\nSex_recode &lt;-convert[Sex]\nSex_recode\n\n       M        F        F        M        M        F \n  \"Male\" \"Female\" \"Female\"   \"Male\"   \"Male\" \"Female\" \n\n\n\n\n4.3.2 Imputing Missing Numerical Values\nImputation refers to the process of replacing missing or incomplete values in a dataset. This step is important to ensure the dataset is complete and suitable for analysis. A common approach is to substitute missing values with summary statistics, such as the mean, median, or mode. More advanced methods may involve regression or machine learning techniques, but simple imputation strategies are often sufficient for exploratory analysis.\nIn the following example, the numeric vector n contains missing values. To impute these missing values using the median, we first compute the median with the median() function. The na.rm = TRUE option tells R to ignore the NA values when performing the calculation. Then, we use a logical index vector generated by is.na() to locate the missing values and replace them with the computed median.\n\nn &lt;-  c(123, 210, NA, 100, 502, NA, 103, 240)\nm &lt;- median(n, na.rm=T) \nm\n\n[1] 166.5\n\nn[is.na(n)] &lt;- m\nn\n\n[1] 123.0 210.0 166.5 100.0 502.0 166.5 103.0 240.0\n\n\n\n\n4.3.3 Imputing Missing Character Values\nWhen dealing with character vectors, a common strategy for imputing missing values is to replace them with the most frequently occurring value. This approach helps maintain consistency and can be implemented using a few steps.\nLet’s start with a character vector that includes some missing values:\n\nc &lt;- c(\"A\", \"B\", \"A\", NA, \"C\", \"C\", \"A\")\n\nTo determine the most frequent value, we use the table() function, which returns a frequency table of the non-missing values:\n\ntab &lt;- table(c)\ntab\n\nc\nA B C \n3 1 2 \n\n\nThe output of the table() function is a named integer vector with the class \"table\". It can be treated like a regular named vector, where the names represent the unique values in the original data, and the values indicate their frequencies. You can view the names using the names() function:\n\nnames(tab)\n\n[1] \"A\" \"B\" \"C\"\n\n\nTo identify the most frequent value, we first compute the maximum frequency using the max() function:\n\nhf &lt;- max(tab)\n\nNext, we want to find which value in tab corresponds to this maximum frequency. This is done by comparing tab with hf, which gives a logical index vector:\n\nind &lt;- tab == hf \nind\n\nc\n    A     B     C \n TRUE FALSE FALSE \n\n\nWe then use this index to extract the name (i.e., value) associated with the highest frequency:\n\nhf_c &lt;- names(tab)[ind]\nhf_c\n\n[1] \"A\"\n\n\nFinally, we use is.na() to identify missing values in the original vector and replace them with hf_c, the most common value:\n\nc[is.na(c)] = hf_c\nc\n\n[1] \"A\" \"B\" \"A\" \"A\" \"C\" \"C\" \"A\"\n\n\nIf there is a tie for the most frequent value, only the first one in the result will be used, which may depend on the internal ordering in R.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#matrix-indexing",
    "href": "Subsetting.html#matrix-indexing",
    "title": "4  Subsetting Objects",
    "section": "4.4 Matrix Indexing",
    "text": "4.4 Matrix Indexing\nThe five types of index vectors can also be applied to matrices for selecting specific elements. Consider the following example:\n\nm &lt;- matrix(1:12, nrow=3)\nrownames(m) = c(\"i\", \"ii\", \"iii\")\ncolnames(m) = c(\"I\", \"II\", \"III\", \"IV\")\nm\n\n    I II III IV\ni   1  4   7 10\nii  2  5   8 11\niii 3  6   9 12\n\n\nTo extract elements from a matrix, two index vectors are placed inside square brackets, separated by a comma. The first index vector corresponds to the row positions, and the second to the column positions. For instance, the following command selects the element in the second row and fourth column:\n\nm[2,4]\n\n[1] 11\n\n\nLeaving either the row or column position empty selects all values along that dimension. For example:\n\nm[c(1,3),] ## select first and third rows\n\n    I II III IV\ni   1  4   7 10\niii 3  6   9 12\n\nm[,c(1,2)] ## select first and second columns\n\n    I II\ni   1  4\nii  2  5\niii 3  6\n\n\nDifferent types of index vectors can be used at each index position. In the next example, a negative integer index excludes the first row, and a character index selects the columns named \"I\" and \"IV\":\n\nm[-1, c(\"I\", \"IV\")]\n\n    I IV\nii  2 11\niii 3 12\n\n\nIn the following example, a character index is used to select rows with names \"i\" and \"ii\", while a numeric index selects the second through fourth columns:\n\nm[c(\"i\", \"ii\"), 2:4]\n\n   II III IV\ni   4   7 10\nii  5   8 11",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#subsetting-data-frames",
    "href": "Subsetting.html#subsetting-data-frames",
    "title": "4  Subsetting Objects",
    "section": "4.5 Subsetting Data Frames",
    "text": "4.5 Subsetting Data Frames\nA data frame in R shares features with both matrices and lists. Therefore, subsetting a data frame can be done using one or two index vectors, depending on how the data frame is treated.\n\n4.5.1 Subsetting a Data Frame as a Matrix\nWhen a data frame is treated like a matrix, two indices are required: the first index selects rows, and the second selects columns. For example, the following code selects the second and third rows from the data frame d, while retaining all columns:\n\nd &lt;- data.frame(\n  L = c(\"A\", \"B\", \"C\"),\n  M = 1:3,\n  N1 = c(T, F, NA)\n)\nd\n\n  L M    N1\n1 A 1  TRUE\n2 B 2 FALSE\n3 C 3    NA\n\nd[c(2,3), ]\n\n  L M    N1\n2 B 2 FALSE\n3 C 3    NA\n\n\nTo select specific columns, you can use a column index in the second position. The following command selects the first and third columns, including all rows:\n\nd[,c(1,3)]\n\n  L    N1\n1 A  TRUE\n2 B FALSE\n3 C    NA\n\n\nYou can also use a logical index to subset rows. The expression d$L == \"A\" creates a logical vector that identifies which rows have the value \"A\" in column L. This logical index is placed before the comma to select the corresponding rows:\n\nd$L == \"A\"\n\n[1]  TRUE FALSE FALSE\n\nd[d$L == \"A\", ]\n\n  L M   N1\n1 A 1 TRUE\n\n\nCharacter indexing can be used to select columns by name. The following example selects the columns named \"M\" and \"N1\":\n\nd[, c(\"M\", \"N1\")]\n\n  M    N1\n1 1  TRUE\n2 2 FALSE\n3 3    NA\n\n\nYou can combine both row and column indexing. The example below selects rows where column L equals \"A\" and returns only the \"M\" and \"N1\" columns:\n\nd[d$L == \"A\", c(\"M\", \"N1\")]\n\n  M   N1\n1 1 TRUE\n\n\n\n\n4.5.2 Subsetting a Data Frame as a List\nA data frame is also a special type of list, where each column is treated as a separate component. When subsetting a data frame as a list, you can only select columns—rows cannot be selected this way—and only a single index vector is used.\nFor instance, you can use a numeric index vector to select the second and third columns:\n\nd[c(2,3)]\n\n  M    N1\n1 1  TRUE\n2 2 FALSE\n3 3    NA\n\n\nAlternatively, use a character index vector to select columns by name:\n\nd[c(\"M\", \"N1\")]\n\n  M    N1\n1 1  TRUE\n2 2 FALSE\n3 3    NA\n\n\n\n\n4.5.3 Sorting a Data Frame\nTo sort a vector in R, the sort() function can be used. By default, this function sorts values in ascending order. If you want to sort the vector in descending order, set the decreasing= option to TRUE:\n\nx &lt;- c(5, 2, 1)\nsort(x)\n\n[1] 1 2 5\n\nsort(x, decreasing = TRUE)\n\n[1] 5 2 1\n\n\nSorting a data frame involves arranging its rows using an index vector of positive integers. This index vector must match the number of rows in the data frame. Typically, the order() function is used to generate this index.\nThe examples below make use of the painters dataset from the MASS package. This dataset includes subjective evaluations of 54 classical painters across four artistic dimensions: Composition, Drawing, Colour, and Expression. These evaluations were originally compiled by the 18th-century art critic, de Piles.\n\nlibrary(MASS)\ndim(painters)\n\n[1] 54  5\n\nhead(painters)\n\n              Composition Drawing Colour Expression School\nDa Udine               10       8     16          3      A\nDa Vinci               15      16      4         14      A\nDel Piombo              8      13     16          7      A\nDel Sarto              12      16      9          8      A\nFr. Penni               0      15      8          0      A\nGuilio Romano          15      16      4         14      A\n\n\nThe School variable in this dataset indicates the school each painter is associated with. To simplify the examples, we’ll extract a smaller subset of the data, painters_ABC, which includes only those painters whose schools are labeled \"A\", \"B\", or \"C\". The %in% operator is used to compare each entry in the School variable against these three values and create a logical index.\n\nABC_index &lt;- painters$School %in% c(\"A\", \"B\", \"C\")\nABC_index\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE FALSE FALSE FALSE FALSE\n\nsum(ABC_index)\n\n[1] 22\n\npainters_ABC &lt;- painters[ABC_index,]\ndim(painters_ABC)\n\n[1] 22  5\n\n\nThe first example shows how to sort painters_ABC by row names, which correspond to the painters’ names. The order() function returns an index that arranges the row names in ascending order. This index is then used to reorder the rows:\n\nname_Index &lt;- order(row.names(painters_ABC))\nname_Index\n\n [1] 17 18  1  2  3  4 11  5 12  6 19 20  7 13  8  9 14 10 15 21 22 16\n\npainters_ABC[name_Index, ]\n\n                Composition Drawing Colour Expression School\nBarocci                  14      15      6         10      C\nCortona                  16      14     12          6      C\nDa Udine                 10       8     16          3      A\nDa Vinci                 15      16      4         14      A\nDel Piombo                8      13     16          7      A\nDel Sarto                12      16      9          8      A\nF. Zucarro               10      13      8          8      B\nFr. Penni                 0      15      8          0      A\nFr. Salviata             13      15      8          8      B\nGuilio Romano            15      16      4         14      A\nJosepin                  10      10      6          2      C\nL. Jordaens              13      12      9          6      C\nMichelangelo              8      17      4          8      A\nParmigiano               10      15      6          6      B\nPerino del Vaga          15      16      7          6      A\nPerugino                  4      12     10          4      A\nPrimaticcio              15      14      7         10      B\nRaphael                  17      18     12         18      A\nT. Zucarro               13      14     10          9      B\nTesta                    11      15      0          6      C\nVanius                   15      15     12         13      C\nVolterra                 12      15      5          8      B\n\n\nThe next example sorts the data by the School variable in descending order. Here, the order() function is placed directly inside the square brackets, and the decreasing = TRUE argument ensures descending order:\n\npainters_ABC[order(painters_ABC$School, decreasing = T), ]\n\n                Composition Drawing Colour Expression School\nBarocci                  14      15      6         10      C\nCortona                  16      14     12          6      C\nJosepin                  10      10      6          2      C\nL. Jordaens              13      12      9          6      C\nTesta                    11      15      0          6      C\nVanius                   15      15     12         13      C\nF. Zucarro               10      13      8          8      B\nFr. Salviata             13      15      8          8      B\nParmigiano               10      15      6          6      B\nPrimaticcio              15      14      7         10      B\nT. Zucarro               13      14     10          9      B\nVolterra                 12      15      5          8      B\nDa Udine                 10       8     16          3      A\nDa Vinci                 15      16      4         14      A\nDel Piombo                8      13     16          7      A\nDel Sarto                12      16      9          8      A\nFr. Penni                 0      15      8          0      A\nGuilio Romano            15      16      4         14      A\nMichelangelo              8      17      4          8      A\nPerino del Vaga          15      16      7          6      A\nPerugino                  4      12     10          4      A\nRaphael                  17      18     12         18      A\n\n\nYou can also sort a data frame by more than one variable. The following command sorts by School, then by Drawing:\n\npainters_ABC[order(painters_ABC$School, \n                   painters_ABC$Drawing), ]\n\n                Composition Drawing Colour Expression School\nDa Udine                 10       8     16          3      A\nPerugino                  4      12     10          4      A\nDel Piombo                8      13     16          7      A\nFr. Penni                 0      15      8          0      A\nDa Vinci                 15      16      4         14      A\nDel Sarto                12      16      9          8      A\nGuilio Romano            15      16      4         14      A\nPerino del Vaga          15      16      7          6      A\nMichelangelo              8      17      4          8      A\nRaphael                  17      18     12         18      A\nF. Zucarro               10      13      8          8      B\nPrimaticcio              15      14      7         10      B\nT. Zucarro               13      14     10          9      B\nFr. Salviata             13      15      8          8      B\nParmigiano               10      15      6          6      B\nVolterra                 12      15      5          8      B\nJosepin                  10      10      6          2      C\nL. Jordaens              13      12      9          6      C\nCortona                  16      14     12          6      C\nBarocci                  14      15      6         10      C\nTesta                    11      15      0          6      C\nVanius                   15      15     12         13      C\n\n\nIf you specify decreasing = TRUE, the sorting is applied in descending order for all variables listed:\n\npainters_ABC[order(painters_ABC$School, \n                   painters_ABC$Colour,    \n                   painters_ABC$Drawing, \n                   decreasing = T),]\n\n                Composition Drawing Colour Expression School\nVanius                   15      15     12         13      C\nCortona                  16      14     12          6      C\nL. Jordaens              13      12      9          6      C\nBarocci                  14      15      6         10      C\nJosepin                  10      10      6          2      C\nTesta                    11      15      0          6      C\nT. Zucarro               13      14     10          9      B\nFr. Salviata             13      15      8          8      B\nF. Zucarro               10      13      8          8      B\nPrimaticcio              15      14      7         10      B\nParmigiano               10      15      6          6      B\nVolterra                 12      15      5          8      B\nDel Piombo                8      13     16          7      A\nDa Udine                 10       8     16          3      A\nRaphael                  17      18     12         18      A\nPerugino                  4      12     10          4      A\nDel Sarto                12      16      9          8      A\nFr. Penni                 0      15      8          0      A\nPerino del Vaga          15      16      7          6      A\nMichelangelo              8      17      4          8      A\nDa Vinci                 15      16      4         14      A\nGuilio Romano            15      16      4         14      A\n\n\nTo selectively sort one of the numeric variables in descending order, you can prefix it with a minus sign (-). For example, this command sorts by School, then by decreasing Colour, and finally by Drawing:\n\npainters_ABC[order(painters_ABC$School, \n                   -painters_ABC$Colour, \n                   painters_ABC$Drawing), ]\n\n                Composition Drawing Colour Expression School\nDa Udine                 10       8     16          3      A\nDel Piombo                8      13     16          7      A\nRaphael                  17      18     12         18      A\nPerugino                  4      12     10          4      A\nDel Sarto                12      16      9          8      A\nFr. Penni                 0      15      8          0      A\nPerino del Vaga          15      16      7          6      A\nDa Vinci                 15      16      4         14      A\nGuilio Romano            15      16      4         14      A\nMichelangelo              8      17      4          8      A\nT. Zucarro               13      14     10          9      B\nF. Zucarro               10      13      8          8      B\nFr. Salviata             13      15      8          8      B\nPrimaticcio              15      14      7         10      B\nParmigiano               10      15      6          6      B\nVolterra                 12      15      5          8      B\nCortona                  16      14     12          6      C\nVanius                   15      15     12         13      C\nL. Jordaens              13      12      9          6      C\nJosepin                  10      10      6          2      C\nBarocci                  14      15      6         10      C\nTesta                    11      15      0          6      C\n\n\nWhen working with character variables, the minus sign cannot be applied directly. Instead, use the xtfrm() function, which transforms the character variable into a numeric form that preserves the original sort order. This allows descending sorting for character data:\n\nxtfrm(c(\"A\", \"D\", \"B\", \"C\"))\n\n[1] 1 4 2 3\n\npainters_ABC[order(-xtfrm(painters_ABC$School),\n                   painters_ABC$Drawing), ]\n\n                Composition Drawing Colour Expression School\nJosepin                  10      10      6          2      C\nL. Jordaens              13      12      9          6      C\nCortona                  16      14     12          6      C\nBarocci                  14      15      6         10      C\nTesta                    11      15      0          6      C\nVanius                   15      15     12         13      C\nF. Zucarro               10      13      8          8      B\nPrimaticcio              15      14      7         10      B\nT. Zucarro               13      14     10          9      B\nFr. Salviata             13      15      8          8      B\nParmigiano               10      15      6          6      B\nVolterra                 12      15      5          8      B\nDa Udine                 10       8     16          3      A\nPerugino                  4      12     10          4      A\nDel Piombo                8      13     16          7      A\nFr. Penni                 0      15      8          0      A\nDa Vinci                 15      16      4         14      A\nDel Sarto                12      16      9          8      A\nGuilio Romano            15      16      4         14      A\nPerino del Vaga          15      16      7          6      A\nMichelangelo              8      17      4          8      A\nRaphael                  17      18     12         18      A\n\n\nBy default, missing values (NA) are placed at the end of the sorted result. To move missing values to the beginning, set na.last = FALSE. To remove rows with missing values from the sort entirely, use na.last = NA.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#the-differences-between-and",
    "href": "Subsetting.html#the-differences-between-and",
    "title": "4  Subsetting Objects",
    "section": "4.6 The Differences Between [, [[, and $",
    "text": "4.6 The Differences Between [, [[, and $\nR provides three operators—[, [[, and $—for subsetting objects. The choice of which operator to use depends on the type of object and the form of the result you want. Understanding the distinctions between these operators is important for writing clear and predictable code.\n\n4.6.1 Selecting a Single Column from a Data Frame\nWhen you use [ to select a single column from a data frame, the result is still a data frame:\n\nd\n\n  L M    N1\n1 A 1  TRUE\n2 B 2 FALSE\n3 C 3    NA\n\nd[3]\n\n     N1\n1  TRUE\n2 FALSE\n3    NA\n\nd[\"N1\"]\n\n     N1\n1  TRUE\n2 FALSE\n3    NA\n\nd[-c(1,2)]\n\n     N1\n1  TRUE\n2 FALSE\n3    NA\n\n\nIn contrast, using [[ returns a vector instead of a data frame:\n\nd[[3]]\n\n[1]  TRUE FALSE    NA\n\nd[[\"N1\"]]\n\n[1]  TRUE FALSE    NA\n\n\nSimilarly, the $ operator also returns a vector:\n\nd$N1\n\n[1]  TRUE FALSE    NA\n\n\n\n\n4.6.2 Selecting One or Several Components from an Object\nThe [ operator allows selection of multiple components (e.g., multiple columns from a data frame). However, both [[ and $ can be used to select only a single element at a time. For example:\n\nd[1:2]\n\n  L M\n1 A 1\n2 B 2\n3 C 3\n\nd[-3]\n\n  L M\n1 A 1\n2 B 2\n3 C 3\n\nd[c(\"L\", \"M\")]\n\n  L M\n1 A 1\n2 B 2\n3 C 3\n\n\nThis rule applies not only to data frames but also to other list-like objects.\n\n\n4.6.3 Using Operators for Evaluations\nThe [[ and [ operators evaluate their arguments, meaning you can pass in expressions. For instance:\n\nd[[1+2]]\n\n[1]  TRUE FALSE    NA\n\nd[c(1,2)+1]\n\n  M    N1\n1 1  TRUE\n2 2 FALSE\n3 3    NA\n\n\nIn contrast, the $ operator does not evaluate its argument. It expects a literal column name. As a result, the following will not work:\n\nd$1 + 2\n\nError in parse(text = input): &lt;text&gt;:1:3: unexpected numeric constant\n1: d$1\n      ^\n\n\n\n\n4.6.4 Partial Matching\nThe $ operator allows for partial matching of column names, whereas [ and [[ do not. In the example below, the column N1 is returned even though only N is specified:\n\nd$N\n\n[1]  TRUE FALSE    NA\n\n\nWhile partial matching can be convenient, it is generally discouraged. Using full, explicit names makes your code easier to understand and less error-prone.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#simplifying-and-preserving",
    "href": "Subsetting.html#simplifying-and-preserving",
    "title": "4  Subsetting Objects",
    "section": "4.7 Simplifying and Preserving",
    "text": "4.7 Simplifying and Preserving\nThis section is based in part on Advanced R by Hadley Wickham (2nd ed., https://adv-r.hadley.nz/subsetting.html)(Wickham 2019), which provides an in-depth treatment of how subsetting can return either simplified or preserved structures in R.\nWhen you subset an object, the result may not always retain the original structure. Simplifying subsets return the most compact possible result (e.g., a vector instead of a data frame), while preserving subsets maintain the structure of the original object. Choosing between them depends on your analysis goals—whether you want simplicity or consistency in data type.\n\n4.7.1 Simplifying and Preserving: Vectors\nLet’s consider a named vector. Using double brackets [[ simplifies the output by removing additional attributes like names. On the other hand, using single brackets [ preserves these attributes and returns a subset of the same type.\n\nv &lt;- 1:5\nnames(v) &lt;- letters[1:5]\nv\n\na b c d e \n1 2 3 4 5 \n\nv[[1]] ## Simplified output, no names\n\n[1] 1\n\nv[1]   ## Preserved output, names retained\n\na \n1 \n\n\n\n\n4.7.2 Simplifying and Preserving: Factors\nWhen extracting elements from a factor, simplification means dropping unused levels. This is done by setting drop = TRUE, which is the default. Preservation retains all original levels, even if they are not present in the subset.\n\nf &lt;- factor(c(\"A\", \"B\", \"C\"))\nf\n\n[1] A B C\nLevels: A B C\n\nf[1:2, drop=T]  ## Simplified: unused levels dropped\n\n[1] A B\nLevels: A B\n\nf[1:2]          ## Preserved: all levels retained\n\n[1] A B\nLevels: A B C\n\n\n\n\n4.7.3 Simplifying and Preserving: Matrices\nIn matrix subsetting, selecting a single row or column can return a simplified result (a vector). To retain the matrix structure, set drop = FALSE to preserve the two-dimensional format.\n\nm &lt;- matrix(1:4, 2)\nm\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nm[, 1]                ## Simplified: returns a vector\n\n[1] 1 2\n\nm[1, ]                ### Simplified: returns a vector\n\n[1] 1 3\n\nm[, 1, drop = FALSE]  ## Preserved: still a matrix\n\n     [,1]\n[1,]    1\n[2,]    2\n\nm[1, , drop = FALSE]  # Preserved: still a matrix\n\n     [,1] [,2]\n[1,]    1    3\n\n\n\n\n4.7.4 Simplifying and Preserving: Lists\nFor lists, double brackets [[ return the internal object directly (e.g., a vector or string), whereas single brackets [ return a sublist, preserving the list structure.\n\nl &lt;- list(a = 1:3, b = \"A\")\nl\n\n$a\n[1] 1 2 3\n\n$b\n[1] \"A\"\n\nl[[1]]  ## Simplifying\n\n[1] 1 2 3\n\nl[1]    ## Preserving\n\n$a\n[1] 1 2 3\n\n\n\n\n4.7.5 Simplifying and Preserving: Data Frames\nA data frame in R can behave either like a matrix or like a list. Depending on how you subset it, the result may either simplify to a vector or preserve the original data frame structure. Below, we illustrate both behaviors.\nTreating a Data Frame as a Matrix\nWhen using the single bracket operator [ with two indices — the first for rows and the second for columns — R treats the data frame like a matrix. Selecting a single column in this way returns a simplified result: a vector.\n\nd &lt;-  data.frame(\n  V1 = 1:3,\n  V2 = letters[1:3],\n  V3 = c(T, T, F)\n)\nd\n\n  V1 V2    V3\n1  1  a  TRUE\n2  2  b  TRUE\n3  3  c FALSE\n\nd[, 2]         ## Simplifying – returns a vector\n\n[1] \"a\" \"b\" \"c\"\n\n\nTo preserve the data frame structure when selecting one column, use the drop = FALSE option:\n\nd[, 2, drop = FALSE]  ## Preserving – returns a one-column data frame\n\n  V2\n1  a\n2  b\n3  c\n\n\nTreating a Data Frame as a List\nAlternatively, you can treat a data frame as a list, where each column is a component of the list. In this case, using double brackets [[ extracts a single component and simplifies the result:\n\nd[[2]]   ## Simplifying – returns a vector\n\n[1] \"a\" \"b\" \"c\"\n\n\nUsing single brackets [ with a numeric or character vector returns a sub-list, which preserves the data frame structure:\n\nd[2]     ## Preserving – returns a one-column data frame\n\n  V2\n1  a\n2  b\n3  c\n\n\nThis distinction between matrix-style and list-style subsetting is important when you want to control the structure of the output — whether you need a simple vector or wish to retain the data frame format for further processing.\n\n\n\n\nWickham, Hadley. 2019. Advanced r. 2nd ed. CRC Press. https://adv-r.hadley.nz/.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting Objects</span>"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "5  Writing User-Defined Functions",
    "section": "",
    "text": "5.1 Creating Your Own Functions\nThis section introduces the motivation for writing functions and explains how to create them step by step. We begin with a practical example to show when a function is useful, then walk through the process of converting a sequence of R commands into a well-structured function. Along the way, we will highlight key concepts such as input arguments, return values, and testing your function for reliability. Writing your own functions is an essential skill for producing clean, reusable, and scalable R code.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Writing User-Defined Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#creating-your-own-functions",
    "href": "functions.html#creating-your-own-functions",
    "title": "5  Writing User-Defined Functions",
    "section": "",
    "text": "5.1.1 Why Write a Function?\nIn R, we often find ourselves performing the same task multiple times—such as cleaning data, performing calculations, or creating plots. If the same block of code is used repeatedly with only slight changes, it becomes a good candidate for turning into a function. Writing a function allows us to package that code into a single, reusable unit.\nThere are several advantages to writing your own functions:\n\nClarity: A well-named function helps explain what the code does, making your script easier to read and understand.\nEfficiency: Once a function is defined, you can call it with different inputs as needed, instead of copying and modifying code manually.\nMaintainability: If you need to make changes, you only have to update the code in one place.\nError reduction: Using functions helps avoid small but hard-to-spot mistakes that often come from copying and pasting similar code blocks.\nModularity: Even if a task isn’t repeated, wrapping related commands into a function can help organize your code into logical sections. This makes it easier to manage, test, and reuse in future projects.\n\nFor example, Suppose we have the following vector:\n\nv1 &lt;- c(5, 10, NA, 15, 20, 100)\n\nNow we want to compute a few summary statistics, including mean, standard deviation, number of missing values, and then print the results in a readable format. Here is how we might write the code:\n\nMean &lt;- mean(v1, na.rm = TRUE)\nSD &lt;- sd(v1, na.rm = TRUE)\nn_missing &lt;- sum(is.na(v1))\n\ncat(\"Mean:\", Mean, \"\\n\")\n\nMean: 30 \n\ncat(\"Standard Deviation:\", SD, \"\\n\")\n\nStandard Deviation: 39.52847 \n\ncat(\"Number of Missing Values:\", n_missing, \"\\n\")\n\nNumber of Missing Values: 1 \n\n\nThe cat() function, short for concatenate and print, is used here to display all three results together in a readable format. It can take a varied number of arguments, each of which can be a constant (quoted text), a variable, or a special character like \"\\n\" (for a new line). All arguments are printed in the order they appear and, by default, are separated by a single space. The \"\\n\" tells R to move to a new line so that each printed value appears neatly on its own line.\nFor example:\n\nx &lt;- 10\ncat(\"The value of x is\", x, \"\\n\")  \n\nThe value of x is 10 \n\n\nIn the code above, cat() is used to combine static labels (\"Mean:\", \"Standard Deviation:\", etc.) with the corresponding computed values. This makes the output easier to read when the function is run.\nThis approach works well, but if we want to apply the same steps to many different vectors, it becomes repetitive and harder to manage.\n\n\n5.1.2 Turning Code into a Function\nWhen we write a function, we are building a small machine. This machine takes input, performs a sequence of operations, and produces output. Just like a vending machine accepts a selection and returns a snack, an R function accepts an argument, performs some computations, and either returns a result or carries out an action. Not all functions need to return a value. In our example, the function simply computes summary statistics and prints them, rather than returning them to be stored or reused.\nFunction Syntax\nThe general structure of a user-defined function is as follows:\nfunction_name &lt;- function(parameter1, parameter2, ...) {\n  # code block\n  # the final line is usually the value returned\n}\n\nfunction_name is the name you assign to your function\nInside the parentheses, you define parameters—these are placeholders for the input values\nThe curly braces {} contain the function body—this is the code that runs when the function is called\nWhen you later call the function and pass in specific values, those values are called arguments\n\nThis basic structure is described in many R references, including R for Data Science (Wickham, Çetinkaya-Rundel, and Grolemund 2023), which offers a practical introduction to writing clear, reusable functions in real-world analysis workflows.\nStep-by-Step: Turning Code into a Function\nLet’s return to the example from the previous section. We want to compute a few summary statistics, and then print the results. The previous code works well, but if we want to repeat these steps for several different vectors, it becomes repetitive. Instead, we can turn it into a function that takes any numeric vector as input and returns the cleaned result.\nStep 1: Choose a Function Name and Parameter\nWe’ll name the function summarize_vector. To decide what should become the parameter, we look back at the original code:\n\nMean &lt;- mean(v1, na.rm = TRUE)\nSD &lt;- sd(v1, na.rm = TRUE)\nn_missing &lt;- sum(is.na(v1))\n\ncat(\"Mean:\", Mean, \"\\n\")\n\nMean: 30 \n\ncat(\"Standard Deviation:\", SD, \"\\n\")\n\nStandard Deviation: 39.52847 \n\ncat(\"Number of Missing Values:\", n_missing, \"\\n\")\n\nNumber of Missing Values: 1 \n\n\nIn this code, the object v1 appears multiple times. It’s used to calculate the mean, the standard deviation, and the number of missing values. This repetition suggests that v1 is the natural input to the function—it’s the part that changes when we want to analyze a different vector.\nTo make the code reusable, we generalize v1 to a parameter called x. Later, when we call the function, we can pass any numeric vector to x.\nBefore turning this into a full function, it’s a good idea to test whether your edits work. One simple way to do this is to assign v1 to a new variable x, then manually replace all instances of v1 with x in your code. This lets you verify that your logic still works with the parameter name you’ll use inside the function. For example:\n\nx &lt;- v1    ## parameter &lt;- argument\n\nMean &lt;- mean(x, na.rm = TRUE)  # replace v1 with x\nSD &lt;- sd(x, na.rm = TRUE)      # replace v1 with x\nn_missing &lt;- sum(is.na(x))     # replace v1 with x\n\ncat(\"Mean:\", Mean, \"\\n\")\n\nMean: 30 \n\ncat(\"Standard Deviation:\", SD, \"\\n\")\n\nStandard Deviation: 39.52847 \n\ncat(\"Number of Missing Values:\", n_missing, \"\\n\")\n\nNumber of Missing Values: 1 \n\n\nIf this modified version runs correctly, you’re ready to move on to the next step—placing the code into a function definition.\nStep 2: Move the Code into the Function Body\nNext, we place the modified code into the function definition. The input vector x is now the function’s parameter, and everything inside the curly braces {} becomes the body of the function. This is the set of instructions that will be executed whenever the function is called.\n\nsummarize_vector &lt;- function(x) {\n  Mean &lt;- mean(x, na.rm = TRUE)\n  SD &lt;- sd(x, na.rm = TRUE)\n  n_missing &lt;- sum(is.na(x))\n  \n  cat(\"Mean:\", Mean, \"\\n\")\n  cat(\"Standard Deviation:\", SD, \"\\n\")\n  cat(\"Number of Missing Values:\", n_missing, \"\\n\")\n}\n\nAt this point, the function is ready to use. We’ve made the code self-contained and reusable by identifying the input (x) and wrapping the logic inside a clearly named function.\nStep 3: Call the Function with Different Arguments\nNow that the function is defined, we can reuse it on any numeric vector by supplying an argument to the parameter x.\n\nsummarize_vector(v1)\n\nMean: 30 \nStandard Deviation: 39.52847 \nNumber of Missing Values: 1 \n\nsummarize_vector(c(2, 4, 6, NA, 8, 10, NA))\n\nMean: 6 \nStandard Deviation: 3.162278 \nNumber of Missing Values: 2 \n\n\nEach time we call the function, the argument we provide replaces the parameter x inside the function body. The same block of code runs, but it operates on the new data we supplied—saving time and reducing errors compared to copying and pasting the same code repeatedly.\n\n\n5.1.3 Return Values\nThe original version of summarize_vector() simply printed the results using cat(), but it did not return a value. In practice, we often want a function to return an object so that the result can be stored or used later in further computations.\nIn R, the value returned by a function is typically the result of the final (unassigned) expression in the function body. If we want to return multiple values, we usually combine them into a single object. The most common way to do this is to return a list.\nHere’s a revised version of the function that prints the results and returns a list:\n\nsummarize_vector &lt;- function(x) {\n  Mean &lt;- mean(x, na.rm = TRUE)\n  SD &lt;- sd(x, na.rm = TRUE)\n  n_missing &lt;- sum(is.na(x))\n  \n  cat(\"Mean:\", Mean, \"\\n\")\n  cat(\"Standard Deviation:\", SD, \"\\n\")\n  cat(\"Number of Missing Values:\", n_missing, \"\\n\")\n  \n  list(\n    Mean = Mean,\n    SD = SD,\n    N_miss = n_missing\n  )\n}\nv1_summary &lt;- summarize_vector(v1)\n\nMean: 30 \nStandard Deviation: 39.52847 \nNumber of Missing Values: 1 \n\nv1_summary\n\n$Mean\n[1] 30\n\n$SD\n[1] 39.52847\n\n$N_miss\n[1] 1\n\n\nAlternatively, if all the values share the same data type, you can return them as a named vector instead of a list:\n\nsummarize_vector &lt;- function(x) {\n  Mean &lt;- mean(x, na.rm = TRUE)\n  SD &lt;- sd(x, na.rm = TRUE)\n  n_missing &lt;- sum(is.na(x))\n  \n  cat(\"Mean:\", Mean, \"\\n\")\n  cat(\"Standard Deviation:\", SD, \"\\n\")\n  cat(\"Number of Missing Values:\", n_missing, \"\\n\")\n  \n  c(\n    Mean = Mean,\n    SD = SD,\n    N_miss = n_missing\n  )\n}\nv1_summary &lt;- summarize_vector(v1)\n\nMean: 30 \nStandard Deviation: 39.52847 \nNumber of Missing Values: 1 \n\nv1_summary\n\n    Mean       SD   N_miss \n30.00000 39.52847  1.00000 \n\n\nThe important idea here is that a function must return exactly one object. That object can be as simple as a number or as complex as a list or data frame—it just has to be one object. This often requires some thoughtful design, especially when returning multiple pieces of related information.\nFinally, you can also use the return() function to explicitly return a value. Although it’s not required in most cases, return() can be useful if you want to stop a function early and send back a result. You’ll find this especially helpful later when we learn about if statements.\n\nreturn(c(Mean = Mean, SD = SD, N_miss = n_missing))",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Writing User-Defined Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#execution-order-in-functions",
    "href": "functions.html#execution-order-in-functions",
    "title": "5  Writing User-Defined Functions",
    "section": "5.2 Execution Order in Functions",
    "text": "5.2 Execution Order in Functions\nWhen we write functions, it’s not just the individual commands that matter—it’s the order in which we execute them. In most real-world applications, each step depends on the output of a previous step, so getting the sequence right is essential. In this section, we’ll explore this idea using a few concrete examples, starting with some simple ones and building up to more practical applications.\n\n5.2.1 Sequential Execution with Simple Calculations\nWhen writing a function, it’s important to pay attention to the order in which the commands are executed. Many operations depend on results from earlier steps. If you skip a step or rearrange the code incorrectly, the function may fail or return the wrong result.\nLet’s work through a simple example. Suppose we want to standardize the values in a numeric vector, and print the results in a readable format.\nWe can begin by testing this in open code using a sample vector v1.\n\nv1 &lt;- c(5, 10, 12, 15, 18, 100)\n\nmean_v1 &lt;- mean(v1, na.rm = TRUE)\nsd_v1 &lt;- sd(v1, na.rm = TRUE)\n\nz &lt;- (v1 - mean_v1) / sd_v1\nextreme_count &lt;- sum(abs(z) &gt; 2)\n\ncat(\"Standardized values:\", round(z, 2), \"\\n\")\n\nStandardized values: -0.6 -0.46 -0.41 -0.32 -0.24 2.03 \n\ncat(\"Number of extreme values:\", extreme_count, \"\\n\")\n\nNumber of extreme values: 1 \n\n\nEvery line here builds on the previous one. For example, we cannot compute z without calculating the mean and standard deviation first. If you change the order of these statements, the code won’t work.\nWe apply round(z, 2) inside cat() to make the printed output easier to read. The internal calculations are still done with full precision.\nTo make this task reusable, we can write a function. This time, we’ll use two parameters:\n\nx: the numeric vector\ncutoff: the threshold for identifying extreme values\n\nHere’s the function version:\n\nsummarize_extremes &lt;- function(x, cutoff) {\n  mean_x &lt;- mean(x, na.rm = TRUE)\n  sd_x &lt;- sd(x, na.rm = TRUE)\n\n  z &lt;- (x - mean_x) / sd_x\n  extreme_count &lt;- sum(abs(z) &gt; cutoff)\n\n  cat(\"Standardized values:\", round(z, 2), \"\\n\")\n  cat(\"Number of extreme values:\", extreme_count, \"\\n\")\n}\n\nLet’s test the function:\n\nsummarize_extremes(v1, 2)\n\nStandardized values: -0.6 -0.46 -0.41 -0.32 -0.24 2.03 \nNumber of extreme values: 1 \n\nsummarize_extremes(c(1, 2, 3, 4, 100), 1.5)\n\nStandardized values: -0.48 -0.46 -0.44 -0.41 1.79 \nNumber of extreme values: 1 \n\n\nThis example highlights two important ideas about writing functions:\n\nThe order of commands matters—each step often depends on values computed earlier.\nFunctions can be made more flexible by accepting multiple parameters, such as the data and a threshold value.\n\n\n\n5.2.2 Application: Imputing Numeric Variables\nIn the previous chapter, we examined how to replace missing values in a numeric vector with the median. Now, suppose we want to apply this idea more generally—to replace missing values in a column of a data frame. Since this task could be useful across many datasets and variables, it makes sense to write a reusable function.\nWe’ll name this function impute_num().\nChoosing Parameters\nTo make the function flexible, we need to allow both the data frame and the target variable to change. So our function will take two parameters:\n\ndat: the data frame\nvar_name: the name of the numeric variable (as a string)\n\nWe begin by setting up the function shell:\n\nimpute_num &lt;- function(dat, var_name){\n  # Function body\n}\n\nLet’s walk through how to build the function body step by step. We’ll use the patient dataset as our working example:\n\nload(\"patient.RData\")\npatient\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88  NA  32  99    Y    Y     Y\n2   B   NA 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120    N    N     N\n4   D   NA 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88  NA  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190    N    N     N\n10  J   90  NA  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\n\nWe plan to test the function using impute_num(patient, \"GLUC\"). To simulate what happens inside the function, we first assign the argument values to the parameter names:\n\ndat &lt;- patient     ## input argument 1\nvar_name &lt;- \"GLUC\" ## input argument 2\n\nSequential Steps\nNow we can write out the logic. The goal is to replace all NA values in a numeric column with its median. Here’s how we’ll do it:\n\nExtract the numeric column from the data frame using [[ ]]\nCalculate the median of the extracted vector\nReplace the missing values with the median\nInsert the cleaned vector back into the original data frame\n\nEach step must be done in order. For example, we can’t calculate the median before we extract the column. The process looks like this:\n\nselect_var &lt;- dat[[var_name]]                  ## step 1: \nselect_var\n\n [1]  88  NA 110  NA  90  88 120 110  NA  90\n\nreplace_value &lt;- median(select_var, na.rm=T)   ## step 2\nreplace_value\n\n[1] 90\n\nselect_var[is.na(select_var)] &lt;- replace_value ## step 3: \nselect_var \n\n [1]  88  90 110  90  90  88 120 110  90  90\n\ndat[[var_name]] &lt;- select_var                  ## step 4\ndat\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88  NA  32  99    Y    Y     Y\n2   B   90 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120    N    N     N\n4   D   90 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88  NA  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   90 190  NA 190    N    N     N\n10  J   90  NA  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\n\nOnce all the pieces work individually, we can bundle them into our function:\n\nimpute_num &lt;- function(dat, var_name){\n  select_var &lt;- dat[[var_name]]                  ## step 1: \n  replace_value &lt;- median(select_var, na.rm=T)   ## step 2\n  select_var[is.na(select_var)] &lt;- replace_value ## step 3: \n  dat[[var_name]] &lt;- select_var                  ## step 4\n  dat           ## returned value\n}\n\nLet’s test it on different columns:\n\nimpute_num (patient, \"GLUC\")\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88  NA  32  99    Y    Y     Y\n2   B   90 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120    N    N     N\n4   D   90 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88  NA  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   90 190  NA 190    N    N     N\n10  J   90  NA  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\nimpute_num (patient, \"TGL\")   ## try another variable\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88 180  32  99    Y    Y     Y\n2   B   NA 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110 180  NA 120    N    N     N\n4   D   NA 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88 180  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190    N    N     N\n10  J   90 180  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\n\nThis example demonstrates how each step in a function builds on the last—and why preserving the correct order is essential for correct results.\n\n\n5.2.3 Application: Imputing Character Variables\nJust like with numeric variables, we often encounter missing values in character columns—such as patient status, gender, or treatment group. A common strategy is to fill in these missing values using the most frequent (or most common) category.\nIn this section, we’ll create a function called impute_char() to do exactly that. Similar to impute_num(), this function will take two parameters:\n\ndat: the data frame\nvar_name: the name of the character variable (as a string)\n\nLet’s begin with the function shell:\n\nimpute_char &lt;- function(dat, var_name) {\n  # Function body\n}\n\nWe’ll use the same patient dataset to test the commands before writing the complete function. To simulate the function behavior, we assign the test arguments to their corresponding parameter names:\n\ndat &lt;- patient        ## input parameter 1\nvar_name &lt;- \"HRT\"     ## input parameter 2\n\nOur goal is to replace missing values in a character vector with the value that occurs most frequently. Here’s the sequence of operations we’ll follow:\n\nExtract the character column from the data frame.\nCreate a frequency table.\nIdentify the most common value.\nReplace all missing values with that value.\nInsert the updated column back into the data frame.\n\nLet’s test each step:\n\nselect_var &lt;- dat[[var_name]]         # Step 1: extract variable\ntab_result &lt;- table(select_var)       # Step 2: frequency table\nhigh_freq  &lt;- max(tab_result)         # Step 3a: get highest frequency\nreplace_value &lt;- names(tab_result)[tab_result == high_freq]  # Step 3b\nselect_var[is.na(select_var)] &lt;- replace_value  # Step 4\ndat[[var_name]] &lt;- select_var         # Step 5: put it back\ndat\n\n   ID GLUC TGL HDL LDL HRT MAMM SMOKE\n1   A   88  NA  32  99   Y    Y     Y\n2   B   NA 150  60  NA   Y &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120   N    N     N\n4   D   NA 200  65 165   Y &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150   Y    Y     Y\n6   F   88  NA  32 210   Y &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA   Y    Y     Y\n8   H  110 170  70 188   Y &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190   N    N     N\n10  J   90  NA  75  NA   Y &lt;NA&gt;  &lt;NA&gt;\n\n\nAfter confirming these steps work correctly, we can write the full function:\n\nimpute_char &lt;- function(dat, var_name){\n  select_var &lt;- dat[[var_name]]                   # step 1\n  tab_result &lt;- table(select_var)                 # step 2\n  high_freq &lt;- max(tab_result)                    # step 3a\n  replace_value &lt;- names(tab_result)[tab_result == high_freq]  # step 3b\n  select_var[is.na(select_var)] &lt;- replace_value  # step 4\n  dat[[var_name]] &lt;- select_var                   # step 5\n  dat  # return updated data frame\n}\n\nLet’s test it out:\n\nimpute_char(patient, \"HRT\")\n\n   ID GLUC TGL HDL LDL HRT MAMM SMOKE\n1   A   88  NA  32  99   Y    Y     Y\n2   B   NA 150  60  NA   Y &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120   N    N     N\n4   D   NA 200  65 165   Y &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150   Y    Y     Y\n6   F   88  NA  32 210   Y &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA   Y    Y     Y\n8   H  110 170  70 188   Y &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190   N    N     N\n10  J   90  NA  75  NA   Y &lt;NA&gt;  &lt;NA&gt;\n\n\nThis example reinforces the importance of logic and order: we must first identify the most frequent value before using it to fill in missing entries.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Writing User-Defined Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#function-parameters",
    "href": "functions.html#function-parameters",
    "title": "5  Writing User-Defined Functions",
    "section": "5.3 Function Parameters",
    "text": "5.3 Function Parameters\nWhen we define a function, we often include one or more parameters—placeholders that will be filled with actual values, known as arguments, when the function is called. Understanding how arguments are matched to parameters, how default values work, and how R evaluates them is essential for writing clear, reusable, and flexible functions. In the following subsections, we explore different ways arguments can be passed to parameters, how default values simplify function calls, and when certain types of parameter behavior matter in practice.\n\n5.3.1 Matching Arguments to Parameters\nIn the impute_num() function, there are two parameters: dat and var_name. When we call the function like this:\n\nimpute_num(patient, \"GLUC\")\n\nthe argument patient is assigned to the parameter dat, and \"GLUC\" is assigned to var_name. This method of matching arguments by their position in the function call is called positional matching.\nAn alternative approach is keyword matching, where we specify arguments using the parameter = argument format:\n\nimpute_num(dat = patient, var_name = \"GLUC\")\n\nWith keyword matching, we do not need to follow the parameter order:\n\nimpute_num(var_name = \"GLUC\", dat = patient)\n\nBoth positional and keyword matching can be used together, although once you use keyword matching in a function call, it’s best to continue using it for clarity.\n\n\n5.3.2 Default Arguments\nWe can assign default values to one or more parameters, making the function more flexible and easier to use. This is helpful when one parameter usually takes the same value. For example, suppose we use the patient dataset most of the time. We can set it as the default for dat:\n\nimpute_num &lt;- function(dat = patient, var_name) {\n  select_var &lt;- dat[[var_name]] \n  replace_value &lt;- median(select_var, na.rm = TRUE) \n  select_var[is.na(select_var)] &lt;- replace_value \n  dat[[var_name]] &lt;- select_var \n  dat \n}\n\nNow, we only need to specify var_name when using the patient dataset:\n\nimpute_num(var_name = \"GLUC\")\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88  NA  32  99    Y    Y     Y\n2   B   90 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120    N    N     N\n4   D   90 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88  NA  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   90 190  NA 190    N    N     N\n10  J   90  NA  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\n\nIf we supply a different data frame, it overrides the default:\n\nfoo &lt;- data.frame(var1 = c(1, 4, NA, 7, 9))\nimpute_num(foo, \"var1\")\n\n  var1\n1  1.0\n2  4.0\n3  5.5\n4  7.0\n5  9.0\n\n\n\n\n5.3.3 Why Use [[ Instead of $?\nInside the function, we extract a column with dat[[var_name]] rather than dat$var_name. This is because the $ operator does not evaluate variables, so writing dat$var_name will literally look for a column named \"var_name\", not the value stored in the var_name variable. The double bracket operator [[ ]], however, evaluates its argument and works with variable column names.\n\n\n5.3.4 Parameterless Functions\nNot all functions require input parameters. While less common for beginners, parameterless functions can still be useful. Here’s a simple example:\n\ngreeting_function &lt;- function() {\n  print(\"Hello, welcome to the world of R programming!\")\n}\ngreeting_function()\n\n[1] \"Hello, welcome to the world of R programming!\"\n\n\nThis function will always return the same greeting when called, without needing any input.\nIf a function body contains only a single command, the curly braces {} are optional. For example, the following version of greeting_function() is equivalent:\n\ngreeting_function &lt;- function() print(\"Hello, welcome to the world of R programming!\")\ngreeting_function()\n\n[1] \"Hello, welcome to the world of R programming!\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Writing User-Defined Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#condition-logic",
    "href": "functions.html#condition-logic",
    "title": "5  Writing User-Defined Functions",
    "section": "5.4 Condition Logic",
    "text": "5.4 Condition Logic\nIn programming, conditional logic allows us to control which pieces of code run based on whether certain conditions are true or false. Just as people make decisions based on situations (“If it’s raining, take an umbrella”), R functions can adapt their behavior using structures like if, else, and logical operators. These tools make our code smarter and more flexible—able to handle different inputs, trigger warnings, or change behavior depending on data values.\nThis section introduces several key components of conditional logic:\n\n5.4.1 The if Statement\nThe if statement is the most basic form of conditional logic in R. It allows your code to make decisions: if a certain condition is true, do one thing; if not, do something else. The general forms of the if statement are:\nif (condition) expression\nif (condition) expression else alternative_expression\nIn the first form, R evaluates the condition. If it is true, it runs the expression. If it is false, nothing happens.\nIn the second form, the else block provides an alternative. If the condition is false, R will execute the alternative_expression. This syntax and logic flow are consistent with standard base R practices, as outlined in R Programming for Data Science (Peng 2020).\nHere’s a simple example:\n\nscore &lt;- 73\nif (score &gt;=60) grade &lt;- \"pass\" else grade &lt;- \"fail\"\ngrade\n\n[1] \"pass\"\n\n\nIf your logic spans multiple lines, you should enclose the expressions inside curly braces {} to create a code block:\nif (condition) {\n  command_1\n  command_2\n  ...\n} else {\n  command_3\n  command_4\n  ...\n}\nFor example:\n\nscore &lt;- 73\nif (score &gt;=60) {\n  grade &lt;- \"pass\" \n  score &lt;- round(score/10)\n} else {\n  grade &lt;- \"fail\"\n  score &lt;- 0\n}\ngrade\n\n[1] \"pass\"\n\nscore\n\n[1] 7\n\n\nIf you need to check multiple conditions, you can chain them using else if:\nif (cond_1) {\n  command(s)\n} else if (cond_2){\n  command(s)\n} else if (cond_3){\n  command(s)\n} else{\n  command(s)\n}\nFor example:\n\nscore &lt;- 73\nif (score &gt;=90) {\n  grade &lt;- \"A\" \n} else if (score &gt;=80) {\n  grade &lt;- \"B\"\n} else if (score &gt;=70) {\n  grade &lt;- \"C\"\n} else if (score &gt;=60) {\n  grade &lt;- \"D\"\n} else {\n  grade &lt;- \"F\"\n} \ngrade\n\n[1] \"C\"\n\n\nEach condition is evaluated in order. Once a condition is found to be true, the corresponding block is executed, and the rest are skipped.\n\n\n5.4.2 Logical Operators\nLogical operators allow us to compare values and evaluate conditions. In R, the most commonly used logical operators are:\n\n& (element-wise AND)\n| (element-wise OR)\n! (logical NOT)\n\nThese operators compare vectors element by element:\n\na &lt;- c(3, 0, 9, -1, 0, 8, -2)\na &lt; 5 & a != 0    \n\n[1]  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE\n\na &lt; 3 | a &gt;= 8   \n\n[1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\nIn addition to the element-wise operators, R provides short-circuit logical operators:\n\n&& (short-circuit AND)\n|| (short-circuit OR)\n\nThese two operators evaluate expressions from left to right and stop as soon as the result is known. They are used primarily in control structures like if statements.\nImportant: Both && and || require each side to return a single logical value. Using them on vectors longer than one element will result in an error.\nThe following function uses a short-circuit && operator inside an if statement to ensure that the input is numeric and all values are positive before calculating square roots and logarithms:\n\nsqrt_log &lt;- function(x){\n  if (is.numeric(x) && min(x) &gt; 0){\n    x_sqrt &lt;- sqrt(x)\n    x_log &lt;- log(x)\n  } else {\n    x_sqrt &lt;- NA\n    x_log &lt;- NA\n  }\n  c(x_sqrt, x_log)\n}\n\nWhen the input meets the condition, the calculations proceed:\n\nsqrt_log(c(2,4,3))\n\n[1] 1.4142136 2.0000000 1.7320508 0.6931472 1.3862944 1.0986123\n\n\nIf not, the function returns NA values:\n\nsqrt_log(c(\"hello\"))\n\n[1] NA NA\n\n\nThis demonstrates how short-circuit logic can help ensure safe execution by checking multiple conditions before proceeding.\n\n\n5.4.3 Application: Print Customized Message\nWhen writing functions, it’s often helpful to provide feedback to users when inputs do not meet expectations. This can make functions easier to use and debug. There are several ways to communicate issues or guidance to users, depending on how severe the issue is and whether or not the function should continue running.\nstop(): Halt Execution with an Error Message\nUse the stop() function to terminate execution immediately when a critical condition is not met. This is useful when continuing the function could lead to incorrect results or unexpected behavior.\n\nsqrt_log &lt;- function(x){\n  if (is.numeric(x) && min(x) &gt; 0){\n    x_sqrt &lt;- sqrt(x)\n    x_log &lt;- log(x)\n  } else \n    stop (\"x must be a numeric vector with values &gt; 0.\")\n  c(x_sqrt, x_log)\n}\nsqrt_log(c(\"hello\"))\n\nError in sqrt_log(c(\"hello\")): x must be a numeric vector with values &gt; 0.\n\n\ncat(): Print a Message and Continue Execution\nThe cat() function can be used to print a message to the console without interrupting the flow of execution. You might use this when a non-critical issue arises but the function can still return a fallback result.\n\nsqrt_log &lt;- function(x){\n  if (is.numeric(x) && min(x) &gt; 0){\n    x_sqrt &lt;- sqrt(x)\n    x_log &lt;- log(x)\n  } else {\n    cat (\"x must be a numeric vector with values &gt; 0. \\n\")\n    x_sqrt &lt;- NA\n    x_log &lt;- NA\n  } \n  c(x_sqrt, x_log)\n}\nsqrt_log(c(\"hello\"))\n\nx must be a numeric vector with values &gt; 0. \n\n\n[1] NA NA\n\n\nwarning(): Signal a Warning but Continue Execution\nThe warning() function signals that something might be wrong, but it doesn’t stop execution. This is useful when the function can proceed, but the user should be alerted to a potential issue.\n\nsqrt_log &lt;- function(x){\n  if (is.numeric(x) && min(x) &gt; 0){\n    x_sqrt &lt;- sqrt(x)\n    x_log &lt;- log(x)\n  } else {\n    warning(\"x should be a numeric vector with values &gt; 0.\")\n    x_sqrt &lt;- NA\n    x_log &lt;- NA\n  } \n  c(x_sqrt, x_log)\n}\n\nsqrt_log(c(\"hello\"))  # Issues warning, returns NA\n\nWarning in sqrt_log(c(\"hello\")): x should be a numeric vector with values &gt; 0.\n\n\n[1] NA NA\n\n\nSummary\n\nUse stop() when the input is invalid and you want to halt the function.\nUse warning() when the input is questionable but the function can still proceed.\nUse cat() when you want to print a friendly message to the user without treating it as an error or warning.\n\n\n\n5.4.4 Application: The impute() Function\nTo avoid writing separate functions for numeric and character variables, we can combine both imputation tasks into a single function using conditional logic. The impute() function checks the variable type and then decides how to compute the replacement value. We also add a check to ensure the variable name is valid within the provided data frame.\nBefore defining the function, it’s a good idea to test the code line by line:\n\ndat &lt;- patient                  ## input data frame\nvar_name &lt;- \"HRT\"               ## name of the variable to impute\n\nif(!var_name %in% names(dat)){  ## check if var_name exists in dat\n  stop(var_name, \" is not in the given data\", \"\\n\")\n}\n\nselect_var &lt;- dat[[var_name]]   ## extract the variable from the data frame\n\nif(is.numeric(select_var)) {    ## if the variable is numeric...\n  replace_value &lt;- median(select_var, na.rm = TRUE)  ## compute the median\n} else {                        ## otherwise (e.g., character variable)...\n  tab_result &lt;- table(select_var)               ## create frequency table\n  high_freq &lt;- max(tab_result)                  ## find the max frequency\n  replace_value &lt;- names(tab_result)[tab_result == high_freq] \n                                                ## get most frequent value\n}\n\nselect_var[is.na(select_var)] &lt;- replace_value  ## replace missing values\ndat[[var_name]] &lt;- select_var                   ## update the original data\ndat                                             ## return the updated data\n\n   ID GLUC TGL HDL LDL HRT MAMM SMOKE\n1   A   88  NA  32  99   Y    Y     Y\n2   B   NA 150  60  NA   Y &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120   N    N     N\n4   D   NA 200  65 165   Y &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150   Y    Y     Y\n6   F   88  NA  32 210   Y &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA   Y    Y     Y\n8   H  110 170  70 188   Y &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190   N    N     N\n10  J   90  NA  75  NA   Y &lt;NA&gt;  &lt;NA&gt;\n\n\nOnce verified, we can wrap these steps into a reusable function:\n\nimpute &lt;- function(dat, var_name){\n  if(!var_name %in% names(dat)){\n    stop(var_name, \"is not in the given data\", \"\\n\")\n  }\n  select_var &lt;- dat[[var_name]]\n  if(is.numeric(select_var)) { \n    replace_value &lt;- median(select_var, na.rm=T)\n  } else{\n    tab_result &lt;- table(select_var)\n    high_freq &lt;- max(tab_result)\n    replace_value &lt;-names(tab_result)[tab_result == high_freq]\n  }\n  select_var[is.na(select_var)] &lt;- replace_value\n  dat[[var_name]] &lt;- select_var\n  dat\n}\nimpute(patient, \"HRT\")\n\n   ID GLUC TGL HDL LDL HRT MAMM SMOKE\n1   A   88  NA  32  99   Y    Y     Y\n2   B   NA 150  60  NA   Y &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120   N    N     N\n4   D   NA 200  65 165   Y &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150   Y    Y     Y\n6   F   88  NA  32 210   Y &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA   Y    Y     Y\n8   H  110 170  70 188   Y &lt;NA&gt;  &lt;NA&gt;\n9   I   NA 190  NA 190   N    N     N\n10  J   90  NA  75  NA   Y &lt;NA&gt;  &lt;NA&gt;\n\nimpute(patient, \"GLUC\")\n\n   ID GLUC TGL HDL LDL  HRT MAMM SMOKE\n1   A   88  NA  32  99    Y    Y     Y\n2   B   90 150  60  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n3   C  110  NA  NA 120    N    N     N\n4   D   90 200  65 165 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n5   E   90 210  NA 150    Y    Y     Y\n6   F   88  NA  32 210 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n7   G  120 164  NA  NA    Y    Y     Y\n8   H  110 170  70 188 &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n9   I   90 190  NA 190    N    N     N\n10  J   90  NA  75  NA &lt;NA&gt; &lt;NA&gt;  &lt;NA&gt;\n\n\n\n\n\n\nPeng, Roger D. 2020. R Programming for Data Science. Leanpub. https://bookdown.org/rdpeng/rprogdatascience/.\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023. R for Data Science. 2nd ed. O’Reilly Media. https://r4ds.hadley.nz/functions.html.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Writing User-Defined Functions</span>"
    ]
  },
  {
    "objectID": "iteration.html#more-examples-of-for-loops",
    "href": "iteration.html#more-examples-of-for-loops",
    "title": "6  Iteration",
    "section": "6.2 More Examples of for Loops",
    "text": "6.2 More Examples of for Loops\nWhile the previous section focused on looping through columns of a matrix, we can also use for loops to process vectors, perform sequential comparisons, and work with lists. The following examples demonstrate how loops can be applied in various situations.\nThe first example shows that we do not always need to use an index variable like i. Instead, we can loop directly through the elements of a vector. Suppose we are classifying a set of temperature readings. If a temperature is 72 or higher, we consider it “Hot”; otherwise, it is “Cold.” We can loop through each temperature value and display the result:\n\ntemps &lt;- c(68, 75, 70, 80, 65)\n\nfor (t in temps) {\n  if (t &gt;= 72) {\n    cat(t, \"is Hot\\n\")\n  } else {\n    cat(t, \"is Cold\\n\")\n  }\n}\n\n68 is Cold\n75 is Hot\n70 is Cold\n80 is Hot\n65 is Cold\n\n\nThis program performs an action on each element of the vector, demonstrating a second way to use a for loop—looping along the values directly instead of using an index. While the same result could be achieved using a vectorized function such as ifelse(), a loop provides more flexibility in formatting and control over the output.\nIn the next example, we simulate a situation where we want to detect how often a patient’s condition fluctuates based on a series of temperature readings. A temperature of 100.4°F or higher is considered a fever. To simplify classification, we use the ifelse() function, which is a vectorized alternative to writing multiple if statements.\n\ntemp_readings &lt;- c(98.6, 101.2, 100.8, 98.7, 99.1)\nstatus &lt;- ifelse(temp_readings &gt;= 100.4, \"Fever\", \"Normal\")\nstatus\n\n[1] \"Normal\" \"Fever\"  \"Fever\"  \"Normal\" \"Normal\"\n\n\nThe ifelse() function takes three arguments: a condition to test, a value to return when the condition is true, and a value to return when it is false. In this example, each temperature is compared to 100.4, and a label of “Fever” or “Normal” is assigned accordingly.\nOnce the classification is complete, we can use a loop to count how many times the status changes from one reading to the next:\n\nfluctuations &lt;- 0\nfor (i in 2:length(status)) {\n  if (status[i] != status[i - 1]) {\n    fluctuations &lt;- fluctuations + 1\n  }\n}\nfluctuations\n\n[1] 2\n\n\nThis type of comparison—where the current value is compared to the previous one—requires sequential access and is naturally suited to a loop. Vectorized functions like ifelse() are not well suited for tasks that depend on the order of elements or previous values.\nIn the final example, we consider a list of sales figures from different stores. We want to calculate and report the average sales for each store. Since we are dealing with a named list, we can use the names of the list elements to access and summarize each component.\n\nsales_data &lt;- list(\n  store_A = c(200, 250, 220),\n  store_B = c(300, 320, 310),\n  store_C = c(150, 180, 170)\n)\n\nfor (name in names(sales_data)) {\n  cat(\"Average sales for\", name, \":\", mean(sales_data[[name]]), \"\\n\")\n}\n\nAverage sales for store_A : 223.3333 \nAverage sales for store_B : 310 \nAverage sales for store_C : 166.6667 \n\n\nThis example shows how a for loop can be applied to a list. Although we could achieve similar results using a function like sapply(), we will introduce that approach in a later section. For now, using a loop helps reinforce how to access and manipulate list elements using their names.\nTogether, these three examples—looping over a vector, comparing sequential elements, and iterating through list components—highlight the flexibility and power of the for loop. They show how looping structures can handle a wide range of repetitive tasks across different data types.\n\n6.2.1 The while Loop\nIn many situations, we know ahead of time how many times a loop should run, which makes for loops a natural choice. However, there are cases where the number of iterations is not known in advance. In those cases, we can use a while loop.\nA while loop contains a condition and a body. The loop continues to run as long as the condition evaluates to TRUE.\n\nwhile (condition) {\n  ## code to execute\n}\n\nThe key idea behind a while loop is that the stopping point depends on a condition that is evaluated within the loop. Let’s look at a practical example.\nSuppose we receive patient records in random order, and we want to search through them until we find the one with ID 1005.\n\npatient_ids &lt;- sample(1001:1010)  # randomly shuffled IDs\ni &lt;- 1\n\nwhile (patient_ids[i] != 1005) {\n  cat(\"Checked patient\", patient_ids[i], \"\\n\")\n  i &lt;- i + 1\n}\n\nChecked patient 1003 \nChecked patient 1010 \nChecked patient 1002 \nChecked patient 1008 \nChecked patient 1006 \nChecked patient 1009 \nChecked patient 1001 \nChecked patient 1007 \n\ncat(\"Found patient\", patient_ids[i], \"- stopping.\\n\")\n\nFound patient 1005 - stopping.\n\n\nIn this case, we do not know how many patients we’ll need to examine. The loop runs until we encounter the target ID. Note that the index variable i must be initialized before the loop and updated manually inside the loop body. Without this, the loop may never terminate.\nAlthough any for loop can be rewritten as a while loop, the reverse is not true—some problems require while because the exit condition depends on dynamic logic, not a predefined sequence.\nWe can also mention two additional loop tools:\n\nThe repeat loop, which runs indefinitely until a break statement is encountered.\nThe break command, which can be used inside any loop to exit early when a condition is met.\n\nThese constructs are not commonly needed for most routine data tasks, so we will not explore them further here.\n\n\n6.2.2 Rewriting the impute() Function with a Loop\nIn the previous chapter, we introduced the impute() function, which handled missing values for a single variable at a time. However, when multiple variables require imputation, repeating the same function call is inefficient. A loop allows us to process all specified variables in one pass, making the function more flexible and scalable.\nTo rewrite the function, we follow three basic steps. First, we identify the sequence of variables to loop over. In this case, we use a character vector var_list containing the names of the variables to be imputed. Second, we create the loop. This can be done with a standard index like 1:length(var_list), though it is generally safer to use seq_along(var_list) to avoid issues when the list is empty. Finally, we write the loop body, which applies the imputation logic to each variable.\nAt the beginning of the loop, we extract the name of the current variable using var_name &lt;- var_list[i], and then proceed with the imputation logic used previously. After filling in the missing values, we update the column in the original dataset.\nHere is the final version of the function:\n\nimpute_N &lt;- function(dat, var_list){\n  for (i in seq_along(var_list)){\n    var_name &lt;- var_list[i]\n    select_var &lt;- dat[[var_name]]\n    if(is.numeric(select_var)) {\n      replace_value &lt;- median(select_var, na.rm=T)\n    } else{\n      tab_result &lt;- table(select_var)\n      high_freq &lt;- max(tab_result)\n      replace_value &lt;-names(tab_result)[tab_result == high_freq]\n    }\n    select_var[is.na(select_var)] &lt;- replace_value\n    dat[[var_name]] &lt;- select_var\n  }\n  dat\n}\n\nTo apply the function, we pass both the dataset and a character vector of variable names to be imputed:\n\nimpute_N(patient, c(\"TGL\", \"HDL\", \"LDL\", \"HRT\", \"MAMM\"))\n\n   ID GLUC TGL  HDL LDL HRT MAMM SMOKE\n1   A   88 180 32.0  99   Y    Y     Y\n2   B   NA 150 60.0 165   Y    Y  &lt;NA&gt;\n3   C  110 180 62.5 120   N    N     N\n4   D   NA 200 65.0 165   Y    Y  &lt;NA&gt;\n5   E   90 210 62.5 150   Y    Y     Y\n6   F   88 180 32.0 210   Y    Y  &lt;NA&gt;\n7   G  120 164 62.5 165   Y    Y     Y\n8   H  110 170 70.0 188   Y    Y  &lt;NA&gt;\n9   I   NA 190 62.5 190   N    N     N\n10  J   90 180 75.0 165   Y    Y  &lt;NA&gt;\n\n\nThis version of the impute() function can handle any number of variables and illustrates how a for loop can help automate repetitive tasks in a structured and reliable way.\n\n\n6.2.3 When to Use Loops vs Vectorized Solutions (New - optional)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "iteration.html#efficient-repetition-with-apply-type-functions",
    "href": "iteration.html#efficient-repetition-with-apply-type-functions",
    "title": "6  Iteration",
    "section": "6.2 Efficient Repetition with “Apply-type” Functions",
    "text": "6.2 Efficient Repetition with “Apply-type” Functions\nMany data analysis tasks involve performing the same computation repeatedly across different parts of a data structure—such as rows of a matrix, columns of a data frame, or elements of a list. While loops can be used for such repetition, R provides a set of vectorized tools called apply-type functions that often make code shorter, faster, and more expressive. The table below summarizes the most commonly used apply-type functions and highlights their typical inputs and outputs:\n\n\n\n\n\n\n\n\n\n\nFunction\nInput Type\nApplies Function To\nOutput Type\nNotes\n\n\n\n\napply()\nMatrix or data frame\nRows (1), Columns (2), or both\nVector, matrix, or list\nOften used for row/column operations\n\n\nlapply()\nVector, list or data frame\nEach element\nList\nAlways returns a list\n\n\nsapply()\nVector, list or data frame\nEach element\nSimplified result\nTries to simplify (e.g., to vector or matrix)\n\n\nvapply()\nVector or List\nEach element\nPre-specified format\nSafer, but more verbose than sapply()\n\n\ntapply()\nVector\nGroups defined by factor(s)\nArray or vector\nUsed for grouped summary statistics\n\n\nmapply()\nMultiple vectors\nElements in parallel\nList or simplified\nMultivariate version of sapply()\n\n\nMap()\nMultiple vectors\nElements in parallel\nList\nSimilar to mapply(), but returns a list always\n\n\nreplicate()\nExpression\nRepeated evaluation\nVector, matrix, or list\nUseful for simulation or bootstrapping\n\n\n\nNote: The functions mapply(), Map(), and replicate() are not covered in this chapter. You are encouraged to explore their usage by reading the official R documentation if you’re interested.\n\n6.2.1 Anonymous Functions\nBefore we learn how to use apply-type functions, let’s take a moment to understand anonymous functions, which are often used together with these tools.\nAn anonymous function is simply a function that does not have a name. Instead of assigning it to an object, we define and use it on the fly—typically for one-time or short-term use. This can be helpful when the function is simple and doesn’t need to be reused elsewhere.\nHere is the traditional syntax for writing a simple function:\n\ndouble &lt;- function(x) 2 * x\ndouble(10)\n\n[1] 20\n\n\nNote that we did not use curly braces since the function body contains only a single command. Now, we can define the same logic anonymously, without assigning the function to a name:\n\n(function(x) 2 * x)(10)\n\n[1] 20\n\n\nThis creates the function and immediately applies it to the value 10. The function works the same way because the named function double on the left-hand side of the assignment operator (&lt;-) is equivalent to everything on the right: function(x) 2 * x.\nStarting with R version 4.1.0, a new and more compact syntax was introduced: we can replace the keyword function with a backslash (\\). For example:\n\ndouble &lt;- \\(x) 2 * x\ndouble(10)\n\n[1] 20\n\n\nThis shorthand notation is especially useful when writing anonymous functions inline:\n\n(\\(x) 2 * x) (10)\n\n[1] 20\n\n\nAnonymous functions can also contain multiple statements by wrapping the body in curly braces. For example, here’s a function that prints a number, doubles it, and then returns the result:\n\n(\\(x) {\n  cat(\"Input value is:\", x, \"\\n\")\n  2 * x\n})(7)\n\nInput value is: 7 \n\n\n[1] 14\n\n\nAlthough short, one-line anonymous functions are more common, it’s good to know that multi-step logic can be included when needed.\n\n\n6.2.2 Apply to Matrices\nR provides several built-in functions for computing summary statistics across the rows or columns of a matrix, including rowSums(), rowMeans(), colSums(), and colMeans(). However, for more flexible and general-purpose operations, the apply() function is a powerful tool.\nThe apply() function takes the following arguments:\n\nX: a matrix or an array.\nMARGIN: an integer indicating the dimension(s) to apply the function over. Use 1 for rows, 2 for columns\nFUN: a function (either built-in or user-defined) to apply to each row or column.\n...: additional arguments to be passed to the function specified in FUN.\n\nThe result returned by apply() is typically a vector or matrix, depending on the output of the function and the margin specified.\nLet’s revisit our blood pressure matrix example:\n\nbp \n\n     systolic diastolic pulse\n[1,]      120        80    70\n[2,]      122        78    72\n[3,]       NA        85    68\n[4,]      118        82    75\n[5,]      130        79    71\n\n\nWhen we run:\n\napply(bp, 2, mean)\n\n systolic diastolic     pulse \n       NA      80.8      71.2 \n\n\nwe are instructing R to compute the median for each column of the matrix. Internally, the apply() function loops through the matrix column by column, passing each column (as a vector) into the mean() function. Similarly, if we want to compute the mean for each row:\n\napply(bp, 1, mean)\n\n[1] 90.00000 90.66667       NA 91.66667 93.33333\n\n\nthis time, each row is treated as the input to mean(). In both cases, apply() eliminates the need to write out a manual loop.\nBy default, mean() will return NA if any value is missing. To handle this, we need to specify the optional argument na.rm = TRUE. This additional argument is written in the form of parameter = value and placed after the function name:\n\napply(bp, 2, mean, na.rm = TRUE)\n\n systolic diastolic     pulse \n    122.5      80.8      71.2 \n\n\nThe optional arguments na.rm = TRUE are passed along directly to mean(). You can include as many optional arguments as needed. For example:\n\napply(bp, 2, mean, na.rm = TRUE, trim = 0.1)\n\n systolic diastolic     pulse \n    122.5      80.8      71.2 \n\n\n\n\n6.2.3 Applying to a List or a Vector\nMost R functions are designed to work element-by-element on vectors. However, these same functions do not always work directly on lists. To address this, R provides a family of apply-type functions specifically designed for iterating over the elements of a list or vector. The most commonly used ones are lapply(), sapply(), and vapply().\nThese functions share a similar interface:\n\nX: a vector or a list.\nFUN: a function to be applied to each element.\n...: optional arguments passed to FUN.\n\nlapply() vs sapply()\nThe difference lies in what they return:\n\nlapply() always returns a list, regardless of the output of the applied function.\nsapply() tries to simplify the result to a vector, or matrix if possible. If not, it falls back to a list.\n\nLet’s walk through an example. Suppose we have a list where each element is a numeric vector. We want to calculate the mean of each component:\n\n\n$a\n[1] 3.762096\n\n$b\n[1] 4.732654\n\n$c\n[1] 2.090286\n\n\n       a        b        c \n3.762096 4.732654 2.090286 \n\n\nNotice that the sapply() function above simplifies the result into a vector, whereas the lapply() function returns a list as the result.\nUsing Custom or Anonymous Functions\nYou are not limited to built-in functions. You can also apply your own:\n\nmean_sd &lt;- function(x){\n  c(MEAN = mean(x, na.rm = T), SD = sd(x, na.rm = T))\n}\nlapply(a, mean_sd)\n\n$a\n    MEAN       SD \n3.762096 3.653015 \n\n$b\n    MEAN       SD \n4.732654 1.911215 \n\n$c\n    MEAN       SD \n2.090286 0.720553 \n\n\nOr define the function inline using an anonymous function:\n\nsapply(a, function(x) {\n  c(MEAN = mean(x, na.rm = TRUE), SD = sd(x, na.rm = TRUE))\n})\n\n            a        b        c\nMEAN 3.762096 4.732654 2.090286\nSD   3.653015 1.911215 0.720553\n\n\nOr use the new function notation by typing the following:\n\nsapply(a, \\(x) {\n  c(MEAN = mean(x, na.rm = TRUE), SD = sd(x, na.rm = TRUE))\n})\n\n            a        b        c\nMEAN 3.762096 4.732654 2.090286\nSD   3.653015 1.911215 0.720553\n\n\nA Safer Alternative: vapply()\nWhile sapply() is convenient, it can be unpredictable in what it returns. This is where vapply() comes in—it requires you to specify the exact structure of the output, making the result more stable and safer to use in programming.\nFor example, if we know that the result should always be a single numeric value, we can use:\n\nvapply(a, mean, numeric(1), na.rm = TRUE)\n\n       a        b        c \n3.762096 4.732654 2.090286 \n\n\nIf each function call returns a vector of two named values, we can specify:\n\nvapply(a, \\(x) c(MEAN = mean(x, na.rm = TRUE), \n                        SD = sd(x, na.rm = TRUE)), \n       numeric(2))\n\n            a        b        c\nMEAN 3.762096 4.732654 2.090286\nSD   3.653015 1.911215 0.720553\n\n\nSpecifying the expected result type with numeric(2) ensures consistent output and helps catch errors early.\nLists vs Data Frames\nRemember that data frames are actually lists of equal-length vectors. This means we can apply these same functions to each column of a data frame.\n\nd &lt;- data.frame(\n  var1 = c(1, 3, 7),\n  var2 = c(3, 5, 10)\n)\n\napply(d, 2, sum)            # Treats data frame as matrix\n\nvar1 var2 \n  11   18 \n\nsapply(d, sum)              # Treats columns as list elements\n\nvar1 var2 \n  11   18 \n\nlapply(d, sum)              # Same, but returns a list\n\n$var1\n[1] 11\n\n$var2\n[1] 18\n\nvapply(d, sum, numeric(1))  # Safe version, ensures numeric output\n\nvar1 var2 \n  11   18 \n\n\nIn general:\n\nUse lapply() when you want list output.\nUse sapply() when you want a simplified output (but are okay with some risk).\nUse vapply() when you want strict control over the return type.\n\n\n\n6.2.4 Applying to Grouped Data\nThe tapply() function is designed to apply a function to subsets of a vector, where the subsets are defined by the levels of one or more categorical variables (factors). This is especially useful when you want to compute summary statistics within groups.\nHere are the key arguments of the tapply() function:\n\nX: A numeric (or character) vector containing the values to be operated on.\nINDEX: A factor or list of factors that defines the grouping. Each unique combination of factor levels determines one subset of X.\nFUN: The function to apply to each group.\n...: Additional arguments passed to FUN.\n\nWe will use the quine data frame from the MASS package to illustrate how tapply() works. This dataset includes information about school absences among children in Walgett, New South Wales, Australia. The Days column records the number of days a student was absent during the school year, and other columns classify students by Ethnicity (Eth), Age, Sex, and Learner status (Lrn).\n\nlibrary(MASS)\nhead(quine)\n\n  Eth Sex Age Lrn Days\n1   A   M  F0  SL    2\n2   A   M  F0  SL   11\n3   A   M  F0  SL   14\n4   A   M  F0  AL    5\n5   A   M  F0  AL    5\n6   A   M  F0  AL   13\n\n\nApplying tapply() with a Single Grouping Variable\nSuppose we want to calculate the mean number of days absent for each age group. We can do this by grouping quine$Days by quine$Age:\n\ntapply(quine$Days, quine$Age, mean)\n\n      F0       F1       F2       F3 \n14.85185 11.15217 21.05000 19.60606 \n\n\nThis returns the average number of days absent for each level of the Age factor.\nApplying tapply() with Multiple Grouping Variables\nWe can also apply a function across multiple grouping variables by passing a list of factors to the INDEX argument. For example, to compute the mean number of days absent by both Age and Sex:\n\ntapply(quine$Days, list(quine$Age, quine$Sex), mean)\n\n          F        M\nF0 18.70000 12.58824\nF1 12.96875  7.00000\nF2 18.42105 23.42857\nF3 14.00000 27.21429\n\n\nThis produces a table where each cell shows the average number of days absent for a specific combination of Age and Sex.\nWhen using multiple grouping variables, tapply() outputs a matrix-like structure (if possible) that makes cross-group comparisons easier.\nSplitting the Data\nSometimes, it’s more convenient to split the data into a list and then apply operations to each component using lapply() or sapply(). The split() function divides a data vector or a data frame based on one or more grouping factors. Its two primary arguments are:\n\nx: a vector or a data frame to be split.\nf: a factor (or list of factors) used to define the groups.\n\nThe result is a list, where each element corresponds to one level (or combination of levels) of the grouping factor(s).\nWhile the tapply() function offers a compact way to apply a function across groups, the split() + sapply() (or lapply()) approach offers greater flexibility, especially when you want to perform multiple operations on each group.\nFor example, to compute the mean number of days absent for each Age group in the quine dataset, we can first split the Days variable:\n\nDays_by_Age &lt;- split(quine$Days, quine$Age)\nDays_by_Age\n\n$F0\n [1]  2 11 14  5  5 13 20 22  3  5 11 24 45  6 17 67  0  0  2  7 11 12 25 10 11\n[26] 20 33\n\n$F1\n [1]  6  6 15  7 14  5  6  6  9 13 23 25 32 53 54  5  5 11 17 19  0  0  5  5  5\n[26] 11 17  3  4  5  7  0  1  5  5  5  5  7 11 15  5 14  6  6  7 28\n\n$F2\n [1]  6 32 53 57 14 16 16 17 40 43 46  8 13 14 20 47 48 60 81  2 22 30 36  8  0\n[26]  1  5  7 16 27  0  5 14  2  2  3  8 10 12  1\n\n$F3\n [1]  8 23 23 28 34 36 38  0  2  3  5 10 14 21 36 40  0 30 10 14 27 41 69  1  9\n[26] 22  3  3  5 15 18 22 37\n\n\nNow that we have a list, we can easily apply a function to each element:\n\nsapply(Days_by_Age, mean)\n\n      F0       F1       F2       F3 \n14.85185 11.15217 21.05000 19.60606 \n\n\nThis produces the same result as tapply(), but in a format that may be easier to extend or customize.\nWe can also perform multiple calculations per group. For example, to compute both the mean and the median:\n\nsapply(split(quine$Days, quine$Age), \n       \\(x){\n         c(Mean = mean(x), Median = median(x))\n       }\n)\n\n             F0       F1    F2       F3\nMean   14.85185 11.15217 21.05 19.60606\nMedian 11.00000  6.00000 14.00 18.00000\n\n\nTo group by more than one factor—say, both Age and Sex—we can pass a list of factors to split():\n\nsapply(split(quine$Days, list(quine$Age, quine$Sex)),\n       \\(x) {\n         c(Mean = mean(x), Median = median(x))\n       }\n)\n\n       F0.F     F1.F     F2.F F3.F     F0.M F1.M     F2.M     F3.M\nMean   18.7 12.96875 18.42105   14 12.58824  7.0 23.42857 27.21429\nMedian 15.5  7.00000 10.00000   10 11.00000  5.5 17.00000 27.50000\n\n\nThis approach is especially powerful when used with anonymous functions. It allows us to write concise, flexible code that can be adapted to a wide range of grouped operations.\nWhy Prefer split() with sapply()?\nAlthough tapply() is convenient for computing a single summary statistic per group, it becomes less manageable when:\n\nmore than one grouping factor is used, and\nthe applied function returns multiple values (e.g., mean and median).\n\nConsider the following example:\n\ntapply(quine$Days, list(quine$Age, quine$Sex), \\(x) {\n  c(Mean = mean(x), Median = median(x))\n})\n\n   F         M        \nF0 numeric,2 numeric,2\nF1 numeric,2 numeric,2\nF2 numeric,2 numeric,2\nF3 numeric,2 numeric,2\n\n\nThis returns a matrix-like object where each cell contains a vector of length two.\nWhile technically correct, this result can be cumbersome to work with, especially if you’re trying to extract or manipulate specific summary values later on.\nIn contrast, the combination of split() and sapply() provides more predictable and structured output, typically in the form of a named matrix or list. This makes it easier to interpret and use in subsequent steps of your analysis.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "iteration.html#when-to-use-loops-vs-vectorized-solutions",
    "href": "iteration.html#when-to-use-loops-vs-vectorized-solutions",
    "title": "6  Iteration",
    "section": "6.3 When to Use Loops vs Vectorized Solutions",
    "text": "6.3 When to Use Loops vs Vectorized Solutions\nIn R, many tasks can be accomplished in multiple ways—sometimes using explicit loops, and other times using vectorized operations or built-in functions like apply() or ifelse(). Understanding when to use each approach will help you write code that is both efficient and easy to read.\nLoops give you full control over each step of the process. This makes them useful when:\nEach iteration depends on the result of the previous one.\nYou need to perform a sequence of actions, not just a simple calculation.\nThe operation involves conditional branching or custom output formatting.\nThe logic cannot easily be expressed as a one-liner.\nFor example, if you are simulating a process like a coin toss that continues until a certain condition is met, or checking for transitions between values in a sequence, a loop is often the most natural tool.\nOn the other hand, vectorized solutions are generally preferred when:\nYou are applying the same simple operation to every element in a vector or list.\nThe task can be expressed clearly using built-in functions like mean(), sum(), ifelse(), or apply() family functions.\nPerformance is a concern—vectorized code is often faster because it is optimized under the hood in R’s C-based engine.\nFor example, classifying a set of temperature readings as “Hot” or “Cold” can be done more succinctly with ifelse() than with a loop. Likewise, calculating column means or row sums is more concise (and faster) using colMeans() or rowSums() than writing a loop.\nIn general, it’s a good idea to start with loops when you’re learning or developing new logic. Once you’re confident in how your code works, you can often rewrite parts of it using vectorized solutions for simplicity and speed. Both tools have their place, and part of becoming fluent in R is knowing which one is best suited for the task at hand.\n\n\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023. R for Data Science. 2nd ed. O’Reilly Media. https://r4ds.hadley.nz/functions.html.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "iteration.html#when-to-use-loops-apply-type-functions-or-vectorized-calculations",
    "href": "iteration.html#when-to-use-loops-apply-type-functions-or-vectorized-calculations",
    "title": "6  Iteration",
    "section": "6.3 When to Use Loops, Apply-Type Functions, or Vectorized Calculations",
    "text": "6.3 When to Use Loops, Apply-Type Functions, or Vectorized Calculations\nIn R, you’ll often find that a task can be solved in several different ways. The three most common approaches are:\n\nUsing loops (for, while, or repeat)\nUsing apply-type functions (like apply(), lapply(), sapply(), tapply(), vapply())\nUsing vectorized operations (like mean(), sum(), ifelse(), colMeans(), and arithmetic on entire vectors)\n\nUnderstanding the strengths and use cases of each will help you write clearer and more efficient R code.\nWhen to Use Loops\nLoops give you full control over each step of a process. They’re ideal when:\n\nEach step depends on the result of the previous one. Example: tracking a running total or detecting state transitions in a time series\nYou need to perform a custom sequence of actions. Example: printing different messages, updating external variables\nThe logic is complex or has conditional branching. Example: applying different formulas based on user input or specific criteria\nYou are prototyping or still learning the logic. Loops are easy to read and good for step-by-step debugging\n\nHowever, a common downside of loops is that the result is often embedded inside the loop, such as being updated step by step. This can make it harder for others (or even yourself later) to figure out what the loop is producing unless they read through the whole body.\nWhen to Use Apply-Type Functions\nApply-type functions offer a middle ground between loops and vectorized code. They let you repeat an operation over elements of a list, matrix, or grouped data, often in fewer lines than a loop.\n\nUse apply() for rows or columns of a matrix\nUse lapply() or sapply() for elements in a list or columns in a data frame\nUse vapply() when you want to enforce the type and length of the result\nUse tapply() or split() + sapply() to summarize values by groups\n\nThese functions are especially useful when:\n\nThe task is repetitive and follows a predictable pattern\nYou want cleaner code without writing an explicit loop\nYou’re applying the same function to multiple elements or groups\n\nApply-type functions also work well with anonymous functions, such as \\(x) x^2, making them ideal for short, one-time logic.\nWhen to Use Vectorized Calculations\nVectorized operations are fast, expressive, and concise. Whenever your logic can be expressed as an operation on entire vectors, this is the preferred route.\nUse vectorized functions when:\n\nYou’re applying the same simple transformation to every element\nYou are classifying, summarizing, or transforming numeric or logical vectors\nBuilt-in functions already exist for the task (e.g., mean(), sum(), ifelse())\n\nVectorized code is usually more efficient because it’s executed in compiled C code under the hood. Examples:\n\nvalues &lt;- c(1, 10, 100, 1000)\nlog(values)  # Vectorized log transformation\n\n[1] 0.000000 2.302585 4.605170 6.907755\n\n\nIn general, start with loops when you’re developing or learning, then refactor using apply-type or vectorized solutions for clarity and performance. Prefer apply-type functions when you want a readable result that’s clearly assigned, rather than hidden inside the loop body.\n\n\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023. R for Data Science. 2nd ed. O’Reilly Media. https://r4ds.hadley.nz/functions.html.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Iteration</span>"
    ]
  }
]